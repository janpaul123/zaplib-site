{"version":3,"file":"test_suite.js","mappings":"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","sources":["webpack://zaplib/webpack/universalModuleDefinition","webpack://zaplib/./zaplib.css","webpack://zaplib/./node_modules/css-loader/dist/runtime/api.js","webpack://zaplib/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack://zaplib/./common.ts","webpack://zaplib/./test_suite/test_helpers.ts","webpack://zaplib/./type_of_runtime.ts","webpack://zaplib/./types.ts","webpack://zaplib/./zap_buffer.ts","webpack://zaplib/./main_worker.ts","webpack://zaplib/./async_worker.ts","webpack://zaplib/./task_worker.ts","webpack://zaplib/./make_rpc_event.ts","webpack://zaplib/./rpc_types.ts","webpack://zaplib/./make_textarea.ts","webpack://zaplib/./webgl_renderer.ts","webpack://zaplib/./default_styles.ts","webpack://zaplib/./wasm_runtime.ts","webpack://zaplib/./loading_indicator.ts","webpack://zaplib/./cursor_map.ts","webpack://zaplib/./zerde_keyboard_handlers.ts","webpack://zaplib/./cef_runtime.ts","webpack://zaplib/./zaplib.css?4485","webpack://zaplib/./zaplib_runtime.ts","webpack://zaplib/./zerde.ts","webpack://zaplib/./node_modules/worker-loader/dist/runtime/inline.js","webpack://zaplib/webpack/bootstrap","webpack://zaplib/webpack/runtime/compat get default export","webpack://zaplib/webpack/runtime/define property getters","webpack://zaplib/webpack/runtime/hasOwnProperty shorthand","webpack://zaplib/webpack/runtime/make namespace object","webpack://zaplib/./test_suite/zap_buffer_test.ts","webpack://zaplib/./test_suite/test_suite.ts","webpack://zaplib/./test_suite/test_suite_worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"zaplib\"] = factory();\n\telse\n\t\troot[\"zaplib\"] = factory();\n})(self, function() {\nreturn ","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"./node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"./node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".zaplib_canvas {\\n    position: absolute; /* For z-index */\\n    top: 0;\\n    left: 0;\\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\\n    z-index: 2147483647;\\n    width: 100%;\\n    height: 100%;\\n    pointer-events: none;\\n    user-select: none;\\n    touch-action: pan-x pan-y; /* Mobile Safari doesn't support \\\"none\\\" */\\n}\\n\\ntextarea.zaplib_textarea {\\n    z-index: 1000;\\n    position: absolute;\\n    opacity: 0;\\n    border-radius: 4px;\\n    color:white;\\n    font-size: 6;\\n    background: gray;\\n    -moz-appearance: none;\\n    appearance:none;\\n    border:none;\\n    resize: none;\\n    outline: none;\\n    overflow: hidden;\\n    text-indent: 0px;\\n    padding: 0 0px;\\n    margin: 0 -1px;\\n    text-indent: 0px;\\n    -ms-user-select: text;\\n    -moz-user-select: text;\\n    -webkit-user-select: text;\\n    user-select: text;\\n    white-space: pre!important;\\n}\\ntextarea:focus.zaplib_textarea {\\n    outline: 0px !important;\\n    -webkit-appearance: none;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./zaplib.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,kBAAkB,EAAE,gBAAgB;IACpC,MAAM;IACN,OAAO;IACP,uHAAuH;IACvH,mBAAmB;IACnB,WAAW;IACX,YAAY;IACZ,oBAAoB;IACpB,iBAAiB;IACjB,yBAAyB,EAAE,yCAAyC;AACxE;;AAEA;IACI,aAAa;IACb,kBAAkB;IAClB,UAAU;IACV,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,gBAAgB;IAChB,qBAAqB;IACrB,eAAe;IACf,WAAW;IACX,YAAY;IACZ,aAAa;IACb,gBAAgB;IAChB,gBAAgB;IAChB,cAAc;IACd,cAAc;IACd,gBAAgB;IAChB,qBAAqB;IACrB,sBAAsB;IACtB,yBAAyB;IACzB,iBAAiB;IACjB,0BAA0B;AAC9B;AACA;IACI,uBAAuB;IACvB,wBAAwB;AAC5B\",\"sourcesContent\":[\".zaplib_canvas {\\n    position: absolute; /* For z-index */\\n    top: 0;\\n    left: 0;\\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\\n    z-index: 2147483647;\\n    width: 100%;\\n    height: 100%;\\n    pointer-events: none;\\n    user-select: none;\\n    touch-action: pan-x pan-y; /* Mobile Safari doesn't support \\\"none\\\" */\\n}\\n\\ntextarea.zaplib_textarea {\\n    z-index: 1000;\\n    position: absolute;\\n    opacity: 0;\\n    border-radius: 4px;\\n    color:white;\\n    font-size: 6;\\n    background: gray;\\n    -moz-appearance: none;\\n    appearance:none;\\n    border:none;\\n    resize: none;\\n    outline: none;\\n    overflow: hidden;\\n    text-indent: 0px;\\n    padding: 0 0px;\\n    margin: 0 -1px;\\n    text-indent: 0px;\\n    -ms-user-select: text;\\n    -moz-user-select: text;\\n    -webkit-user-select: text;\\n    user-select: text;\\n    white-space: pre!important;\\n}\\ntextarea:focus.zaplib_textarea {\\n    outline: 0px !important;\\n    -webkit-appearance: none;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","\"use strict\";\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","\"use strict\";\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;","// This file should only be imported by WebWorkers\n/// <reference lib=\"WebWorker\" />\nimport { ZapParamType, } from \"types\";\nimport { getCachedZapBuffer, getZapBufferWasm } from \"zap_buffer\";\nimport { ZerdeBuilder } from \"zerde\";\nconst RESPONSE = \"$$RESPONSE\";\nconst ERROR = \"$$ERROR\";\n// helper function to create linked channels for testing\nfunction _createLinkedChannels() {\n    const local = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (remote.onmessage) {\n                remote.onmessage(ev);\n            }\n        },\n    };\n    const remote = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (local.onmessage) {\n                local.onmessage(ev);\n            }\n        },\n    };\n    return { local, remote };\n}\n// This class allows you to hook up bi-directional async calls across web-worker\n// boundaries where a single call to or from a worker can 'wait' on the response.\n// Errors in receivers are propigated back to the caller as a rejection.\n// It also supports returning transferrables over the web-worker postMessage api,\n// which was the main shortcomming with the worker-rpc npm module.\n// To attach rpc to an instance of a worker in the main thread:\n//   const rpc = new Rpc(workerInstace);\n// To attach rpc within an a web worker:\n//   const rpc = new Rpc(global);\n// Check out the tests for more examples.\n// See `rpc_types.ts` for descriptions of how to set up typed interactions.\nexport class Rpc {\n    constructor(channel) {\n        this._messageId = 0;\n        this._pendingCallbacks = {};\n        this._receivers = new Map();\n        this._onChannelMessage = (ev) => {\n            const { id, topic, data } = ev.data;\n            if (topic === RESPONSE) {\n                this._pendingCallbacks[id](ev.data);\n                delete this._pendingCallbacks[id];\n                return;\n            }\n            // invoke the receive handler in a promise so if it throws synchronously we can reject\n            new Promise((resolve) => {\n                const handler = this._receivers.get(topic);\n                if (!handler) {\n                    throw new Error(`no receiver registered for ${topic}`);\n                }\n                // This works both when `handler` returns a value or a Promise.\n                resolve(handler(data));\n            })\n                .then((result) => {\n                if (!result) {\n                    this.postMessage({ topic: RESPONSE, id }, []);\n                    return;\n                }\n                const transferrables = result[Rpc.transferrables];\n                delete result[Rpc.transferrables];\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: result,\n                };\n                this.postMessage(message, transferrables);\n            })\n                .catch((err) => {\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: {\n                        [ERROR]: true,\n                        name: err.name,\n                        message: err.message,\n                        stack: err.stack,\n                    },\n                };\n                this.postMessage(message, []);\n            });\n        };\n        this._channel = channel;\n        if (this._channel.onmessage) {\n            throw new Error(\"channel.onmessage is already set. Can only use one Rpc instance per channel.\");\n        }\n        this._channel.onmessage = this._onChannelMessage;\n    }\n    // send a message across the rpc boundary to a receiver on the other side\n    // this returns a promise for the receiver's response.  If there is no registered\n    // receiver for the given topic, this method throws\n    send(topic, data, transfer) {\n        const id = this._messageId++;\n        const message = { topic, id, data };\n        const result = new Promise((resolve, reject) => {\n            this._pendingCallbacks[id] = (info) => {\n                if (info.data && info.data[ERROR]) {\n                    const error = new Error(info.data.message);\n                    error.name = info.data.name;\n                    error.stack = info.data.stack;\n                    reject(error);\n                }\n                else {\n                    resolve(info.data);\n                }\n            };\n        });\n        this.postMessage(message, transfer);\n        return result;\n    }\n    // register a receiver for a given message on a topic\n    // only one receiver can be registered per topic and currently\n    // 'deregistering' a receiver is not supported since this is not common\n    receive(topic, handler) {\n        if (this._receivers.has(topic)) {\n            throw new Error(`Receiver already registered for topic: ${topic}`);\n        }\n        this._receivers.set(topic, handler);\n    }\n    postMessage(message, transfer) {\n        try {\n            this._channel.postMessage(message, transfer);\n        }\n        catch (e) {\n            console.error(\"Rpc postMessage call itself failed: \", e);\n        }\n    }\n}\nRpc.transferrables = \"$$TRANSFERRABLES\";\n////////////////////////////////////////////////////////////////\n// Mutex\n////////////////////////////////////////////////////////////////\nconst MUTEX_UNLOCKED = 0;\nconst MUTEX_LOCKED = 1;\nexport const mutexLock = (sabi32, offset) => {\n    // This needs to be in a loop, because between the `wait` and `compareExchange` another thread might\n    // take the Mutex.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (Atomics.compareExchange(sabi32, offset, MUTEX_UNLOCKED, MUTEX_LOCKED) ==\n            MUTEX_UNLOCKED) {\n            return;\n        }\n        Atomics.wait(sabi32, offset, MUTEX_LOCKED);\n    }\n};\nexport const mutexUnlock = (sabi32, offset) => {\n    if (Atomics.compareExchange(sabi32, offset, MUTEX_LOCKED, MUTEX_UNLOCKED) !=\n        MUTEX_LOCKED) {\n        throw new Error(\"Called mutex_unlock on an already unlocked mutex\");\n    }\n    Atomics.notify(sabi32, offset, 1);\n};\n////////////////////////////////////////////////////////////////\n// Task worker\n////////////////////////////////////////////////////////////////\nexport const TW_SAB_MUTEX_PTR = 0;\nexport const TW_SAB_MESSAGE_COUNT_PTR = 1;\n// Initialize a SharedArrayBuffer used to communicate with task_worker.ts. This\n// is a one-way communication channel; use pointers into `memory` for communicating\n// information back.\n//\n// We use this because we typically can't use `postMessage`; see task_worker.ts\n// for more details.\n//\n// Format:\n// * i32 (4 bytes)         - read/write mutex\n// * i32 (4 bytes)         - number of messages in queue (notify on this to wake up the task worker - it will\n//                           read this before taking a mutex, but then reread it after taking the mutex)\n// * n * u32 (n * 4 bytes) - pointers to messages serialized with `ZerdeBuilder`\nexport const initTaskWorkerSab = () => {\n    const bufferSizeBytes = 10000;\n    const taskWorkerSab = new SharedArrayBuffer(bufferSizeBytes);\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    taskWorkerSabi32[TW_SAB_MUTEX_PTR] = MUTEX_UNLOCKED;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = 0;\n    return taskWorkerSab;\n};\n// Append a new message pointer to the SharedArrayBuffer used by task_worker.ts,\n// and wake it up so it can process this new message (unless it's currently in polling\n// mode, in that case the `Atomics.notify` will just not do anything).\nconst sendTaskWorkerMessage = (taskWorkerSab, twMessagePtr) => {\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    mutexLock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    const currentNumberOfMessages = taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR];\n    // Use unsigned numbers for the actual pointer, since they can be >2GB.\n    new Uint32Array(taskWorkerSab)[currentNumberOfMessages + 2] = twMessagePtr;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = currentNumberOfMessages + 1;\n    mutexUnlock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    Atomics.notify(taskWorkerSabi32, 1);\n};\n////////////////////////////////////////////////////////////////\n// Wasm Thread initialization\n////////////////////////////////////////////////////////////////\n// Threads in WebAssembly! They are.. fun! Here's what happens.\n//\n// The first Wasm instance we start is in the main worker. It does the following:\n// - It initializes static memory using `__wasm_init_memory`, which is automatically set\n//   by LLVM as the special \"start\" function.\n// - It already has memory allocated for the \"shadow stack\". This is like any stack in a\n//   native program, but in WebAssembly it's called the \"shadow stack\" because WebAssembly\n//   itself also has a notion of a stack built-in. It is however not suitable for all\n//   kinds of data, which is why we need another separate stack.\n// - We allocate Thread Local Storage (TLS) by allocating some memory on the heap (an\n//   operation which by itself should not require TLS; otherwise we'd have a Catch-22\n//   situation..), and calling `initThreadLocalStorageMainWorker` with it.\n//\n// Then, when we make any other WebAssembly threads (e.g. in our own WebWorkers, or in\n// the WebWorkers of users), we do the following:\n// - `__wasm_init_memory` is again called automatically, but will be skipped, since an\n//   (atomic) flag has been set not to initialize static memory again.\n// - We need to initialize memory for both the shadow stack and the Thread Local\n//   Storage (TLS), using `makeThreadLocalStorageAndStackDataOnExistingThread`. We do this\n//   by allocating memory on the heap on an already initialized thread, since allocating memory DOES\n//   require the shadow stack to be initialized.\n// - We then use this memory for both the TLS (on the lower side) and the shadow stack\n//   (on the upper side, since it moves downward), using `initThreadLocalStorageAndStackOtherWorkers`.\n//\n// TODO(JP): This currently leaks memory since we never deallocate the TLS/shadow stack!\n//\n// TODO(JP): Even if we do deallocate the memory, there is currently no way to call TLS\n// destructors; so we'd still leak memory. See https://github.com/rust-lang/rust/issues/77839\n// The \"shadow stack\" size for new threads. Note that the main thread will\n// keep using its own shadow stack size.\nconst WASM_STACK_SIZE_BYTES = 2 * 1024 * 1024; // 2 MB\n// For the main worker, we only need to initialize Thread Local Storage (TLS).\nexport const initThreadLocalStorageMainWorker = (wasmExports) => {\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(wasmExports.__tls_size.value));\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    wasmExports.__wasm_init_tls(Number(ptr));\n};\n// For non-main workers, we need to allocate enough data for Thread Local Storage (TLS)\n// and the \"shadow stack\". We allocate this data in the main worker, and then send the\n// pointer + size to other workers.\n//\n// This is easier than trying to allocate the appropriate amount of data in the other\n// itself, which is possible (e.g. using memory.grow) but kind of cumbersome.\nexport const makeThreadLocalStorageAndStackDataOnExistingThread = (wasmExports) => {\n    // Align size to 64 bits / 8 bytes.\n    const size = Math.ceil((wasmExports.__tls_size.value + WASM_STACK_SIZE_BYTES) / 8) * 8;\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(size));\n    return { ptr, size };\n};\n// Set the shadow stack pointer and initialize thet Thread Local Storage (TLS).\n//\n// Note that the TLS sits on the lower side of the memory, wheras the shadow stack\n// starts on the upper side of the memory and grows downwards.\n//\n// TODO(JP): __wasm_init_tls takes a Number, which might not work when it is >2GB.\nexport const initThreadLocalStorageAndStackOtherWorkers = (wasmExports, tlsAndStackData) => {\n    // Start the shadow stack pointer on the upper side of the memory, though subtract\n    // 8 so we don't overwrite the byte right after the memory, while still keeping it\n    // 64-bit aligned. TODO(JP): Is the 64-bit alignment necessary for the shadow stack?\n    wasmExports.__stack_pointer.value =\n        Number(tlsAndStackData.ptr) + tlsAndStackData.size - 8;\n    wasmExports.__wasm_init_tls(\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    Number(tlsAndStackData.ptr));\n};\n////////////////////////////////////////////////////////////////\n// Common wasm functions\n////////////////////////////////////////////////////////////////\nexport const copyArrayToRustBuffer = (inputBuffer, outputBuffer, outputPtr) => {\n    // should be the same type as inputBuffer\n    // @ts-ignore: constructor is getting typed as Function instead of a constructor\n    new inputBuffer.constructor(outputBuffer, outputPtr, inputBuffer.length).set(inputBuffer);\n};\nexport const getZapParamType = (array, readonly) => {\n    if (array instanceof Uint8Array) {\n        return readonly ? ZapParamType.ReadOnlyU8Buffer : ZapParamType.U8Buffer;\n    }\n    else if (array instanceof Float32Array) {\n        return readonly ? ZapParamType.ReadOnlyF32Buffer : ZapParamType.F32Buffer;\n    }\n    else {\n        throw new Error(\"Invalid array type\");\n    }\n};\nexport const createWasmBuffer = (memory, exports, data) => {\n    const vecPtr = Number(exports.allocWasmVec(BigInt(data.byteLength)));\n    copyArrayToRustBuffer(data, memory.buffer, vecPtr);\n    return vecPtr;\n};\nexport const makeZerdeBuilder = (memory, wasmExports) => {\n    const slots = 1024;\n    // We have get memory.buffer *after* calling `allocWasmMessage`, because\n    // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n    const byteOffset = Number(wasmExports.allocWasmMessage(BigInt(slots * 4)));\n    return new ZerdeBuilder({\n        buffer: memory.buffer,\n        byteOffset: byteOffset,\n        slots,\n        growCallback: (_buffer, oldByteOffset, newBytes) => {\n            const newByteOffset = Number(wasmExports.reallocWasmMessage(BigInt(oldByteOffset), BigInt(newBytes)));\n            // We have get memory.buffer *after* calling `reallocWasmMessage`, because\n            // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n            return { buffer: memory.buffer, byteOffset: newByteOffset };\n        },\n    });\n};\nexport const getWasmEnv = ({ getExports, memory, taskWorkerSab, fileHandles, sendEventFromAnyThread, threadSpawn, baseUri, }) => {\n    const parseString = (ptr, len) => {\n        let out = \"\";\n        // Can't use TextDecoder here since it doesn't work with SharedArrayBuffer.\n        // TODO(JP): If it becomes important enough, we can see if making a copy to a regular\n        // ArrayBuffer and then using TextDecoder is faster than what we do here.\n        const array = new Uint32Array(memory.buffer, ptr, len);\n        for (let i = 0; i < len; i++) {\n            out += String.fromCharCode(array[i]);\n        }\n        return out;\n    };\n    return {\n        memory,\n        _consoleLog: (charsPtr, len) => {\n            const out = parseString(parseInt(charsPtr), parseInt(len));\n            console.log(out);\n        },\n        _throwError: (charsPtr, len) => {\n            throw new RustPanic(parseString(parseInt(charsPtr), parseInt(len)));\n        },\n        readUserFileRange: (userFileId, bufPtr, bufLen, fileOffset) => {\n            const file = fileHandles[userFileId];\n            const start = Number(fileOffset);\n            const end = start + Number(bufLen);\n            if (file.lastReadStart <= start && start < file.lastReadEnd) {\n                console.warn(`Read start (${start}) fell in the range of the last read (${file.lastReadStart}-${file.lastReadEnd}); ` +\n                    \"this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.\");\n            }\n            file.lastReadStart = start;\n            file.lastReadEnd = end;\n            // TODO(JP): This creates a new buffer instead of reading directly into the wasm memory.\n            // Maybe we can avoid this by using a stream with a ReadableStreamBYOBReader, but that is\n            // asynchronous, so we'd have to do a dance with another thread and atomics and all that,\n            // and I don't know if that overhead would be worth it..\n            const fileReaderSync = new FileReaderSync();\n            const buffer = fileReaderSync.readAsArrayBuffer(file.file.slice(start, end));\n            copyArrayToRustBuffer(new Uint8Array(buffer), memory.buffer, Number(bufPtr));\n            return BigInt(buffer.byteLength);\n        },\n        performanceNow: () => {\n            return performance.now();\n        },\n        threadSpawn: (ctxPtr) => {\n            threadSpawn(ctxPtr);\n        },\n        _sendEventFromAnyThread: (eventPtr) => {\n            sendEventFromAnyThread(eventPtr);\n        },\n        readUrlSync: (urlPtr, urlLen, bufPtrOut, bufLenOut) => {\n            const url = parseString(urlPtr, urlLen);\n            const request = new XMLHttpRequest();\n            request.responseType = \"arraybuffer\";\n            request.open(\"GET\", new URL(url, baseUri).href, false /* synchronous */);\n            request.send(null);\n            if (request.status === 200) {\n                const exports = getExports();\n                const outputBufPtr = createWasmBuffer(memory, exports, new Uint8Array(request.response));\n                new Uint32Array(memory.buffer, bufPtrOut, 1)[0] = outputBufPtr;\n                new Uint32Array(memory.buffer, bufLenOut, 1)[0] =\n                    request.response.byteLength;\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        },\n        randomU64: () => new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],\n        sendTaskWorkerMessage: (twMessagePtr) => {\n            sendTaskWorkerMessage(taskWorkerSab, parseInt(twMessagePtr));\n        },\n    };\n};\nexport function transformParamsFromRustImpl(memory, destructor, mutableDestructor, params) {\n    return params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else {\n            const zapBuffer = getZapBufferWasm(memory, param, destructor, mutableDestructor);\n            if (param.paramType === ZapParamType.String) {\n                throw new Error(\"ZapParam buffer type called with string paramType\");\n            }\n            // These are actually ZapArray types, since we overwrite TypedArrays in overwriteTypedArraysWithZapArrays()\n            const ArrayConstructor = {\n                [ZapParamType.U8Buffer]: Uint8Array,\n                [ZapParamType.ReadOnlyU8Buffer]: Uint8Array,\n                [ZapParamType.F32Buffer]: Float32Array,\n                [ZapParamType.ReadOnlyF32Buffer]: Float32Array,\n            }[param.paramType];\n            return getCachedZapBuffer(zapBuffer, new ArrayConstructor(zapBuffer, param.bufferPtr, param.bufferLen / ArrayConstructor.BYTES_PER_ELEMENT));\n        }\n    });\n}\nexport function assertNotNull(value, objectName = \"Value\") {\n    if (value === null || value === undefined) {\n        throw new Error(`Assertion failed: ${objectName} is null`);\n    }\n    return value;\n}\nexport class RustPanic extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"RustPanic\";\n    }\n}\nexport const createErrorCheckers = (wasmInitialized) => {\n    const checkWasm = () => {\n        if (!wasmInitialized())\n            throw new Error(\"Zaplib WebAssembly instance crashed\");\n    };\n    return {\n        checkWasm,\n        wrapWasmExports: (exports) => new Proxy(exports, {\n            get: function (obj, prop) {\n                checkWasm();\n                return obj[prop];\n            },\n        }),\n    };\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { jsRuntime } from \"type_of_runtime\";\nimport { allocatedArcs, allocatedVecs } from \"zap_buffer\";\nexport const expect = (actual, expected) => {\n    if (expected === actual) {\n        console.debug(`Success: Got ${actual}, Expected ${expected}`);\n    }\n    else {\n        throw new Error(`Failure: Got ${actual}, Expected ${expected}`);\n    }\n};\n// TODO(Paras): Would be nice to combine the two functions below at some point.\nexport const expectThrow = (f, expectedMessage) => {\n    let error;\n    try {\n        f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n};\nexport const expectThrowAsync = (f, expectedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n    let error;\n    try {\n        yield f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n});\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst checkConditionTimeout = (condition, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n    const startTime = performance.now();\n    while (!condition() && performance.now() < startTime + timeout) {\n        yield sleep(10);\n    }\n    return condition();\n});\n// Generate some dummy data and then delete it. This usually triggers the garbage collector.\nconst generateGarbage = () => {\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        self[\"garbage_\" + i] = { i };\n    }\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        delete self[\"garbage_\" + i];\n    }\n};\nconst arcAllocated = (callRust, buffer) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!buffer.__zaplibBufferData.readonly)\n        throw new Error(\"arcAllocated called on mutable buffer\");\n    const arcPtr = buffer.__zaplibBufferData.arcPtr;\n    // We still have the buffer here! So it should still be allocated.\n    expect(allocatedArcs[arcPtr], true);\n    const [result] = yield callRust(\"check_arc_count\", [`${BigInt(arcPtr)}`]);\n    const [countBeforeDeallocation] = result;\n    expect(countBeforeDeallocation, 1);\n    return arcPtr;\n});\nconst arcDeallocated = (arcPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // From here on out we don't refer to `buffer` anymore, so it should get\n    // deallocated, if the garbage collector is any good.\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return allocatedArcs[arcPtr] === false;\n    }, 20000), true);\n});\nconst vecDeallocated = (bufferPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // Even though we have the buffer, it might have already been unregistered\n    // when passed to Rust. We shouldn't read/write to it anymore. If this is the\n    // case, let's just bail.\n    if (!allocatedVecs[bufferPtr])\n        return;\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return allocatedVecs[bufferPtr] === false;\n    }, 20000), true);\n});\n// Test that ZapBuffers were deallocated at some point in the next 20 seconds.\n// This is a bit brittle given that there are no guarantees for garbage collection during this time,\n// but observationally this ends up being enough time. The caller must also ensure that the buffer will go out of scope\n// shortly after calling this.\n// We have to pass in `callRust` because we can call this function from a variety of runtimes.\n// Note that assertions on garbage collection are extremely sensitive to exactly how these functions are written,\n// and can easily break if you restucture the function, use a different/newer browser, etc!\nexport const expectDeallocationOrUnregister = (callRust, zapArray) => {\n    // Deallocation code is only run in WASM for now.\n    if (jsRuntime === \"cef\")\n        return Promise.resolve();\n    const buffer = zapArray.buffer;\n    return buffer.readonly\n        ? arcAllocated(callRust, buffer).then((arcPtr) => arcDeallocated(arcPtr))\n        : vecDeallocated(buffer.__zaplibBufferData.bufferPtr);\n};\nexport let inTest = false;\n// Set this to true to enable testing code\nexport const setInTest = (v) => {\n    inTest = v;\n};\n","// We only define `cefCallRust` if in CEF, so we can use this for environment detection.\n// This should only be used at the top level `zaplib_runtime` file or in test, since we want to keep\n// CEF and WASM code separate for bundle size.\nexport const jsRuntime = \"cefCallRust\" in self ? \"cef\" : \"wasm\";\n// Whether or not we're in a WebWorker.\n// From https://stackoverflow.com/a/23619712\nexport const inWorker = typeof importScripts === \"function\";\nexport const gitSha = __GIT_SHA__;\n","// Keep in sync with `param.rs`\nexport var ZapParamType;\n(function (ZapParamType) {\n    ZapParamType[ZapParamType[\"String\"] = 0] = \"String\";\n    ZapParamType[ZapParamType[\"ReadOnlyU8Buffer\"] = 1] = \"ReadOnlyU8Buffer\";\n    ZapParamType[ZapParamType[\"U8Buffer\"] = 2] = \"U8Buffer\";\n    ZapParamType[ZapParamType[\"F32Buffer\"] = 3] = \"F32Buffer\";\n    ZapParamType[ZapParamType[\"ReadOnlyF32Buffer\"] = 4] = \"ReadOnlyF32Buffer\";\n})(ZapParamType || (ZapParamType = {}));\n","// Wrapper around SharedArrayBuffer to encapsulate ownership of particular segments of it\nimport { getZapParamType } from \"common\";\nimport { ZapParamType } from \"types\";\nimport { inTest } from \"test_suite/test_helpers\";\n// TODO(Paras) - Make sure we monkeypatch on web workers as well\nexport class ZapBuffer extends SharedArrayBuffer {\n    constructor(buffer, bufferData) {\n        super(0);\n        this.__zaplibWasmBuffer = buffer;\n        this.__zaplibBufferData = bufferData;\n    }\n    // TODO(Paras): Actually enforce this flag and prevent mutation of ZapArrays marked as readonly.\n    // Potentially, we can do this by hashing read only buffer data and periodically checking in debug\n    // builds if they have been modified/raising errors.\n    get readonly() {\n        return this.__zaplibBufferData.readonly;\n    }\n    // The only 2 methods on SharedArrayBuffer class to override:\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#instance_properties\n    get byteLength() {\n        return this.__zaplibWasmBuffer.byteLength;\n    }\n    slice(...args) {\n        return this.__zaplibWasmBuffer.slice(...args);\n    }\n}\n// This class is a drop-in replacement for all typed arrays\n// It uses ZapBuffer as a handle for underlying buffer as the object that keeps underlying data around\n// Requirements:\n//  * The underlying typed array behaves like it was created over the original view\n//  * When the new typed array (potentially with different class name) is created from the buffer of the original one,\n//  they share the same handle\n//\n// The Rust side assumes that underlying data buffer is immutable,\n// however it still could be accidentally modified on JS side leading to weird behavior\n// TODO(Dmitry): Throw an error if there is mutation of the data\nfunction zapBufferExtends(cls) {\n    return class ZapTypedArray extends cls {\n        constructor(...args) {\n            const buffer = args[0];\n            if (typeof buffer === \"object\" && buffer instanceof ZapBuffer) {\n                // Fill in byteOffset if that's omitted.\n                if (args.length < 2) {\n                    args[1] = buffer.__zaplibBufferData.bufferPtr;\n                }\n                // Fill in length (in elements, not in bytes) if that's omitted.\n                if (args.length < 3) {\n                    args[2] = Math.floor((buffer.__zaplibBufferData.bufferPtr +\n                        buffer.__zaplibBufferData.bufferLen -\n                        args[1]) /\n                        cls.BYTES_PER_ELEMENT);\n                }\n                if (args[1] < buffer.__zaplibBufferData.bufferPtr) {\n                    throw new Error(`Byte_offset ${args[1]} is out of bounds`);\n                }\n                if (args[1] + args[2] * cls.BYTES_PER_ELEMENT >\n                    buffer.__zaplibBufferData.bufferPtr +\n                        buffer.__zaplibBufferData.bufferLen) {\n                    throw new Error(`Byte_offset ${args[1]} + length ${args[2]} is out of bounds`);\n                }\n                // Whenever we create ZapUintArray using ZapBuffer as first argument\n                // pass the underlying full wasm_buffer further\n                args[0] = buffer.__zaplibWasmBuffer;\n                super(...args);\n                this.__zaplibBuffer = buffer;\n            }\n            else {\n                super(...args);\n            }\n        }\n        get buffer() {\n            return this.__zaplibBuffer || super.buffer;\n        }\n        subarray(begin = 0, end = this.length) {\n            if (begin < 0) {\n                begin = this.length + begin;\n            }\n            if (end < 0) {\n                end = this.length + end;\n            }\n            if (end < begin) {\n                end = begin;\n            }\n            return new ZapTypedArray(this.buffer, this.byteOffset + begin * this.BYTES_PER_ELEMENT, end - begin);\n        }\n    };\n}\n// Extending all typed arrays\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#indexed_collections\nexport const classesToExtend = {\n    Int8Array: \"ZapInt8Array\",\n    Uint8Array: \"ZapUint8Array\",\n    Uint8ClampedArray: \"ZapUint8ClampedArray\",\n    Int16Array: \"ZapInt16Array\",\n    Uint16Array: \"ZapUint16Array\",\n    Uint16ClampedArray: \"ZapUint16ClampedArray\",\n    Int32Array: \"ZapInt32Array\",\n    Uint32Array: \"ZapUint32Array\",\n    Float32Array: \"ZapFloat32Array\",\n    Float64Array: \"ZapFloat64Array\",\n    BigInt64Array: \"ZapBigInt64Array\",\n    BigUint64Array: \"ZapBigUint64Array\",\n    DataView: \"ZapDataView\",\n};\nfor (const [cls, zapCls] of Object.entries(classesToExtend)) {\n    // Get a new type name by prefixing old one with \"Zaplib\".\n    // e.g. Uint8Array is extended by ZapUint8Array, etc\n    if (cls in self) {\n        // @ts-ignore\n        self[zapCls] = zapBufferExtends(self[cls]);\n    }\n}\n// Checks if the given object itself or recursively contains ZapBuffers.\n// Exported for tests.\nexport function containsZapBuffer(object) {\n    if (typeof object != \"object\" || object === null) {\n        return false;\n    }\n    if (Object.prototype.hasOwnProperty.call(object, \"__zaplibBuffer\")) {\n        return true;\n    }\n    // Only supporting nesting for arrays, plain objects, maps and sets similar to StructuredClone algorithm\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types\n    if (Array.isArray(object) || object instanceof Set || object instanceof Map) {\n        for (const entry of object) {\n            if (containsZapBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    else if (Object.getPrototypeOf(object) === Object.getPrototypeOf({})) {\n        for (const entry of Object.entries(object)) {\n            if (containsZapBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction patchPostMessage(cls) {\n    const origPostMessage = cls.postMessage;\n    // Explicitly NOT a fat arrow (=>) since we want to keep the original `this`.\n    cls.postMessage = function (...args) {\n        if (containsZapBuffer(args[0])) {\n            // TODO(Dmitry): add a better error message showing the exact location of typed arrays\n            throw new Error(\"Sending ZapBuffers to/from workers is not supported - \" +\n                \"use .slice() on typed array instead to make an explicit copy\");\n        }\n        origPostMessage.apply(this, args);\n    };\n}\nexport function overwriteTypedArraysWithZapArrays() {\n    for (const [cls, zapCls] of Object.entries(classesToExtend)) {\n        if (cls in self) {\n            // @ts-ignore\n            self[cls] = self[zapCls];\n        }\n    }\n    patchPostMessage(self);\n    // In Safari nested workers are not defined.\n    if (self.Worker) {\n        patchPostMessage(self.Worker);\n    }\n    // Skipping this in nodejs case as web-worker polyfill doesn't provide MessagePort\n    if (self.MessagePort) {\n        patchPostMessage(self.MessagePort);\n    }\n}\nconst zapBufferCache = new WeakMap();\nexport function getCachedZapBuffer(zapBuffer, fallbackArray) {\n    var _a;\n    if (!(\n    // Overwrite the cached value if we return a pointer to a buffer of a different type\n    // For example, Rust code may cast a float to an u8 and return the same buffer pointer.\n    (((_a = zapBufferCache.get(zapBuffer)) === null || _a === void 0 ? void 0 : _a.BYTES_PER_ELEMENT) ===\n        fallbackArray.BYTES_PER_ELEMENT))) {\n        zapBufferCache.set(zapBuffer, fallbackArray);\n    }\n    return zapBufferCache.get(zapBuffer);\n}\nexport function isZapBuffer(potentialZapBuffer) {\n    return (typeof potentialZapBuffer === \"object\" &&\n        potentialZapBuffer instanceof ZapBuffer);\n}\nexport function checkValidZapArray(zapArray) {\n    if (!isZapBuffer(zapArray.buffer)) {\n        throw new Error(\"zapArray.buffer is not a ZapBuffer in checkValidZapArray\");\n    }\n    const buffer = zapArray.buffer;\n    const bufferCoversZapBuffer = zapArray.byteOffset === buffer.__zaplibBufferData.bufferPtr &&\n        zapArray.byteLength === buffer.__zaplibBufferData.bufferLen;\n    if (!bufferCoversZapBuffer) {\n        throw new Error(\"Called Rust with a buffer that does not span the entire underlying ZapBuffer\");\n    }\n    const paramType = getZapParamType(zapArray, buffer.readonly);\n    if (paramType !== buffer.__zaplibBufferData.paramType) {\n        throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${ZapParamType[buffer.__zaplibBufferData.paramType]} but got ${ZapParamType[paramType]}`);\n    }\n}\n// Cache ZapBuffers so that we have a stable identity for ZapBuffers pointing to the same\n// Arc. This is useful for any downstream caches in user code.\nconst bufferCache = {};\nexport const allocatedArcs = {};\nexport const allocatedVecs = {};\nconst bufferRegistry = new FinalizationRegistry(({ arcPtr, destructor, }) => {\n    if (inTest) {\n        if (allocatedArcs[arcPtr] === false) {\n            throw new Error(`Deallocating an already deallocated arcPtr ${arcPtr}`);\n        }\n        else if (allocatedArcs[arcPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated arcPtr ${arcPtr}`);\n        }\n        allocatedArcs[arcPtr] = false;\n    }\n    delete bufferCache[arcPtr];\n    if (destructor)\n        destructor(arcPtr);\n});\nconst mutableZapBufferRegistry = new FinalizationRegistry(({ bufferData, destructor, }) => {\n    if (inTest) {\n        const { bufferPtr } = bufferData;\n        if (allocatedVecs[bufferPtr] === false) {\n            throw new Error(`Deallocating an already deallocated bufferPtr ${bufferPtr}`);\n        }\n        else if (allocatedVecs[bufferPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated bufferPtr ${bufferPtr}`);\n        }\n        allocatedVecs[bufferPtr] = false;\n    }\n    destructor(bufferData);\n});\n// Return a buffer with a stable identity based on arcPtr.\n// Register callbacks so we de-allocate the buffer when it goes out of scope.\nexport const getZapBufferWasm = (wasmMemory, bufferData, destructor, mutableDestructor) => {\n    var _a;\n    if (bufferData.readonly) {\n        if (!((_a = bufferCache[bufferData.arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            if (inTest) {\n                allocatedArcs[bufferData.arcPtr] = true;\n            }\n            const zapBuffer = new ZapBuffer(wasmMemory.buffer, bufferData);\n            bufferRegistry.register(zapBuffer, {\n                arcPtr: bufferData.arcPtr,\n                destructor,\n                /* no unregisterToken here since we never need to unregister */\n            });\n            bufferCache[bufferData.arcPtr] = new WeakRef(zapBuffer);\n        }\n        else {\n            // If we already hold a reference, decrement the Arc we were just given;\n            // otherwise we leak memory.\n            destructor(bufferData.arcPtr);\n        }\n        return bufferCache[bufferData.arcPtr].deref();\n    }\n    else {\n        if (inTest) {\n            allocatedVecs[bufferData.bufferPtr] = true;\n        }\n        const zapBuffer = new ZapBuffer(wasmMemory.buffer, bufferData);\n        mutableZapBufferRegistry.register(zapBuffer, {\n            bufferData,\n            destructor: mutableDestructor,\n        }, zapBuffer);\n        return zapBuffer;\n    }\n};\n// Remove mutable ZapBuffers without running destructors. This is useful\n// when transferring ownership of buffers to Rust without deallocating data.\nexport const unregisterMutableBuffer = (zapBuffer) => {\n    if (zapBuffer.readonly) {\n        throw new Error(\"`unregisterMutableBuffer` should only be called on mutable ZapBuffers\");\n    }\n    mutableZapBufferRegistry.unregister(zapBuffer);\n    if (inTest) {\n        allocatedVecs[zapBuffer.__zaplibBufferData.bufferPtr] = false;\n    }\n};\n// Return a buffer with a stable identity based on arcPtr\nexport const getZapBufferCef = (buffer, arcPtr, paramType) => {\n    var _a;\n    if (arcPtr) {\n        if (!((_a = bufferCache[arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            const zapBuffer = new ZapBuffer(buffer, {\n                bufferPtr: 0,\n                bufferLen: buffer.byteLength,\n                readonly: true,\n                paramType,\n                // TODO(Paras): These fields below do not apply to CEF\n                arcPtr: -1,\n            });\n            bufferRegistry.register(zapBuffer, { arcPtr });\n            bufferCache[arcPtr] = new WeakRef(zapBuffer);\n        }\n        return bufferCache[arcPtr].deref();\n    }\n    else {\n        return new ZapBuffer(buffer, {\n            bufferPtr: 0,\n            bufferLen: buffer.byteLength,\n            bufferCap: buffer.byteLength,\n            paramType,\n            readonly: false,\n        });\n    }\n};\n","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";const e=[\\\"none\\\",\\\"default\\\",\\\"crosshair\\\",\\\"pointer\\\",\\\"default\\\",\\\"move\\\",\\\"text\\\",\\\"wait\\\",\\\"help\\\",\\\"not-allowed\\\",\\\"n-resize\\\",\\\"ne-resize\\\",\\\"e-resize\\\",\\\"se-resize\\\",\\\"s-resize\\\",\\\"sw-resize\\\",\\\"w-resize\\\",\\\"nw-resize\\\",\\\"ns-resize\\\",\\\"nesw-resize\\\",\\\"ew-resize\\\",\\\"nwse-resize\\\",\\\"col-resize\\\",\\\"row-resize\\\"];var t,r;(r=t||(t={}))[r.String=0]=\\\"String\\\",r[r.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",r[r.U8Buffer=2]=\\\"U8Buffer\\\",r[r.F32Buffer=3]=\\\"F32Buffer\\\",r[r.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\",self;class s extends SharedArrayBuffer{constructor(e,t){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=t}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class t extends e{constructor(...t){const r=t[0];if(\\\"object\\\"==typeof r&&r instanceof s){if(t.length<2&&(t[1]=r.__zaplibBufferData.bufferPtr),t.length<3&&(t[2]=Math.floor((r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen-t[1])/e.BYTES_PER_ELEMENT)),t[1]<r.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${t[1]} is out of bounds`);if(t[1]+t[2]*e.BYTES_PER_ELEMENT>r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${t[1]} + length ${t[2]} is out of bounds`);t[0]=r.__zaplibWasmBuffer,super(...t),this.__zaplibBuffer=r}else super(...t)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,r=this.length){return e<0&&(e=this.length+e),r<0&&(r=this.length+r),r<e&&(r=e),new t(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,r-e)}}}const i={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,t]of Object.entries(i))e in self&&(self[t]=n(self[e]));new WeakMap;const a={};new FinalizationRegistry((({arcPtr:e,destructor:t})=>{delete a[e],t&&t(e)})),new FinalizationRegistry((({bufferData:e,destructor:t})=>{t(e)}));class o{constructor({buffer:e,byteOffset:t,slots:r,growCallback:s}){this._buffer=e,this._byteOffset=t,this._slots=r,this._growCallback=s,this._used=2,this._updateRefs()}_updateRefs(){this._f32=new Float32Array(this._buffer,this._byteOffset,this._slots),this._u32=new Uint32Array(this._buffer,this._byteOffset,this._slots),this._f64=new Float64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64=new BigUint64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64[0]=BigInt(this._slots)*BigInt(4)}_fit(e){if(this._used+e>this._slots){let t=Math.max(this._used+e,2*this._slots);1&t&&t++;const r=4*t,{buffer:s,byteOffset:n}=this._growCallback(this._buffer,this._byteOffset,r);this._buffer=s,this._byteOffset=n,this._slots=t,this._updateRefs()}const t=this._used;return this._used+=e,t}sendF32(e){const t=this._fit(1);this._f32[t]=e}sendU32(e){const t=this._fit(1);this._u32[t]=e}sendF64(e){if(1&this._used){const t=this._fit(3)+1;this._f64[t>>1]=e}else{const t=this._fit(2);this._f64[t>>1]=e}}sendU64(e){if(1&this._used){const t=this._fit(3)+1;this._u64[t>>1]=e}else{const t=this._fit(2);this._u64[t>>1]=e}}sendString(e){let t=this._fit(e.length+1);this._u32[t++]=e.length;for(let r=0;r<e.length;r++)this._u32[t++]=e.charCodeAt(r)}getData(){return{buffer:this._buffer,byteOffset:this._byteOffset}}}class d{constructor(e,t){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,t),this._u32=new Uint32Array(this._memory.buffer,t),this._f64=new Float64Array(this._memory.buffer,t),this._u64=new BigUint64Array(this._memory.buffer,t)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e=\\\"\\\";const t=this.parseU32();for(let r=0;r<t;r++){const t=this.parseU32();0!=t&&(e+=String.fromCharCode(t))}return e}parseU8Slice(){const e=this.parseU32(),t=e>>2,r=new Uint8Array(e),s=3&e;for(let e=0;e<t;e++){const t=e<<2,s=this.parseU32();r[t+0]=255&s,r[t+1]=s>>8&255,r[t+2]=s>>16&255,r[t+3]=s>>24&255}const n=t<<2;if(1==s){const e=this.parseU32();r[n+0]=255&e}else if(2==s){const e=this.parseU32();r[n+0]=255&e,r[n+1]=e>>8&255}else if(3==s){const e=this.parseU32();r[n+0]=255&e,r[n+1]=e>>8&255,r[n+2]=e>>16&255}return r}parseZapParams(){const e=this.parseU32(),r=[];for(let s=0;s<e;++s){const e=this.parseU32();if(e===t.String)r.push(this.parseString());else if(e===t.ReadOnlyU8Buffer||e===t.ReadOnlyF32Buffer){const t=this.parseU32(),s=this.parseU32(),n=this.parseU32();r.push({paramType:e,bufferPtr:t,bufferLen:s,arcPtr:n,readonly:!0})}else{if(e!==t.U8Buffer&&e!==t.F32Buffer)throw new Error(`Unknown ZapParam type: ${e}`);{const t=this.parseU32(),s=this.parseU32(),n=this.parseU32();r.push({paramType:e,bufferPtr:t,bufferLen:s,bufferCap:n,readonly:!1})}}}return r}}const l=\\\"$$RESPONSE\\\",h=\\\"$$ERROR\\\";class c{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:t,topic:r,data:s}=e.data;if(r===l)return this._pendingCallbacks[t](e.data),void delete this._pendingCallbacks[t];new Promise((e=>{const t=this._receivers.get(r);if(!t)throw new Error(`no receiver registered for ${r}`);e(t(s))})).then((e=>{if(!e)return void this.postMessage({topic:l,id:t},[]);const r=e[c.transferrables];delete e[c.transferrables];const s={topic:l,id:t,data:e};this.postMessage(s,r)})).catch((e=>{const r={topic:l,id:t,data:{[h]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(r,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,t,r){const s=this._messageId++,n={topic:e,id:s,data:t},i=new Promise(((e,t)=>{this._pendingCallbacks[s]=r=>{if(r.data&&r.data[h]){const e=new Error(r.data.message);e.name=r.data.name,e.stack=r.data.stack,t(e)}else e(r.data)}}));return this.postMessage(n,r),i}receive(e,t){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,t)}postMessage(e,t){try{this._channel.postMessage(e,t)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}c.transferrables=\\\"$$TRANSFERRABLES\\\";const u=e=>{const t=8*Math.ceil((e.__tls_size.value+2097152)/8);return{ptr:e.allocWasmMessage(BigInt(t)),size:t}},f=(e,t,r)=>{new e.constructor(t,r,e.length).set(e)},p=(e,r)=>{if(e instanceof Uint8Array)return r?t.ReadOnlyU8Buffer:t.U8Buffer;if(e instanceof Float32Array)return r?t.ReadOnlyF32Buffer:t.F32Buffer;throw new Error(\\\"Invalid array type\\\")},m=(e,t,r)=>{const s=Number(t.allocWasmVec(BigInt(r.byteLength)));return f(r,e.buffer,s),s};function g(e,t=\\\"Value\\\"){if(null==e)throw new Error(`Assertion failed: ${t} is null`);return e}class E extends Error{constructor(e){super(e),this.name=\\\"RustPanic\\\"}}function _(e){return(e.shiftKey?1:0)|(e.ctrlKey?2:0)|(e.altKey?4:0)|(e.metaKey?8:0)}const b={keyDown(e,t){e.sendU32(12),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(_(t.event)),e.sendF64(performance.now()/1e3)},keyUp(e,t){e.sendU32(13),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(_(t.event)),e.sendF64(performance.now()/1e3)},textInput(e,t){e.sendU32(14),e.sendU32(t.wasPaste?1:0),e.sendU32(t.replaceLast?1:0),e.sendString(t.input)},textCopy(e){e.sendU32(17)}};class v{constructor(e){this._wasmApp=e,this._zerdeBuilder=((e,t)=>{const r=Number(t.allocWasmMessage(BigInt(4096)));return new o({buffer:e.buffer,byteOffset:r,slots:1024,growCallback:(r,s,n)=>{const i=Number(t.reallocWasmMessage(BigInt(s),BigInt(n)));return{buffer:e.buffer,byteOffset:i}}})})(e.memory,e.exports),this._zerdeBuilder.sendF64(0)}getWasmApp(){return this._wasmApp}createWasmBuffer(e){return m(this._wasmApp.memory,this._wasmApp.exports,e)}createArcVec(e,t){return Number(this._wasmApp.exports.createArcVec(BigInt(e),BigInt(t.length),BigInt(p(t,!0))))}init(e){this._zerdeBuilder.sendU32(1),this._zerdeBuilder.sendF32(e.width),this._zerdeBuilder.sendF32(e.height),this._zerdeBuilder.sendF32(e.dpiFactor),this._zerdeBuilder.sendU32(e.xrCanPresent?1:0),this._zerdeBuilder.sendU32(e.canFullscreen?1:0),this._zerdeBuilder.sendString(\\\"4537990a86a4640f267b9a361cb0cb8f04a92564\\\")}resize(e){this._zerdeBuilder.sendU32(4),this._zerdeBuilder.sendF32(e.width),this._zerdeBuilder.sendF32(e.height),this._zerdeBuilder.sendF32(e.dpiFactor),this._zerdeBuilder.sendU32(e.xrIsPresenting?1:0),this._zerdeBuilder.sendU32(e.xrCanPresent?1:0),this._zerdeBuilder.sendU32(e.isFullscreen?1:0)}animationFrame(){this._zerdeBuilder.sendU32(5)}pointerDown(e){this._zerdeBuilder.sendU32(6),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.button),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerUp(e){this._zerdeBuilder.sendU32(7),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.button),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerMove(e){this._zerdeBuilder.sendU32(8),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerHover(e){this._zerdeBuilder.sendU32(9),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerScroll(e){this._zerdeBuilder.sendU32(10),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendF32(e.scrollX),this._zerdeBuilder.sendF32(e.scrollY),this._zerdeBuilder.sendU32(e.isWheel?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerOut(e){this._zerdeBuilder.sendU32(11),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}keyDown(e){b.keyDown(this._zerdeBuilder,e)}keyUp(e){b.keyUp(this._zerdeBuilder,e)}textInput(e){b.textInput(this._zerdeBuilder,e)}textCopy(){b.textCopy(this._zerdeBuilder)}timerFired(e){this._zerdeBuilder.sendU32(18),this._zerdeBuilder.sendF64(e)}windowFocus(e){this._zerdeBuilder.sendU32(19),this._zerdeBuilder.sendU32(e?1:0)}xrUpdateHead(e,t){}xrUpdateInputs(e,t,r,s,n){}paintDirty(e,t){this._zerdeBuilder.sendU32(21)}httpSendResponse(e,t){this._zerdeBuilder.sendU32(22),this._zerdeBuilder.sendU32(e),this._zerdeBuilder.sendU32(t)}sendEventFromAnyThread(e){this._zerdeBuilder.sendU32(26),this._zerdeBuilder.sendU64(e)}websocketMessage(e,t){const r=t.byteLength,s=this.createWasmBuffer(new Uint8Array(t));this._zerdeBuilder.sendU32(23),this._zerdeBuilder.sendU32(s),this._zerdeBuilder.sendU32(r),this._zerdeBuilder.sendString(e)}websocketError(e,t){this._zerdeBuilder.sendU32(24),this._zerdeBuilder.sendString(e),this._zerdeBuilder.sendString(t)}appOpenFiles(e){this._zerdeBuilder.sendU32(25),this._zerdeBuilder.sendU32(e.length);for(const t of e)this._zerdeBuilder.sendU32(t.id),this._zerdeBuilder.sendU64(BigInt(t.file.size)),this._zerdeBuilder.sendString(t.basename)}dragenter(){this._zerdeBuilder.sendU32(27)}dragleave(){this._zerdeBuilder.sendU32(28)}dragover(e,t){this._zerdeBuilder.sendU32(29),this._zerdeBuilder.sendU32(e),this._zerdeBuilder.sendU32(t)}callRust(e,r,s){this._zerdeBuilder.sendU32(30),this._zerdeBuilder.sendString(e),this._zerdeBuilder.sendU32(r.length);for(const e of r)if(\\\"string\\\"==typeof e)this._zerdeBuilder.sendU32(t.String),this._zerdeBuilder.sendString(e);else if(\\\"bufferData\\\"in e)this._zerdeBuilder.sendU32(e.bufferData.paramType),e.bufferData.readonly?this._zerdeBuilder.sendU32(e.bufferData.arcPtr):(this._zerdeBuilder.sendU32(e.bufferData.bufferPtr),this._zerdeBuilder.sendU32(e.bufferData.bufferLen),this._zerdeBuilder.sendU32(e.bufferData.bufferCap));else{const t=e.byteLength,r=this.createWasmBuffer(e);this._zerdeBuilder.sendU32(p(e,!1)),this._zerdeBuilder.sendU32(r),this._zerdeBuilder.sendU32(t),this._zerdeBuilder.sendU32(t)}this._zerdeBuilder.sendU32(s)}end(){this._zerdeBuilder.sendU32(0);const{buffer:e,byteOffset:t}=this._zerdeBuilder.getData();return new Float64Array(e,t,2)[1]=performance.now()/1e3,t}}class z{constructor(e,t,r,s){this.uniformFnTable={float:function(e,t,r){const s=r>>2;e.gl.uniform1f(t,e.basef32[s])},vec2:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform2f(t,n[s],n[s+1])},vec3:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform3f(t,n[s],n[s+1],n[s+2])},vec4:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform4f(t,n[s],n[s+1],n[s+2],n[s+3])},mat2:function(e,t,r){e.gl.uniformMatrix2fv(t,!1,new Float32Array(e.memory.buffer,r,4))},mat3:function(e,t,r){e.gl.uniformMatrix3fv(t,!1,new Float32Array(e.memory.buffer,r,9))},mat4:function(e,t,r){const s=new Float32Array(e.memory.buffer,r,16);e.gl.uniformMatrix4fv(t,!1,s)}},this.sendFnTable=[function(e){return!0},function(e){function t(){const t=e.zerdeParser.parseU32(),r=[];for(let s=0;s<t;s++)r.push({ty:e.zerdeParser.parseString(),name:e.zerdeParser.parseString()});return r}const r={shaderId:e.zerdeParser.parseU32(),fragment:e.zerdeParser.parseString(),vertex:e.zerdeParser.parseString(),geometrySlots:e.zerdeParser.parseU32(),instanceSlots:e.zerdeParser.parseU32(),passUniforms:t(),viewUniforms:t(),drawUniforms:t(),userUniforms:t(),textureSlots:t()};e.compileWebGLShader(r)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=new Float32Array(e.memory.buffer,s,r);e.allocArrayBuffer(t,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=new Uint32Array(e.memory.buffer,s,r);e.allocIndexBuffer(t,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),i=e.zerdeParser.parseU32();e.allocVao(t,r,s,n,i)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),i=e.zerdeParser.parseU32(),a=e.zerdeParser.parseU32(),o=e.zerdeParser.parseU32();e.drawCall(t,r,s,n,i,a,o)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32();e.allocTexture(t,r,s,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32();e.beginRenderTargets(t,r,s)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseF32(),n=e.zerdeParser.parseF32(),i=e.zerdeParser.parseF32(),a=e.zerdeParser.parseF32();e.addColorTarget(t,r,s,n,i,a)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseF32();e.setDepthTarget(t,r,s)},function(e){e.endRenderTargets()},function(e){e.setDefaultDepthAndBlendMode()},function(e){const t=e.zerdeParser.parseF32(),r=e.zerdeParser.parseF32(),s=e.zerdeParser.parseF32(),n=e.zerdeParser.parseF32(),i=e.zerdeParser.parseF32();e.beginMainCanvas(t,r,s,n,i)}],this.canvas=e,this.memory=t,this.sizingData=r,this.shaders=[],this.indexBuffers=[],this.arrayBuffers=[],this.vaos=[],this.textures=[],this.framebuffers=[],this.targetWidth=0,this.targetHeight=0,this.clearFlags=0,this.clearR=0,this.clearG=0,this.clearB=0,this.clearA=0,this.clearDepth=0;const n={preferLowPowerToHighPerformance:!0};this.gl=e.getContext(\\\"webgl\\\",n)||e.getContext(\\\"webgl-experimental\\\",n)||e.getContext(\\\"experimental-webgl\\\",n),this.gl?(this.OESVertexArrayObject=g(this.gl.getExtension(\\\"OES_vertex_array_object\\\")),this.ANGLEInstancedArrays=g(this.gl.getExtension(\\\"ANGLE_instanced_arrays\\\")),this.gl.getExtension(\\\"OES_standard_derivatives\\\"),this.gl.getExtension(\\\"OES_element_index_uint\\\"),this.resize(r)):s()}processMessages(e){for(this.zerdeParser=new d(this.memory,e),this.basef32=new Float32Array(this.memory.buffer),this.baseu32=new Uint32Array(this.memory.buffer);;){const e=this.zerdeParser.parseU32();if(this.sendFnTable[e](this))break}}resize(e){this.sizingData=e,this.canvas.width=e.width*e.dpiFactor,this.canvas.height=e.height*e.dpiFactor}getAttribLocations(e,t,r){const s=this.gl,n=[];let i=r>>2;0!=(3&r)&&i++;for(let a=0;a<i;a++){let i=r-4*a;i>4&&(i=4),n.push({loc:s.getAttribLocation(e,t+a),offset:16*a,size:i,stride:4*r})}return n}getUniformLocations(e,t){const r=this.gl,s=[];let n=0;for(let i=0;i<t.length;i++){const a=t[i],o=U[a.ty];0!=(3&n)&&(3&n)+o>4&&(n+=4-(3&n)),s.push({name:a.name,offset:n<<2,ty:a.ty,loc:r.getUniformLocation(e,a.name),fn:this.uniformFnTable[a.ty]}),n+=o}return s}compileWebGLShader(e){const t=this.gl,r=g(t.createShader(t.VERTEX_SHADER));t.shaderSource(r,e.vertex),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(r),B(e.vertex));const s=g(t.createShader(t.FRAGMENT_SHADER));t.shaderSource(s,e.fragment),t.compileShader(s),t.getShaderParameter(s,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(s),B(e.fragment));const n=g(t.createProgram());t.attachShader(n,r),t.attachShader(n,s),t.linkProgram(n),t.getProgramParameter(n,t.LINK_STATUS)||console.log(t.getProgramInfoLog(n),B(e.vertex),B(e.fragment)),this.shaders[e.shaderId]={geomAttribs:this.getAttribLocations(n,\\\"mpsc_packed_geometry_\\\",e.geometrySlots),instAttribs:this.getAttribLocations(n,\\\"mpsc_packed_instance_\\\",e.instanceSlots),passUniforms:this.getUniformLocations(n,e.passUniforms),viewUniforms:this.getUniformLocations(n,e.viewUniforms),drawUniforms:this.getUniformLocations(n,e.drawUniforms),userUniforms:this.getUniformLocations(n,e.userUniforms),textureSlots:this.getUniformLocations(n,e.textureSlots),instanceSlots:e.instanceSlots,program:n,ash:e}}allocArrayBuffer(e,t){const r=this.gl;let s=this.arrayBuffers[e];void 0===s?s=this.arrayBuffers[e]={glBuf:g(r.createBuffer()),length:t.length}:s.length=t.length,r.bindBuffer(r.ARRAY_BUFFER,s.glBuf),r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,null)}allocIndexBuffer(e,t){const r=this.gl;let s=this.indexBuffers[e];void 0===s?s=this.indexBuffers[e]={glBuf:g(r.createBuffer()),length:t.length}:s.length=t.length,r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,s.glBuf),r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null)}allocVao(e,t,r,s,n){const i=this.gl,a=this.vaos[e];a&&this.OESVertexArrayObject.deleteVertexArrayOES(a.glVao);const o=g(this.OESVertexArrayObject.createVertexArrayOES()),d=this.vaos[e]={glVao:o,geomIbId:r,geomVbId:s,instVbId:n};this.OESVertexArrayObject.bindVertexArrayOES(d.glVao),i.bindBuffer(i.ARRAY_BUFFER,this.arrayBuffers[s].glBuf);const l=this.shaders[t];for(let e=0;e<l.geomAttribs.length;e++){const t=l.geomAttribs[e];t.loc<0||(i.vertexAttribPointer(t.loc,t.size,i.FLOAT,!1,t.stride,t.offset),i.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,0))}i.bindBuffer(i.ARRAY_BUFFER,this.arrayBuffers[n].glBuf);for(let e=0;e<l.instAttribs.length;e++){const t=l.instAttribs[e];t.loc<0||(i.vertexAttribPointer(t.loc,t.size,i.FLOAT,!1,t.stride,t.offset),i.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,1))}i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,this.indexBuffers[r].glBuf),this.OESVertexArrayObject.bindVertexArrayOES(null)}drawCall(e,t,r,s,n,i,a){const o=this.gl,d=this.shaders[e];o.useProgram(d.program);const l=this.vaos[t];this.OESVertexArrayObject.bindVertexArrayOES(l.glVao);const h=this.indexBuffers[l.geomIbId],c=this.arrayBuffers[l.instVbId],u=d.passUniforms,f=d.viewUniforms;for(let e=0;e<f.length;e++){const t=f[e];t.fn(this,t.loc,t.offset+s)}const p=d.drawUniforms;for(let e=0;e<p.length;e++){const t=p[e];t.fn(this,t.loc,t.offset+n)}const m=d.userUniforms;for(let e=0;e<m.length;e++){const t=m[e];t.fn(this,t.loc,t.offset+i)}const g=d.textureSlots;for(let e=0;e<g.length;e++){const t=g[e],r=this.baseu32[(a>>2)+e],s=this.textures[r];o.activeTexture(o.TEXTURE0+e),o.bindTexture(o.TEXTURE_2D,s),o.uniform1i(t.loc,e)}const E=h.length,_=c.length/d.instanceSlots;for(let e=0;e<u.length;e++){const t=u[e];t.fn(this,t.loc,t.offset+r)}this.ANGLEInstancedArrays.drawElementsInstancedANGLE(o.TRIANGLES,E,o.UNSIGNED_INT,0,_),this.OESVertexArrayObject.bindVertexArrayOES(null)}allocTexture(e,t,r,s){const n=this.gl,i=this.textures[e]||n.createTexture();n.bindTexture(n.TEXTURE_2D,i),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);const a=new Uint8Array(this.memory.buffer,s,t*r*4);n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t,r,0,n.RGBA,n.UNSIGNED_BYTE,a),this.textures[e]=i}beginRenderTargets(e,t,r){const s=this.gl;this.targetWidth=t,this.targetHeight=r,this.clearFlags=0;const n=this.framebuffers[e]||(this.framebuffers[e]=g(s.createFramebuffer()));s.bindFramebuffer(s.FRAMEBUFFER,n)}addColorTarget(e,t,r,s,n,i){this.clearR=r,this.clearG=s,this.clearB=n,this.clearA=i;const a=this.gl,o=this.textures[e]||(this.textures[e]=a.createTexture());o.mpWidth!=this.targetWidth||o.mpHeight!=this.targetHeight?(a.bindTexture(a.TEXTURE_2D,o),this.clearFlags|=a.COLOR_BUFFER_BIT,o.mpWidth=this.targetWidth,o.mpHeight=this.targetHeight,a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,o.mpWidth,o.mpHeight,0,a.RGBA,a.UNSIGNED_BYTE,null)):t||(this.clearFlags|=a.COLOR_BUFFER_BIT),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,o,0)}setDepthTarget(e,t,r){const s=this.gl;this.clearDepth=r;const n=this.textures[e]||(this.textures[e]=s.createRenderbuffer());n.mpWidth!=this.targetWidth||n.mpHeight!=this.targetHeight?(s.bindRenderbuffer(s.RENDERBUFFER,n),this.clearFlags|=s.DEPTH_BUFFER_BIT,n.mpWidth=this.targetWidth,n.mpHeight=this.targetHeight,s.renderbufferStorage(s.RENDERBUFFER,s.DEPTH_COMPONENT16,this.targetWidth,this.targetHeight)):t||(this.clearFlags|=s.DEPTH_BUFFER_BIT),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.RENDERBUFFER,n)}endRenderTargets(){const e=this.gl;e.viewport(0,0,this.targetWidth,this.targetHeight),this.clearFlags&&(e.clearColor(this.clearR,this.clearG,this.clearB,this.clearA),e.clearDepth(this.clearDepth),e.clear(this.clearFlags))}setDefaultDepthAndBlendMode(){const e=this.gl;e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.blendEquationSeparate(e.FUNC_ADD,e.FUNC_ADD),e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA),e.enable(e.BLEND)}beginMainCanvas(e,t,r,s,n){const i=this.gl;i.bindFramebuffer(i.FRAMEBUFFER,null),i.viewport(0,0,this.sizingData.width*this.sizingData.dpiFactor,this.sizingData.height*this.sizingData.dpiFactor),i.clearColor(e,t,r,s),i.clearDepth(n),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT)}}const U={float:1,vec2:2,vec3:3,vec4:4,mat2:4,mat3:9,mat4:16};function B(e){const t=e.split(\\\"\\\\n\\\");let r=\\\"\\\";for(let e=0;e<t.length;e++)r+=e+1+\\\": \\\"+t[e]+\\\"\\\\n\\\";return r}var y,w,A,F;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\",e.Panic=\\\"WorkerEvent.Panic\\\"}(y||(y={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(w||(w={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(A||(A={})),function(e){e.Init=\\\"MainWorkerChannelEvent.Init\\\",e.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",e.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",e.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\"}(F||(F={}));var R,T=function(e,t,r,s){return new(r||(r=Promise))((function(n,i){function a(e){try{d(s.next(e))}catch(e){i(e)}}function o(e){try{d(s.throw(e))}catch(e){i(e)}}function d(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,o)}d((s=s.apply(e,t||[])).next())}))};const P=new c(self),S=(null===(R=self.navigator)||void 0===R?void 0:R.userAgent.toLowerCase().indexOf(\\\"firefox\\\"))>-1;let W;const{wrapWasmExports:x}=(e=>{const t=()=>{if(1!==Atomics.load(W,0))throw new Error(\\\"Zaplib WebAssembly instance crashed\\\")};return{checkWasm:t,wrapWasmExports:e=>new Proxy(e,{get:function(e,r){return t(),e[r]}})}})();class I{constructor({offscreenCanvas:e,wasmModule:t,wasmExports:r,memory:s,sizingData:n,baseUri:i,fileHandles:a,taskWorkerSab:o}){this.xrCanPresent=!1,this.xrIsPresenting=!1,this.sendFnTable=[function(e){return!0},function(e){const t=e.zerdeParser.parseU64();e.webglRenderer?(e.webglRenderer.processMessages(Number(t)),e.exports.deallocWasmMessage(t)):e.runWebGLPromise=P.send(y.RunWebGL,Number(t)).then((()=>{e.exports.deallocWasmMessage(t),e.runWebGLPromise=void 0}))},function(e){console.log(e.zerdeParser.parseString())},function(e){e.requestAnimationFrame()},function(e){e.setDocumentTitle(e.zerdeParser.parseString())},function(e){e.setMouseCursor(e.zerdeParser.parseU32())},function(e){const t=e.zerdeParser.parseF32(),r=e.zerdeParser.parseF32();P.send(y.ShowTextIME,{x:t,y:r})},function(e){},function(e){const t=e.zerdeParser.parseString();P.send(y.TextCopyResponse,t)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseF64(),s=e.zerdeParser.parseF64();e.startTimer(r,s,t)},function(e){const t=e.zerdeParser.parseF64();e.stopTimer(t)},function(e){e.xrStartPresenting()},function(e){e.xrStopPresenting()},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseString(),n=e.zerdeParser.parseString(),i=e.zerdeParser.parseString(),a=e.zerdeParser.parseString(),o=e.zerdeParser.parseString(),d=e.zerdeParser.parseU8Slice();e.httpSend(s,n,i,a,t,o,d,r)},function(e){P.send(y.Fullscreen)},function(e){P.send(y.Normalscreen)},function(e){const t=e.zerdeParser.parseString(),r=e.zerdeParser.parseU8Slice();e.websocketSend(t,r)},function(e){e.enableGlobalFileDropTarget()},function(e){const t=e.zerdeParser.parseString(),r=e.zerdeParser.parseZapParams();if(\\\"_zaplibReturnParams\\\"===t){const t=JSON.parse(r[0]);e.callRustPendingCallbacks[t](r.slice(1)),delete e.callRustPendingCallbacks[t]}else P.send(y.CallJs,{fnName:t,params:r})}],this.module=t,this.exports=r,this.memory=s,this.baseUri=i,this.sizingData=n,this.timers=[],this.hasRequestedAnimationFrame=!1,this.websockets={},this.fileHandles=a,this.callRustNewCallbackId=0,this.callRustPendingCallbacks={},e&&(this.webglRenderer=new z(e,this.memory,this.sizingData,(()=>{P.send(y.ShowIncompatibleBrowserNotification)}))),P.receive(y.ScreenResize,(e=>{this.sizingData=e,this.webglRenderer&&this.webglRenderer.resize(this.sizingData),this.zerdeEventloopEvents.resize({width:this.sizingData.width,height:this.sizingData.height,dpiFactor:this.sizingData.dpiFactor,xrIsPresenting:this.xrIsPresenting,xrCanPresent:this.xrCanPresent,isFullscreen:this.sizingData.isFullscreen}),this.requestAnimationFrame()})),this.bindMouseAndTouch(),this.bindKeyboard(),this.appPtr=this.exports.createWasmApp(),P.receive(y.WindowFocus,(()=>{this.zerdeEventloopEvents.windowFocus(!0),this.doWasmIo()})),P.receive(y.WindowBlur,(()=>{this.zerdeEventloopEvents.windowFocus(!1),this.doWasmIo()}));const d=({name:e,params:t})=>{const r=this.callRustNewCallbackId++,s=new Promise(((e,t)=>{this.callRustPendingCallbacks[r]=t=>{e(t)}}));return this.zerdeEventloopEvents.callRust(e,t,r),this.doWasmIo(),s};P.receive(y.CallRust,d),P.receive(y.CreateBuffer,(e=>this.zerdeEventloopEvents.createWasmBuffer(e))),P.receive(y.CreateReadOnlyBuffer,(e=>{const t=this.zerdeEventloopEvents.createWasmBuffer(e);return{bufferPtr:t,arcPtr:this.zerdeEventloopEvents.createArcVec(t,e)}})),P.receive(y.IncrementArc,(e=>{this.exports.incrementArc(BigInt(e))})),P.receive(y.DecrementArc,(e=>{this.exports.decrementArc(BigInt(e))})),P.receive(y.DeallocVec,(({bufferPtr:e,bufferLen:t,bufferCap:r})=>{this.exports.deallocVec(BigInt(e),BigInt(t),BigInt(r))}));const l=e=>{const t=new c(e);t.receive(F.Init,(()=>({wasmModule:this.module,memory:this.memory,taskWorkerSab:o,appPtr:this.appPtr,baseUri:i,tlsAndStackData:u(this.exports),wasmOnline:W}))),t.receive(F.BindMainWorkerPort,(e=>{l(e)})),t.receive(F.CallRust,d),t.receive(F.SendEventFromAnyThread,(e=>{this.sendEventFromAnyThread(e)}))};P.receive(y.BindMainWorkerPort,(e=>{l(e)})),this.zerdeEventloopEvents=new v(this)}init(){Atomics.store(W,0,1),this.exports=x(this.exports),P.send(y.RemoveLoadingIndicators),this.zerdeEventloopEvents.init({width:this.sizingData.width,height:this.sizingData.height,dpiFactor:this.sizingData.dpiFactor,xrCanPresent:this.xrCanPresent,canFullscreen:this.sizingData.canFullscreen,xrIsPresenting:!1}),this.doWasmIo()}doWasmIo(){if(this.doWasmBlock)return;const e=this.zerdeEventloopEvents.end(),t=Number(this.exports.processWasmEvents(this.appPtr,BigInt(e)));for(this.zerdeEventloopEvents=new v(this),this.zerdeParser=new d(this.memory,t);;){const e=this.zerdeParser.parseU32();if(this.sendFnTable[e](this))break}this.exports.deallocWasmMessage(BigInt(t))}setDocumentTitle(e){P.send(y.SetDocumentTitle,e)}bindMouseAndTouch(){let e;const t=[];function r(e){const r=t[e.button]||(t[e.button]={});return r.x=e.pageX,r.y=e.pageY,r.button=e.button,r.digit=e.button,r.time=performance.now()/1e3,r.modifiers=_(e),r.touch=!1,r}const s=[];P.receive(y.CanvasMouseDown,(e=>{s[e.button]=!0,this.zerdeEventloopEvents.pointerDown(r(e)),this.doWasmIo()})),P.receive(y.WindowMouseUp,(e=>{s[e.button]=!1,this.zerdeEventloopEvents.pointerUp(r(e)),this.doWasmIo()})),P.receive(y.WindowMouseMove,(t=>{for(let e=0;e<s.length;e++)if(s[e]){const s=r(t);s.digit=e,this.zerdeEventloopEvents.pointerMove(s)}e=r(t),this.zerdeEventloopEvents.pointerHover(e),this.doWasmIo()})),P.receive(y.WindowMouseOut,(e=>{this.zerdeEventloopEvents.pointerOut(r(e)),this.doWasmIo()}));const n=[];let i,a;P.receive(y.WindowTouchStart,(e=>{for(const t of e.changedTouches){let r=n.indexOf(void 0);-1===r&&(r=n.length),n[r]=t.identifier,this.zerdeEventloopEvents.pointerDown({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0})}this.doWasmIo()})),P.receive(y.WindowTouchMove,(e=>{for(const t of e.changedTouches){const r=n.indexOf(t.identifier);-1!=r?this.zerdeEventloopEvents.pointerMove({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0}):console.error(\\\"Unrecognized digit in WorkerEvent.WindowTouchMove\\\")}this.doWasmIo()})),P.receive(y.WindowTouchEndCancelLeave,(e=>{for(const t of e.changedTouches){const r=n.indexOf(t.identifier);-1!=r?(n[r]=void 0,this.zerdeEventloopEvents.pointerUp({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0})):console.error(\\\"Unrecognized digit in WorkerEvent.WindowTouchMove\\\")}this.doWasmIo()})),P.receive(y.CanvasWheel,(e=>{const t=r(e),s=e.timeStamp-i;i=e.timeStamp,a=S?1==e.deltaMode:!(Math.abs(Math.abs(e.deltaY/e.wheelDeltaY)-1/3)<1e-5||!a&&s<250);let n=1;1===e.deltaMode?n=40:2===e.deltaMode&&(n=800);const o=Object.assign(Object.assign({},t),{scrollX:e.deltaX*n,scrollY:e.deltaY*n,isWheel:a});this.zerdeEventloopEvents.pointerScroll(o),this.doWasmIo()}))}bindKeyboard(){P.receive(y.TextInput,(e=>{this.zerdeEventloopEvents.textInput(e),this.doWasmIo()})),P.receive(y.TextCopy,(()=>{this.zerdeEventloopEvents.textCopy(),this.doWasmIo()})),P.receive(y.KeyDown,(e=>{this.zerdeEventloopEvents.keyDown(e),this.doWasmIo()})),P.receive(y.KeyUp,(e=>{this.zerdeEventloopEvents.keyUp(e),this.doWasmIo()}))}setMouseCursor(t){P.send(y.SetMouseCursor,e[t]||\\\"default\\\")}startTimer(e,t,r){for(let t=0;t<this.timers.length;t++)if(this.timers[t].id==e)return void console.log(\\\"Timer ID collision!\\\");const s=0!==r?self.setInterval((()=>{this.zerdeEventloopEvents.timerFired(e),this.doWasmIo()}),1e3*t):self.setTimeout((()=>{for(let t=0;t<this.timers.length;t++)if(this.timers[t].id==e){this.timers.splice(t,1);break}this.zerdeEventloopEvents.timerFired(e),this.doWasmIo()}),1e3*t);this.timers.push({id:e,repeats:r,sysId:s})}stopTimer(e){for(let t=0;t<this.timers.length;t++){const r=this.timers[t];if(r.id==e)return r.repeats?self.clearInterval(r.sysId):self.clearTimeout(r.sysId),void this.timers.splice(t,1)}}httpSend(e,t,r,s,n,i,a,o){const d=new XMLHttpRequest;d.addEventListener(\\\"error\\\",(e=>{this.zerdeEventloopEvents.httpSendResponse(o,2),this.doWasmIo()})),d.addEventListener(\\\"load\\\",(e=>{200!==d.status?this.zerdeEventloopEvents.httpSendResponse(o,2):this.zerdeEventloopEvents.httpSendResponse(o,1),this.doWasmIo()})),d.open(e,r+\\\"://\\\"+s+\\\":\\\"+n+t,!0),console.log(e,r+\\\"://\\\"+s+\\\":\\\"+n+t,a),d.send(a.buffer)}websocketSend(e,t){const r=this.websockets[e];if(r)r.sendStack?r.sendStack.push(t):r.send(t);else{const r=new WebSocket(e);this.websockets[e]=r,r.sendStack=[t],r.addEventListener(\\\"close\\\",(()=>{this.websockets[e]=null})),r.addEventListener(\\\"error\\\",(t=>{this.websockets[e]=null,this.zerdeEventloopEvents.websocketError(e,\\\"\\\"+t),this.doWasmIo()})),r.addEventListener(\\\"message\\\",(t=>{t.data.arrayBuffer().then((t=>{this.zerdeEventloopEvents.websocketMessage(e,t),this.doWasmIo()}))})),r.addEventListener(\\\"open\\\",(()=>{const e=r.sendStack;for(t of(r.sendStack=null,e))r.send(t)}))}}enableGlobalFileDropTarget(){P.send(y.EnableGlobalFileDropTarget),P.receive(y.DragEnter,(()=>{this.zerdeEventloopEvents.dragenter(),this.doWasmIo()})),P.receive(y.DragOver,(({x:e,y:t})=>{this.zerdeEventloopEvents.dragover(e,t),this.doWasmIo()})),P.receive(y.DragLeave,(()=>{this.zerdeEventloopEvents.dragleave(),this.doWasmIo()})),P.receive(y.Drop,(({fileHandles:e,fileHandlesToSend:t})=>{this.fileHandles.splice(0,this.fileHandles.length),this.fileHandles.push(...e),this.zerdeEventloopEvents.appOpenFiles(t),this.doWasmIo()}))}requestAnimationFrame(){return T(this,void 0,void 0,(function*(){this.xrIsPresenting||this.hasRequestedAnimationFrame||(this.hasRequestedAnimationFrame=!0,this.runWebGLPromise&&(yield this.runWebGLPromise),(self.requestAnimationFrame||self.setTimeout)((()=>T(this,void 0,void 0,(function*(){if(this.runWebGLPromise&&(yield this.runWebGLPromise),this.hasRequestedAnimationFrame=!1,!this.xrIsPresenting){this.zerdeEventloopEvents.animationFrame();try{this.doWasmIo()}catch(e){if(!(e instanceof Error&&\\\"RustPanic\\\"===e.name))throw e;Atomics.store(W,0,0),P.send(y.Panic,e)}}})))))}))}xrStartPresenting(){}xrStopPresenting(){}sendEventFromAnyThread(e){setTimeout((()=>{try{this.zerdeEventloopEvents.sendEventFromAnyThread(e),this.doWasmIo()}catch(e){if(!(e instanceof Error&&\\\"RustPanic\\\"===e.name))throw e;Atomics.store(W,0,0),P.send(y.Panic,e)}}))}}P.receive(y.Init,(({wasmModule:e,offscreenCanvas:t,sizingData:r,baseUri:s,memory:n,taskWorkerSab:i,wasmOnline:a})=>{let o;return W=a,new Promise(((a,d)=>{const l=[],h=(({getExports:e,memory:t,taskWorkerSab:r,fileHandles:s,sendEventFromAnyThread:n,threadSpawn:i,baseUri:a})=>{const o=(e,r)=>{let s=\\\"\\\";const n=new Uint32Array(t.buffer,e,r);for(let e=0;e<r;e++)s+=String.fromCharCode(n[e]);return s};return{memory:t,_consoleLog:(e,t)=>{const r=o(parseInt(e),parseInt(t));console.log(r)},_throwError:(e,t)=>{throw new E(o(parseInt(e),parseInt(t)))},readUserFileRange:(e,r,n,i)=>{const a=s[e],o=Number(i),d=o+Number(n);a.lastReadStart<=o&&o<a.lastReadEnd&&console.warn(`Read start (${o}) fell in the range of the last read (${a.lastReadStart}-${a.lastReadEnd}); this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.`),a.lastReadStart=o,a.lastReadEnd=d;const l=(new FileReaderSync).readAsArrayBuffer(a.file.slice(o,d));return f(new Uint8Array(l),t.buffer,Number(r)),BigInt(l.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{i(e)},_sendEventFromAnyThread:e=>{n(e)},readUrlSync:(r,s,n,i)=>{const d=o(r,s),l=new XMLHttpRequest;if(l.responseType=\\\"arraybuffer\\\",l.open(\\\"GET\\\",new URL(d,a).href,!1),l.send(null),200===l.status){const r=e(),s=m(t,r,new Uint8Array(l.response));return new Uint32Array(t.buffer,n,1)[0]=s,new Uint32Array(t.buffer,i,1)[0]=l.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,t)=>{const r=new Int32Array(e);((e,t)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(r);const s=r[1];new Uint32Array(e)[s+2]=t,r[1]=s+1,((e,t)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,0,1)})(r),Atomics.notify(r,1)})(r,parseInt(e))}}})({getExports:()=>o.exports,memory:n,taskWorkerSab:i,fileHandles:l,sendEventFromAnyThread:e=>{o.sendEventFromAnyThread(e)},threadSpawn:e=>{P.send(y.ThreadSpawn,{ctxPtr:e,tlsAndStackData:u(o.exports)})},baseUri:s});WebAssembly.instantiate(e,{env:h}).then((d=>{const h=d.exports;(e=>{const t=e.allocWasmMessage(BigInt(e.__tls_size.value));e.__wasm_init_tls(Number(t))})(h),o=new I({offscreenCanvas:t,wasmModule:e,wasmExports:h,memory:n,sizingData:r,baseUri:s,fileHandles:l,taskWorkerSab:i}),o.init(),a()}),d)}))}))})();\\n\", \"Worker\", undefined, undefined);\n}\n","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";var e,r;(r=e||(e={}))[r.String=0]=\\\"String\\\",r[r.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",r[r.U8Buffer=2]=\\\"U8Buffer\\\",r[r.F32Buffer=3]=\\\"F32Buffer\\\",r[r.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\",self;class t extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class r extends e{constructor(...r){const n=r[0];if(\\\"object\\\"==typeof n&&n instanceof t){if(r.length<2&&(r[1]=n.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<n.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=n.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=n}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const a={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,r]of Object.entries(a))e in self&&(self[r]=n(self[e]));new WeakMap;const o={};new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete o[e],r&&r(e)})),new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)}));const s=\\\"$$RESPONSE\\\",i=\\\"$$ERROR\\\";class l{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===s)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:s,id:r},[]);const t=e[l.transferrables];delete e[l.transferrables];const n={topic:s,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:s,id:r,data:{[i]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,a={topic:e,id:n,data:r},o=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[i]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(a,t),o}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}l.transferrables=\\\"$$TRANSFERRABLES\\\";const c=e=>{const r=8*Math.ceil((e.__tls_size.value+2097152)/8);return{ptr:e.allocWasmMessage(BigInt(r)),size:r}},u=(e,r,t)=>{new e.constructor(r,t,e.length).set(e)},f=({getExports:e,memory:r,taskWorkerSab:t,fileHandles:n,sendEventFromAnyThread:a,threadSpawn:o,baseUri:s})=>{const i=(e,t)=>{let n=\\\"\\\";const a=new Uint32Array(r.buffer,e,t);for(let e=0;e<t;e++)n+=String.fromCharCode(a[e]);return n};return{memory:r,_consoleLog:(e,r)=>{const t=i(parseInt(e),parseInt(r));console.log(t)},_throwError:(e,r)=>{throw new d(i(parseInt(e),parseInt(r)))},readUserFileRange:(e,t,a,o)=>{const s=n[e],i=Number(o),l=i+Number(a);s.lastReadStart<=i&&i<s.lastReadEnd&&console.warn(`Read start (${i}) fell in the range of the last read (${s.lastReadStart}-${s.lastReadEnd}); this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.`),s.lastReadStart=i,s.lastReadEnd=l;const c=(new FileReaderSync).readAsArrayBuffer(s.file.slice(i,l));return u(new Uint8Array(c),r.buffer,Number(t)),BigInt(c.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{o(e)},_sendEventFromAnyThread:e=>{a(e)},readUrlSync:(t,n,a,o)=>{const l=i(t,n),c=new XMLHttpRequest;if(c.responseType=\\\"arraybuffer\\\",c.open(\\\"GET\\\",new URL(l,s).href,!1),c.send(null),200===c.status){const t=e(),n=((e,r,t)=>{const n=Number(r.allocWasmVec(BigInt(t.byteLength)));return u(t,e.buffer,n),n})(r,t,new Uint8Array(c.response));return new Uint32Array(r.buffer,a,1)[0]=n,new Uint32Array(r.buffer,o,1)[0]=c.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,r)=>{const t=new Int32Array(e);((e,r)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(t);const n=t[1];new Uint32Array(e)[n+2]=r,t[1]=n+1,((e,r)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,0,1)})(t),Atomics.notify(t,1)})(t,parseInt(e))}}};class d extends Error{constructor(e){super(e),this.name=\\\"RustPanic\\\"}}var p,h,E,y;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\",e.Panic=\\\"WorkerEvent.Panic\\\"}(p||(p={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(h||(h={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(E||(E={})),function(e){e.Init=\\\"MainWorkerChannelEvent.Init\\\",e.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",e.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",e.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\"}(y||(y={}));const v=new l(self);v.receive(E.Run,(({wasmModule:e,memory:r,taskWorkerSab:t,ctxPtr:n,fileHandles:a,baseUri:o,tlsAndStackData:s,mainWorkerPort:i})=>{let u;const d=new l(i),p=f({getExports:()=>u,memory:r,taskWorkerSab:t,fileHandles:a,sendEventFromAnyThread:e=>{d.send(y.SendEventFromAnyThread,e)},threadSpawn:e=>{v.send(E.ThreadSpawn,{ctxPtr:e,tlsAndStackData:c(u)})},baseUri:o});return new Promise(((r,t)=>{WebAssembly.instantiate(e,{env:p}).then((e=>{u=e.exports,((e,r)=>{e.__stack_pointer.value=Number(r.ptr)+r.size-8,e.__wasm_init_tls(Number(r.ptr))})(u,s),u.runFunctionPointer(n),r()}),t)}))}))})();\\n\", \"Worker\", undefined, undefined);\n}\n","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";var e,r;(r=e||(e={}))[r.String=0]=\\\"String\\\",r[r.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",r[r.U8Buffer=2]=\\\"U8Buffer\\\",r[r.F32Buffer=3]=\\\"F32Buffer\\\",r[r.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\",self;class t extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class r extends e{constructor(...r){const n=r[0];if(\\\"object\\\"==typeof n&&n instanceof t){if(r.length<2&&(r[1]=n.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<n.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=n.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=n}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const s={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,r]of Object.entries(s))e in self&&(self[r]=n(self[e]));new WeakMap;const a={};new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete a[e],r&&r(e)})),new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)}));class o{constructor(e,r){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,r),this._u32=new Uint32Array(this._memory.buffer,r),this._f64=new Float64Array(this._memory.buffer,r),this._u64=new BigUint64Array(this._memory.buffer,r)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e=\\\"\\\";const r=this.parseU32();for(let t=0;t<r;t++){const r=this.parseU32();0!=r&&(e+=String.fromCharCode(r))}return e}parseU8Slice(){const e=this.parseU32(),r=e>>2,t=new Uint8Array(e),n=3&e;for(let e=0;e<r;e++){const r=e<<2,n=this.parseU32();t[r+0]=255&n,t[r+1]=n>>8&255,t[r+2]=n>>16&255,t[r+3]=n>>24&255}const s=r<<2;if(1==n){const e=this.parseU32();t[s+0]=255&e}else if(2==n){const e=this.parseU32();t[s+0]=255&e,t[s+1]=e>>8&255}else if(3==n){const e=this.parseU32();t[s+0]=255&e,t[s+1]=e>>8&255,t[s+2]=e>>16&255}return t}parseZapParams(){const r=this.parseU32(),t=[];for(let n=0;n<r;++n){const r=this.parseU32();if(r===e.String)t.push(this.parseString());else if(r===e.ReadOnlyU8Buffer||r===e.ReadOnlyF32Buffer){const e=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,arcPtr:s,readonly:!0})}else{if(r!==e.U8Buffer&&r!==e.F32Buffer)throw new Error(`Unknown ZapParam type: ${r}`);{const e=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,bufferCap:s,readonly:!1})}}}return t}}const i=\\\"$$RESPONSE\\\",f=\\\"$$ERROR\\\";class u{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===i)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:i,id:r},[]);const t=e[u.transferrables];delete e[u.transferrables];const n={topic:i,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:i,id:r,data:{[f]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,s={topic:e,id:n,data:r},a=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[f]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(s,t),a}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}u.transferrables=\\\"$$TRANSFERRABLES\\\";const l=(e,r)=>{for(;;){if(0==Atomics.compareExchange(e,r,0,1))return;Atomics.wait(e,r,1)}},c=(e,r)=>{if(1!=Atomics.compareExchange(e,r,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,r,1)};function h(e,r=\\\"Value\\\"){if(null==e)throw new Error(`Assertion failed: ${r} is null`);return e}var d,p,y,v;Error,function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\",e.Panic=\\\"WorkerEvent.Panic\\\"}(d||(d={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(p||(p={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(y||(y={})),function(e){e.Init=\\\"MainWorkerChannelEvent.Init\\\",e.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",e.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",e.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\"}(v||(v={})),new u(self).receive(p.Init,(({taskWorkerSab:e,wasmMemory:r})=>{const t=new Int32Array(e);let n=0,s=1;const a={};function i(e,t){const n=new Int32Array(r.buffer,e,1);if(n[0]===t)throw new Error(\\\"Have to set the return value to something different than the initial value, otherwise Atomics.notify won't do anything\\\");n[0]=t,Atomics.notify(n,0)}function f(e){const r=a[e];n++,r.reader.read().then((t=>{n--,t.done?r.done=!0:(r.values.push(t.value),f(e)),u(e)})).catch((t=>{n--,console.error(\\\"fetch read error\\\",t),r.error=!0,u(e)}))}function u(e){const t=a[e];if(!t.currentTwMessage)return;if(t.error)return i(t.currentTwMessage.bytesReadReturnValPtr,-2),void(t.currentTwMessage=void 0);if(0===t.values.length)return void(t.done&&(i(t.currentTwMessage.bytesReadReturnValPtr,0),t.currentTwMessage=void 0));let n=0;for(;t.values.length>0&&n<t.currentTwMessage.bufLen;){const e=t.values[0],s=t.currentTwMessage.bufLen-n,a=Math.min(e.byteLength,s),o=new Uint8Array(e.buffer,e.byteOffset,a);new Uint8Array(r.buffer,t.currentTwMessage.bufPtr+n,a).set(o),a<e.byteLength?t.values[0]=new Uint8Array(e.buffer,e.byteOffset+a,e.byteLength-a):t.values.shift(),n+=a}i(t.currentTwMessage.bytesReadReturnValPtr,n),t.currentTwMessage=void 0}function d(e){const r=e.parseU32();if(1==r){const r=e.parseU32(),t=e.parseString(),o=e.parseString(),u=e.parseU8Slice(),l=e.parseU32(),c={};for(let r=0;r<l;r++)c[e.parseString()]=e.parseString();n++,fetch(t,{method:o,body:u,headers:c}).then((e=>{if(n--,e.ok){const t=s++;a[t]={reader:h(e.body).getReader(),values:[],done:!1,error:!1,currentTwMessage:void 0},f(t),i(r,t)}else i(r,-2)})).catch((e=>{n--,console.error(\\\"fetch create error\\\",e),i(r,-2)}))}else if(2==r){const r={bytesReadReturnValPtr:e.parseU32(),streamId:e.parseU32(),bufPtr:e.parseU32(),bufLen:e.parseU32()};if(a[r.streamId].currentTwMessage)return console.error(\\\"Got multiple http_stream_read messages in a row\\\"),void i(r.bytesReadReturnValPtr,-2);a[r.streamId].currentTwMessage=r,u(r.streamId)}}setTimeout((function s(){for(;;){if(Atomics.load(t,1)>0){l(t,0);const n=t[1];for(let t=0;t<n;t++){const n=new Uint32Array(e)[t+2];d(new o(r,n))}t[1]=0,c(t,0)}if(n>0){setTimeout(s,1);break}Atomics.wait(t,1,0)}}),0)}))})();\\n\", \"Worker\", undefined, undefined);\n}\n","export const makeRpcMouseEvent = (event) => {\n    return {\n        pageX: event.pageX,\n        pageY: event.pageY,\n        button: event.button,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\nexport const makeRpcTouchEvent = (event) => {\n    return {\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n        changedTouches: Array.from(event.changedTouches).map((touch) => ({\n            pageX: touch.pageX,\n            pageY: touch.pageY,\n            identifier: touch.identifier,\n        })),\n    };\n};\nexport const makeRpcWheelEvent = (event) => {\n    return {\n        pageX: event.pageX,\n        pageY: event.pageY,\n        button: event.button,\n        timeStamp: event.timeStamp,\n        deltaMode: event.deltaMode,\n        deltaX: event.deltaX,\n        deltaY: event.deltaY,\n        // @ts-ignore - the wheelDeltaY API is non-standard\n        wheelDeltaY: event.wheelDeltaY,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\nexport const makeRpcKeyboardEvent = (event) => {\n    return {\n        keyCode: event.keyCode,\n        repeat: event.repeat,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\n","export var WorkerEvent;\n(function (WorkerEvent) {\n    WorkerEvent[\"CallRust\"] = \"WorkerEvent.CallRust\";\n    WorkerEvent[\"CreateBuffer\"] = \"WorkerEvent.CreateBuffer\";\n    WorkerEvent[\"CreateReadOnlyBuffer\"] = \"WorkerEvent.CreateReadOnlyBuffer\";\n    WorkerEvent[\"BindMainWorkerPort\"] = \"WorkerEvent.BindMainWorkerPort\";\n    WorkerEvent[\"DecrementArc\"] = \"WorkerEvent.DecrementArc\";\n    WorkerEvent[\"DeallocVec\"] = \"WorkerEvent.DeallocVec\";\n    WorkerEvent[\"IncrementArc\"] = \"WorkerEvent.IncrementArc\";\n    WorkerEvent[\"DragEnter\"] = \"WorkerEvent.DragEnter\";\n    WorkerEvent[\"DragOver\"] = \"WorkerEvent.DragOver\";\n    WorkerEvent[\"DragLeave\"] = \"WorkerEvent.DragLeave\";\n    WorkerEvent[\"Drop\"] = \"WorkerEvent.Drop\";\n    WorkerEvent[\"WindowMouseUp\"] = \"WorkerEvent.WindowMouseUp\";\n    WorkerEvent[\"CanvasMouseDown\"] = \"WorkerEvent.CanvasMouseDown\";\n    WorkerEvent[\"WindowMouseMove\"] = \"WorkerEvent.WindowMouseMove\";\n    WorkerEvent[\"WindowMouseOut\"] = \"WorkerEvent.WindowMouseOut\";\n    WorkerEvent[\"WindowFocus\"] = \"WorkerEvent.WindowFocus\";\n    WorkerEvent[\"WindowBlur\"] = \"WorkerEvent.WindowBlur\";\n    WorkerEvent[\"ScreenResize\"] = \"WorkerEvent.ScreenResize\";\n    WorkerEvent[\"CanvasWheel\"] = \"WorkerEvent.CanvasWheel\";\n    WorkerEvent[\"ShowIncompatibleBrowserNotification\"] = \"WorkerEvent.ShowIncompatibleBrowserNotification\";\n    WorkerEvent[\"RemoveLoadingIndicators\"] = \"WorkerEvent.RemoveLoadingIndicators\";\n    WorkerEvent[\"SetDocumentTitle\"] = \"WorkerEvent.SetDocumentTitle\";\n    WorkerEvent[\"SetMouseCursor\"] = \"WorkerEvent.SetMouseCursor\";\n    WorkerEvent[\"Fullscreen\"] = \"WorkerEvent.Fullscreen\";\n    WorkerEvent[\"Normalscreen\"] = \"WorkerEvent.Normalscreen\";\n    WorkerEvent[\"TextCopyResponse\"] = \"WorkerEvent.TextCopyResponse\";\n    WorkerEvent[\"EnableGlobalFileDropTarget\"] = \"WorkerEvent.EnableGlobalFileDropTarget\";\n    WorkerEvent[\"CallJs\"] = \"WorkerEvent.CallJs\";\n    WorkerEvent[\"ShowTextIME\"] = \"WorkerEvent.ShowTextIME\";\n    WorkerEvent[\"TextInput\"] = \"WorkerEvent.TextInput\";\n    WorkerEvent[\"TextCopy\"] = \"WorkerEvent.TextCopy\";\n    WorkerEvent[\"KeyDown\"] = \"WorkerEvent.KeyDown\";\n    WorkerEvent[\"KeyUp\"] = \"WorkerEvent.KeyUp\";\n    WorkerEvent[\"Init\"] = \"WorkerEvent.Init\";\n    WorkerEvent[\"RunWebGL\"] = \"WorkerEvent.RunWebGL\";\n    WorkerEvent[\"ThreadSpawn\"] = \"WorkerEvent.ThreadSpawn\";\n    WorkerEvent[\"WindowTouchStart\"] = \"WorkerEvent.WindowTouchStart\";\n    WorkerEvent[\"WindowTouchMove\"] = \"WorkerEvent.WindowTouchMove\";\n    WorkerEvent[\"WindowTouchEndCancelLeave\"] = \"WorkerEvent.WindowTouchEndCancelLeave\";\n    WorkerEvent[\"Panic\"] = \"WorkerEvent.Panic\";\n})(WorkerEvent || (WorkerEvent = {}));\nexport var TaskWorkerEvent;\n(function (TaskWorkerEvent) {\n    TaskWorkerEvent[\"Init\"] = \"TaskWorkerEvent.Init\";\n})(TaskWorkerEvent || (TaskWorkerEvent = {}));\nexport var AsyncWorkerEvent;\n(function (AsyncWorkerEvent) {\n    AsyncWorkerEvent[\"Run\"] = \"AsyncWorkerEvent.Run\";\n    AsyncWorkerEvent[\"ThreadSpawn\"] = \"AsyncWorkerEvent.ThreadSpawn\";\n})(AsyncWorkerEvent || (AsyncWorkerEvent = {}));\nexport var MainWorkerChannelEvent;\n(function (MainWorkerChannelEvent) {\n    MainWorkerChannelEvent[\"Init\"] = \"MainWorkerChannelEvent.Init\";\n    MainWorkerChannelEvent[\"BindMainWorkerPort\"] = \"MainWorkerChannelEvent.BindMainWorkerPort\";\n    MainWorkerChannelEvent[\"CallRust\"] = \"MainWorkerChannelEvent.CallRust\";\n    MainWorkerChannelEvent[\"SendEventFromAnyThread\"] = \"MainWorkerChannelEvent.SendEventFromAnyThread\";\n})(MainWorkerChannelEvent || (MainWorkerChannelEvent = {}));\n","import { makeRpcKeyboardEvent } from \"make_rpc_event\";\nimport { WorkerEvent } from \"rpc_types\";\n// Create a hidden textarea which is purely used for text input into Rust.\nexport function makeTextarea(callback) {\n    let ta;\n    // NOTE(JP): This looks a bit convoluted, but it's the most reliable method I could find to return the focus to the textarea!\n    function fixFocus() {\n        setTimeout(() => {\n            var _a;\n            if (ta &&\n                document.activeElement !== ta &&\n                !((_a = document\n                    .getElementById(\"zaplib_js_root\")) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement))) {\n                ta.focus();\n            }\n        });\n    }\n    document.addEventListener(\"mousedown\", fixFocus, true);\n    document.addEventListener(\"mouseup\", fixFocus, true);\n    document.addEventListener(\"focus\", fixFocus, true);\n    document.addEventListener(\"blur\", fixFocus, true);\n    let textAreaPos;\n    const updateTextAreaPos = () => {\n        if (!textAreaPos) {\n            ta.style.left = -100 + \"px\";\n            ta.style.top = -100 + \"px\";\n        }\n        else {\n            ta.style.left = Math.round(textAreaPos.x) - 4 + \"px\";\n            ta.style.top = Math.round(textAreaPos.y) + \"px\";\n        }\n    };\n    function showTextIME({ x, y }) {\n        textAreaPos = { x, y };\n        updateTextAreaPos();\n    }\n    let wasPaste = false;\n    let lastLen = 0;\n    let uglyIMEHack = false;\n    const recreateTextarea = function () {\n        if (ta)\n            document.body.removeChild(ta);\n        ta = document.createElement(\"textarea\");\n        ta.className = \"zaplib_textarea\";\n        ta.setAttribute(\"autocomplete\", \"off\");\n        ta.setAttribute(\"autocorrect\", \"off\");\n        ta.setAttribute(\"autocapitalize\", \"off\");\n        ta.setAttribute(\"spellcheck\", \"false\");\n        ta.style.left = -100 + \"px\";\n        ta.style.top = -100 + \"px\";\n        ta.style.height = 1 + \"px\";\n        ta.style.width = 1 + \"px\";\n        ta.addEventListener(\"contextmenu\", (event) => {\n            event.preventDefault();\n            return false;\n        });\n        document.body.appendChild(ta);\n        ta.focus();\n        updateTextAreaPos();\n        ta.addEventListener(\"cut\", () => {\n            setTimeout(() => {\n                ta.value = \"\";\n                lastLen = 0;\n            });\n        });\n        ta.addEventListener(\"copy\", () => {\n            setTimeout(() => {\n                ta.value = \"\";\n                lastLen = 0;\n            });\n        });\n        ta.addEventListener(\"paste\", () => {\n            wasPaste = true;\n        });\n        ta.addEventListener(\"input\", () => {\n            if (ta.value.length > 0) {\n                if (wasPaste) {\n                    wasPaste = false;\n                    const input = ta.value.substring(lastLen);\n                    ta.value = \"\";\n                    callback({\n                        type: WorkerEvent.TextInput,\n                        wasPaste: true,\n                        input,\n                        replaceLast: false,\n                    });\n                }\n                else {\n                    let replaceLast = false;\n                    let textValue = ta.value;\n                    if (ta.value.length >= 2) {\n                        // we want the second char\n                        textValue = ta.value.substring(1, 2);\n                        ta.value = textValue;\n                    }\n                    else if (ta.value.length == 1 && lastLen == ta.value.length) {\n                        // its an IME replace\n                        replaceLast = true;\n                    }\n                    // we should send a replace last\n                    if (replaceLast || textValue != \"\\n\") {\n                        callback({\n                            type: WorkerEvent.TextInput,\n                            wasPaste: false,\n                            input: textValue,\n                            replaceLast: replaceLast,\n                        });\n                    }\n                }\n            }\n            lastLen = ta.value.length;\n        });\n        ta.addEventListener(\"keydown\", (event) => {\n            const code = event.keyCode;\n            if (code == 18 || code == 17 || code == 16)\n                event.preventDefault(); // alt\n            if (code === 8 || code === 9)\n                event.preventDefault(); // backspace/tab\n            if (code === 89 && (event.metaKey || event.ctrlKey))\n                event.preventDefault(); // all (select all)\n            if (code === 83 && (event.metaKey || event.ctrlKey))\n                event.preventDefault(); // ctrl s\n            if (code >= 33 && code <= 40) {\n                // if we are using arrow keys, home or end\n                ta.value = \"\";\n                lastLen = ta.value.length;\n            }\n            if ((code === 88 || code == 67) && (event.metaKey || event.ctrlKey)) {\n                // copy or cut\n                // we need to request the clipboard\n                callback({ type: WorkerEvent.TextCopy });\n                event.preventDefault();\n            }\n            if (code === 90 && (event.metaKey || event.ctrlKey)) {\n                // ctrl/cmd + z\n                updateTextAreaPos();\n                ta.value = \"\";\n                uglyIMEHack = true;\n                ta.readOnly = true;\n                event.preventDefault();\n            }\n            callback({\n                type: WorkerEvent.KeyDown,\n                event: makeRpcKeyboardEvent(event),\n            });\n        });\n        ta.addEventListener(\"keyup\", (event) => {\n            const code = event.keyCode;\n            if (code == 18 || code == 17 || code == 16)\n                event.preventDefault(); // alt\n            if (code == 91)\n                event.preventDefault(); // left window key\n            if (uglyIMEHack) {\n                uglyIMEHack = false;\n                recreateTextarea();\n            }\n            callback({\n                type: WorkerEvent.KeyUp,\n                event: makeRpcKeyboardEvent(event),\n            });\n        });\n    };\n    recreateTextarea();\n    function textareaHasFocus() {\n        return document.activeElement == ta;\n    }\n    return { showTextIME, textareaHasFocus };\n}\n","import { assertNotNull } from \"common\";\nimport { ZerdeParser } from \"zerde\";\nexport class WebGLRenderer {\n    constructor(canvas, memory, sizingData, incompatibleBrowserCallback) {\n        this.uniformFnTable = {\n            float: function setFloat(self, loc, off) {\n                const slot = off >> 2;\n                self.gl.uniform1f(loc, self.basef32[slot]);\n            },\n            vec2: function setVec2(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform2f(loc, basef32[slot], basef32[slot + 1]);\n            },\n            vec3: function setVec3(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform3f(loc, basef32[slot], basef32[slot + 1], basef32[slot + 2]);\n            },\n            vec4: function setVec4(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform4f(loc, basef32[slot], basef32[slot + 1], basef32[slot + 2], basef32[slot + 3]);\n            },\n            mat2: function setMat2(self, loc, off) {\n                self.gl.uniformMatrix2fv(loc, false, new Float32Array(self.memory.buffer, off, 4));\n            },\n            mat3: function setMat3(self, loc, off) {\n                self.gl.uniformMatrix3fv(loc, false, new Float32Array(self.memory.buffer, off, 9));\n            },\n            mat4: function setMat4(self, loc, off) {\n                const mat4 = new Float32Array(self.memory.buffer, off, 16);\n                self.gl.uniformMatrix4fv(loc, false, mat4);\n            },\n        };\n        // Array of function id's wasm can call on us; `self` is pointer to WebGLRenderer.\n        // Function names are suffixed with the index in the array, and annotated with\n        // their name in cx_webgl.rs, for easier matching.\n        this.sendFnTable = [\n            // end\n            function end0(_self) {\n                return true;\n            },\n            // compile_webgl_shader\n            function compileWebGLShader1(self) {\n                function parseShvarvec() {\n                    const len = self.zerdeParser.parseU32();\n                    const vars = [];\n                    for (let i = 0; i < len; i++) {\n                        vars.push({\n                            ty: self.zerdeParser.parseString(),\n                            name: self.zerdeParser.parseString(),\n                        });\n                    }\n                    return vars;\n                }\n                const ash = {\n                    shaderId: self.zerdeParser.parseU32(),\n                    fragment: self.zerdeParser.parseString(),\n                    vertex: self.zerdeParser.parseString(),\n                    geometrySlots: self.zerdeParser.parseU32(),\n                    instanceSlots: self.zerdeParser.parseU32(),\n                    passUniforms: parseShvarvec(),\n                    viewUniforms: parseShvarvec(),\n                    drawUniforms: parseShvarvec(),\n                    userUniforms: parseShvarvec(),\n                    textureSlots: parseShvarvec(),\n                };\n                self.compileWebGLShader(ash);\n            },\n            // alloc_array_buffer\n            function allocArrayBuffer2(self) {\n                const arrayBufferId = self.zerdeParser.parseU32();\n                const len = self.zerdeParser.parseU32();\n                const pointer = self.zerdeParser.parseU32();\n                const array = new Float32Array(self.memory.buffer, pointer, len);\n                self.allocArrayBuffer(arrayBufferId, array);\n            },\n            // alloc_index_buffer\n            function allocIndexBuffer3(self) {\n                const indexBufferId = self.zerdeParser.parseU32();\n                const len = self.zerdeParser.parseU32();\n                const pointer = self.zerdeParser.parseU32();\n                const array = new Uint32Array(self.memory.buffer, pointer, len);\n                self.allocIndexBuffer(indexBufferId, array);\n            },\n            // alloc_vao\n            function allocVao4(self) {\n                const vaoId = self.zerdeParser.parseU32();\n                const shaderId = self.zerdeParser.parseU32();\n                const geomIbId = self.zerdeParser.parseU32();\n                const geomVbId = self.zerdeParser.parseU32();\n                const instVbId = self.zerdeParser.parseU32();\n                self.allocVao(vaoId, shaderId, geomIbId, geomVbId, instVbId);\n            },\n            // draw_call\n            function drawCall5(self) {\n                const shaderId = self.zerdeParser.parseU32();\n                const vaoId = self.zerdeParser.parseU32();\n                const uniformsPassPtr = self.zerdeParser.parseU32();\n                const uniformsViewPtr = self.zerdeParser.parseU32();\n                const uniformsDrawPtr = self.zerdeParser.parseU32();\n                const uniformsUserPtr = self.zerdeParser.parseU32();\n                const textures = self.zerdeParser.parseU32();\n                self.drawCall(shaderId, vaoId, uniformsPassPtr, uniformsViewPtr, uniformsDrawPtr, uniformsUserPtr, textures);\n            },\n            // update_texture_image2d\n            function allocTexture6(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const width = self.zerdeParser.parseU32();\n                const height = self.zerdeParser.parseU32();\n                const dataPtr = self.zerdeParser.parseU32();\n                self.allocTexture(textureId, width, height, dataPtr);\n            },\n            // begin_render_targets\n            function beginRenderTargets7(self) {\n                const passId = self.zerdeParser.parseU32();\n                const width = self.zerdeParser.parseU32();\n                const height = self.zerdeParser.parseU32();\n                self.beginRenderTargets(passId, width, height);\n            },\n            // add_color_target\n            function addColorTarget8(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const initOnly = self.zerdeParser.parseU32();\n                const r = self.zerdeParser.parseF32();\n                const g = self.zerdeParser.parseF32();\n                const b = self.zerdeParser.parseF32();\n                const a = self.zerdeParser.parseF32();\n                self.addColorTarget(textureId, initOnly, r, g, b, a);\n            },\n            // set_depth_target\n            function setDepthTarget9(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const initOnly = self.zerdeParser.parseU32();\n                const depth = self.zerdeParser.parseF32();\n                self.setDepthTarget(textureId, initOnly, depth);\n            },\n            // end_render_targets\n            function endRenderTargets10(self) {\n                self.endRenderTargets();\n            },\n            // set_default_depth_and_blend_mode\n            function setDefaultDepthAndBlendMode11(self) {\n                self.setDefaultDepthAndBlendMode();\n            },\n            // begin_main_canvas\n            function beginMainCanvas12(self) {\n                const r = self.zerdeParser.parseF32();\n                const g = self.zerdeParser.parseF32();\n                const b = self.zerdeParser.parseF32();\n                const a = self.zerdeParser.parseF32();\n                const depth = self.zerdeParser.parseF32();\n                self.beginMainCanvas(r, g, b, a, depth);\n            },\n        ];\n        this.canvas = canvas;\n        this.memory = memory;\n        this.sizingData = sizingData;\n        this.shaders = [];\n        this.indexBuffers = [];\n        this.arrayBuffers = [];\n        this.vaos = [];\n        this.textures = [];\n        this.framebuffers = [];\n        this.targetWidth = 0;\n        this.targetHeight = 0;\n        this.clearFlags = 0;\n        this.clearR = 0;\n        this.clearG = 0;\n        this.clearB = 0;\n        this.clearA = 0;\n        this.clearDepth = 0;\n        // this.isMainCanvas = false;\n        const options = {\n            preferLowPowerToHighPerformance: true,\n            // xrCompatible: true // TODO(JP): Bring back some day?\n        };\n        // @ts-ignore - TODO(Paras): Get proper support for OffscreenCanvas\n        this.gl =\n            // @ts-ignore\n            canvas.getContext(\"webgl\", options) ||\n                // @ts-ignore\n                canvas.getContext(\"webgl-experimental\", options) ||\n                // @ts-ignore\n                canvas.getContext(\"experimental-webgl\", options);\n        if (!this.gl) {\n            incompatibleBrowserCallback();\n            return;\n        }\n        this.OESVertexArrayObject = assertNotNull(this.gl.getExtension(\"OES_vertex_array_object\"));\n        this.ANGLEInstancedArrays = assertNotNull(this.gl.getExtension(\"ANGLE_instanced_arrays\"));\n        this.gl.getExtension(\"OES_standard_derivatives\");\n        this.gl.getExtension(\"OES_element_index_uint\");\n        this.resize(sizingData);\n    }\n    processMessages(zerdeParserPtr) {\n        this.zerdeParser = new ZerdeParser(this.memory, zerdeParserPtr);\n        this.basef32 = new Float32Array(this.memory.buffer);\n        this.baseu32 = new Uint32Array(this.memory.buffer);\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const msgType = this.zerdeParser.parseU32();\n            if (this.sendFnTable[msgType](this)) {\n                break;\n            }\n        }\n    }\n    resize(sizingData) {\n        this.sizingData = sizingData;\n        this.canvas.width = sizingData.width * sizingData.dpiFactor;\n        this.canvas.height = sizingData.height * sizingData.dpiFactor;\n    }\n    getAttribLocations(program, base, slots) {\n        const gl = this.gl;\n        const attribLocs = [];\n        let attribs = slots >> 2;\n        if ((slots & 3) != 0)\n            attribs++;\n        for (let i = 0; i < attribs; i++) {\n            let size = slots - i * 4;\n            if (size > 4)\n                size = 4;\n            attribLocs.push({\n                loc: gl.getAttribLocation(program, base + i),\n                offset: i * 16,\n                size: size,\n                stride: slots * 4,\n            });\n        }\n        return attribLocs;\n    }\n    getUniformLocations(program, uniforms) {\n        const gl = this.gl;\n        const uniformLocs = [];\n        let offset = 0;\n        for (let i = 0; i < uniforms.length; i++) {\n            const uniform = uniforms[i];\n            // lets align the uniform\n            const slots = uniformSizeTable[uniform.ty];\n            if ((offset & 3) != 0 && (offset & 3) + slots > 4) {\n                // goes over the boundary\n                offset += 4 - (offset & 3); // make jump to new slot\n            }\n            uniformLocs.push({\n                name: uniform.name,\n                offset: offset << 2,\n                ty: uniform.ty,\n                loc: gl.getUniformLocation(program, uniform.name),\n                fn: this.uniformFnTable[uniform.ty],\n            });\n            offset += slots;\n        }\n        return uniformLocs;\n    }\n    compileWebGLShader(ash) {\n        const gl = this.gl;\n        const vsh = assertNotNull(gl.createShader(gl.VERTEX_SHADER));\n        gl.shaderSource(vsh, ash.vertex);\n        gl.compileShader(vsh);\n        if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {\n            console.log(gl.getShaderInfoLog(vsh), addLineNumbersToString(ash.vertex));\n        }\n        // compile pixelshader\n        const fsh = assertNotNull(gl.createShader(gl.FRAGMENT_SHADER));\n        gl.shaderSource(fsh, ash.fragment);\n        gl.compileShader(fsh);\n        if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {\n            console.log(gl.getShaderInfoLog(fsh), addLineNumbersToString(ash.fragment));\n        }\n        const program = assertNotNull(gl.createProgram());\n        gl.attachShader(program, vsh);\n        gl.attachShader(program, fsh);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            console.log(gl.getProgramInfoLog(program), addLineNumbersToString(ash.vertex), addLineNumbersToString(ash.fragment));\n        }\n        // fetch all attribs and uniforms\n        this.shaders[ash.shaderId] = {\n            geomAttribs: this.getAttribLocations(program, \"mpsc_packed_geometry_\", ash.geometrySlots),\n            instAttribs: this.getAttribLocations(program, \"mpsc_packed_instance_\", ash.instanceSlots),\n            passUniforms: this.getUniformLocations(program, ash.passUniforms),\n            viewUniforms: this.getUniformLocations(program, ash.viewUniforms),\n            drawUniforms: this.getUniformLocations(program, ash.drawUniforms),\n            userUniforms: this.getUniformLocations(program, ash.userUniforms),\n            textureSlots: this.getUniformLocations(program, ash.textureSlots),\n            instanceSlots: ash.instanceSlots,\n            program: program,\n            ash: ash,\n        };\n    }\n    allocArrayBuffer(arrayBufferId, array) {\n        const gl = this.gl;\n        let buf = this.arrayBuffers[arrayBufferId];\n        if (buf === undefined) {\n            buf = this.arrayBuffers[arrayBufferId] = {\n                glBuf: assertNotNull(gl.createBuffer()),\n                length: array.length,\n            };\n        }\n        else {\n            buf.length = array.length;\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, buf.glBuf);\n        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n    allocIndexBuffer(indexBufferId, array) {\n        const gl = this.gl;\n        let buf = this.indexBuffers[indexBufferId];\n        if (buf === undefined) {\n            buf = this.indexBuffers[indexBufferId] = {\n                glBuf: assertNotNull(gl.createBuffer()),\n                length: array.length,\n            };\n        }\n        else {\n            buf.length = array.length;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.glBuf);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    allocVao(vaoId, shaderId, geomIbId, geomVbId, instVbId) {\n        const gl = this.gl;\n        const oldVao = this.vaos[vaoId];\n        if (oldVao) {\n            this.OESVertexArrayObject.deleteVertexArrayOES(oldVao.glVao);\n        }\n        const glVao = assertNotNull(this.OESVertexArrayObject.createVertexArrayOES());\n        const vao = (this.vaos[vaoId] = { glVao, geomIbId, geomVbId, instVbId });\n        this.OESVertexArrayObject.bindVertexArrayOES(vao.glVao);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffers[geomVbId].glBuf);\n        const shader = this.shaders[shaderId];\n        for (let i = 0; i < shader.geomAttribs.length; i++) {\n            const attr = shader.geomAttribs[i];\n            if (attr.loc < 0) {\n                continue;\n            }\n            gl.vertexAttribPointer(attr.loc, attr.size, gl.FLOAT, false, attr.stride, attr.offset);\n            gl.enableVertexAttribArray(attr.loc);\n            this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(attr.loc, 0);\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffers[instVbId].glBuf);\n        for (let i = 0; i < shader.instAttribs.length; i++) {\n            const attr = shader.instAttribs[i];\n            if (attr.loc < 0) {\n                continue;\n            }\n            gl.vertexAttribPointer(attr.loc, attr.size, gl.FLOAT, false, attr.stride, attr.offset);\n            gl.enableVertexAttribArray(attr.loc);\n            this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(attr.loc, 1);\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffers[geomIbId].glBuf);\n        this.OESVertexArrayObject.bindVertexArrayOES(null);\n    }\n    drawCall(shaderId, vaoId, passUniformsPtr, viewUniformsPtr, drawUniformsPtr, userUniformsPtr, texturesPtr) {\n        const gl = this.gl;\n        const shader = this.shaders[shaderId];\n        gl.useProgram(shader.program);\n        const vao = this.vaos[vaoId];\n        this.OESVertexArrayObject.bindVertexArrayOES(vao.glVao);\n        const indexBuffer = this.indexBuffers[vao.geomIbId];\n        const instanceBuffer = this.arrayBuffers[vao.instVbId];\n        // set up uniforms TODO do this a bit more incremental based on uniform layer\n        // also possibly use webGL2 uniform buffers. For now this will suffice for webGL 1 compat\n        const passUniforms = shader.passUniforms;\n        // if vr_presenting\n        const viewUniforms = shader.viewUniforms;\n        for (let i = 0; i < viewUniforms.length; i++) {\n            const uni = viewUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + viewUniformsPtr);\n        }\n        const drawUniforms = shader.drawUniforms;\n        for (let i = 0; i < drawUniforms.length; i++) {\n            const uni = drawUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + drawUniformsPtr);\n        }\n        const userUniforms = shader.userUniforms;\n        for (let i = 0; i < userUniforms.length; i++) {\n            const uni = userUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + userUniformsPtr);\n        }\n        const textureSlots = shader.textureSlots;\n        for (let i = 0; i < textureSlots.length; i++) {\n            const texSlot = textureSlots[i];\n            const texId = this.baseu32[(texturesPtr >> 2) + i];\n            const texObj = this.textures[texId];\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, texObj);\n            gl.uniform1i(texSlot.loc, i);\n        }\n        const indices = indexBuffer.length;\n        const instances = instanceBuffer.length / shader.instanceSlots;\n        // if (this.isMainCanvas && xrIsPresenting) {\n        // for (let i = 3; i < pass_uniforms.length; i ++) {\n        //     let uni = pass_uniforms[i];\n        //     uni.fn(this, uni.loc, uni.offset + pass_uniforms_ptr);\n        // }\n        // // the first 2 matrices are project and view\n        // let left_viewport = this.xr_left_viewport;\n        // gl.viewport(left_viewport.x, left_viewport.y, left_viewport.width, left_viewport.height);\n        // gl.uniformMatrix4fv(pass_uniforms[0].loc, false, this.xr_left_projection_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[1].loc, false, this.xr_left_transform_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[2].loc, false, this.xr_left_invtransform_matrix);\n        // this.ANGLE_instanced_arrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // let right_viewport = this.xr_right_viewport;\n        // gl.viewport(right_viewport.x, right_viewport.y, right_viewport.width, right_viewport.height);\n        // gl.uniformMatrix4fv(pass_uniforms[0].loc, false, this.xr_right_projection_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[1].loc, false, this.xr_right_transform_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[2].loc, false, this.xr_right_invtransform_matrix);\n        // this.ANGLE_instanced_arrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // } else {\n        for (let i = 0; i < passUniforms.length; i++) {\n            const uni = passUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + passUniformsPtr);\n        }\n        this.ANGLEInstancedArrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // }\n        this.OESVertexArrayObject.bindVertexArrayOES(null);\n    }\n    allocTexture(textureId, width, height, dataPtr) {\n        const gl = this.gl;\n        const glTex = this.textures[textureId] || gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, glTex);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        const data = new Uint8Array(this.memory.buffer, dataPtr, width * height * 4);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        this.textures[textureId] = glTex;\n    }\n    beginRenderTargets(passId, width, height) {\n        const gl = this.gl;\n        this.targetWidth = width;\n        this.targetHeight = height;\n        this.clearFlags = 0;\n        // this.isMainCanvas = false;\n        const glFramebuffer = this.framebuffers[passId] ||\n            (this.framebuffers[passId] = assertNotNull(gl.createFramebuffer()));\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glFramebuffer);\n    }\n    addColorTarget(textureId, initOnly, r, g, b, a) {\n        // if use_default\n        this.clearR = r;\n        this.clearG = g;\n        this.clearB = b;\n        this.clearA = a;\n        const gl = this.gl;\n        const glTex = this.textures[textureId] ||\n            (this.textures[textureId] = gl.createTexture());\n        // resize or create texture\n        if (glTex.mpWidth != this.targetWidth ||\n            glTex.mpHeight != this.targetHeight) {\n            gl.bindTexture(gl.TEXTURE_2D, glTex);\n            this.clearFlags |= gl.COLOR_BUFFER_BIT;\n            glTex.mpWidth = this.targetWidth;\n            glTex.mpHeight = this.targetHeight;\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, glTex.mpWidth, glTex.mpHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n        else if (!initOnly) {\n            this.clearFlags |= gl.COLOR_BUFFER_BIT;\n        }\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTex, 0);\n    }\n    setDepthTarget(textureId, initOnly, depth) {\n        const gl = this.gl;\n        this.clearDepth = depth;\n        const glRenderBuffer = this.textures[textureId] ||\n            (this.textures[textureId] = gl.createRenderbuffer());\n        if (glRenderBuffer.mpWidth != this.targetWidth ||\n            glRenderBuffer.mpHeight != this.targetHeight) {\n            // Borrowed concept from https://webglfundamentals.org/webgl/lessons/webgl-render-to-texture.html\n            gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderBuffer);\n            this.clearFlags |= gl.DEPTH_BUFFER_BIT;\n            glRenderBuffer.mpWidth = this.targetWidth;\n            glRenderBuffer.mpHeight = this.targetHeight;\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.targetWidth, this.targetHeight);\n        }\n        else if (!initOnly) {\n            this.clearFlags |= gl.DEPTH_BUFFER_BIT;\n        }\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, glRenderBuffer);\n    }\n    endRenderTargets() {\n        const gl = this.gl;\n        // process the actual 'clear'\n        gl.viewport(0, 0, this.targetWidth, this.targetHeight);\n        // check if we need to clear color, and depth\n        // clear it\n        if (this.clearFlags) {\n            gl.clearColor(this.clearR, this.clearG, this.clearB, this.clearA);\n            gl.clearDepth(this.clearDepth);\n            gl.clear(this.clearFlags);\n        }\n    }\n    setDefaultDepthAndBlendMode() {\n        const gl = this.gl;\n        gl.enable(gl.DEPTH_TEST);\n        gl.depthFunc(gl.LEQUAL);\n        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n    }\n    beginMainCanvas(r, g, b, a, depth) {\n        const gl = this.gl;\n        // this.isMainCanvas = true;\n        // if (this.xrIsPresenting) {\n        // let xr_webgllayer = this.xr_session.renderState.baseLayer;\n        // this.gl.bindFramebuffer(gl.FRAMEBUFFER, xr_webgllayer.framebuffer);\n        // gl.viewport(0, 0, xr_webgllayer.framebufferWidth, xr_webgllayer.framebufferHeight);\n        // // quest 1 is 3648\n        // // quest 2 is 4096\n        // let left_view = this.xr_pose.views[0];\n        // let right_view = this.xr_pose.views[1];\n        // this.xr_left_viewport = xr_webgllayer.getViewport(left_view);\n        // this.xr_right_viewport = xr_webgllayer.getViewport(right_view);\n        // this.xr_left_projection_matrix = left_view.projectionMatrix;\n        // this.xr_left_transform_matrix = left_view.transform.inverse.matrix;\n        // this.xr_left_invtransform_matrix = left_view.transform.matrix;\n        // this.xr_right_projection_matrix = right_view.projectionMatrix;\n        // this.xr_right_transform_matrix = right_view.transform.inverse.matrix;\n        // this.xr_right_camera_pos = right_view.transform.inverse.position;\n        // this.xr_right_invtransform_matrix = right_view.transform.matrix;\n        // } else {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, this.sizingData.width * this.sizingData.dpiFactor, this.sizingData.height * this.sizingData.dpiFactor);\n        // }\n        gl.clearColor(r, g, b, a);\n        gl.clearDepth(depth);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    }\n}\nconst uniformSizeTable = {\n    float: 1,\n    vec2: 2,\n    vec3: 3,\n    vec4: 4,\n    mat2: 4,\n    mat3: 9,\n    mat4: 16,\n};\nfunction addLineNumbersToString(code) {\n    const lines = code.split(\"\\n\");\n    let out = \"\";\n    for (let i = 0; i < lines.length; i++) {\n        out += i + 1 + \": \" + lines[i] + \"\\n\";\n    }\n    return out;\n}\n","export function addDefaultStyles() {\n    const style = document.createElement(\"style\");\n    style.innerHTML = `\n  * {\n    user-select: none;\n  }\n  html, body {\n    overflow: hidden;\n    background-color: #333;\n  }\n  body {\n    margin: 0;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n  }\n\n  #zaplib_js_root {\n    position: absolute; /* For z-index */\n    z-index: 0; /* New stacking context */\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    pointer-events: none;\n  }`;\n    document.body.appendChild(style);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// Import workers inline, so you can just include a single file \"wasm_runtime.js\"\n// without having to worry about having to serve multiple chunks.\n// @ts-ignore\nimport MainWorker from \"worker-loader?inline=no-fallback!main_worker\";\n// @ts-ignore\nimport AsyncWorker from \"worker-loader?inline=no-fallback!async_worker\";\n// @ts-ignore\nimport TaskWorker from \"worker-loader?inline=no-fallback!task_worker\";\nimport { getZapBufferWasm, isZapBuffer, overwriteTypedArraysWithZapArrays, unregisterMutableBuffer, checkValidZapArray, } from \"zap_buffer\";\nimport { createErrorCheckers, getZapParamType, initTaskWorkerSab, Rpc, transformParamsFromRustImpl, } from \"common\";\nimport { makeTextarea } from \"make_textarea\";\nimport { WebGLRenderer } from \"webgl_renderer\";\nimport { makeRpcMouseEvent, makeRpcTouchEvent, makeRpcWheelEvent, } from \"make_rpc_event\";\nimport { WorkerEvent, TaskWorkerEvent, AsyncWorkerEvent, } from \"rpc_types\";\nimport { addLoadingIndicator, removeLoadingIndicator } from \"loading_indicator\";\nimport { addDefaultStyles } from \"default_styles\";\nimport { inWorker } from \"type_of_runtime\";\nconst jsFunctions = {};\n/// Users must call this function to register functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const registerCallJsCallbacks = (fns) => {\n    // Check that all new functions are unique\n    for (const key of Object.keys(fns)) {\n        if (key in jsFunctions) {\n            throw new Error(`Error: overwriting existing function \"${key}\" in window.jsFunctions`);\n        }\n    }\n    Object.assign(jsFunctions, fns);\n};\n/// Users must call this function to unregister functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const unregisterCallJsCallbacks = (fnNames) => {\n    for (const name of fnNames) {\n        // Check that functions are registered\n        if (!(name in jsFunctions)) {\n            throw new Error(`Error: unregistering non-existent function \"${name}\".`);\n        }\n        delete jsFunctions[name];\n    }\n};\nconst wasmOnline = new Uint8Array(new SharedArrayBuffer(1));\nAtomics.store(wasmOnline, 0, 0);\nconst wasmInitialized = () => Atomics.load(wasmOnline, 0) === 1;\nconst { checkWasm } = createErrorCheckers(wasmInitialized);\n// Wrap RPC so we can globally catch Rust panics\nlet _rpc;\nconst rpc = {\n    send: (...args) => __awaiter(void 0, void 0, void 0, function* () {\n        try {\n            return yield _rpc.send(...args);\n        }\n        catch (ev) {\n            if (ev instanceof Error && ev.name === \"RustPanic\") {\n                Atomics.store(wasmOnline, 0, 0);\n            }\n            throw ev;\n        }\n    }),\n    receive: (...args) => _rpc.receive(...args),\n};\nexport const newWorkerPort = () => {\n    const channel = new MessageChannel();\n    rpc.send(WorkerEvent.BindMainWorkerPort, channel.port1, [channel.port1]);\n    return channel.port2;\n};\nlet wasmMemory;\nconst destructor = (arcPtr) => {\n    rpc.send(WorkerEvent.DecrementArc, arcPtr);\n};\nconst mutableDestructor = (bufferData) => {\n    rpc.send(WorkerEvent.DeallocVec, bufferData);\n};\nconst transformParamsFromRust = (params) => transformParamsFromRustImpl(wasmMemory, destructor, mutableDestructor, params);\n// TODO(JP): Somewhat duplicated with the other implementation.\nconst temporarilyHeldBuffersForPostMessage = new Set();\nexport const serializeZapArrayForPostMessage = (zapArray) => {\n    if (!(typeof zapArray === \"object\" && isZapBuffer(zapArray.buffer))) {\n        throw new Error(\"Only pass Zap arrays to serializeZapArrayForPostMessage\");\n    }\n    const zapBuffer = zapArray.buffer;\n    if (zapBuffer.__zaplibBufferData.readonly) {\n        // Store the buffer temporarily until we've received confirmation that the Arc has been incremented.\n        // Otherwise it might get garbage collected and deallocated (if the Arc's count was 1) before it gets\n        // incremented.\n        temporarilyHeldBuffersForPostMessage.add(zapBuffer);\n        rpc\n            .send(WorkerEvent.IncrementArc, zapBuffer.__zaplibBufferData.arcPtr)\n            .then(() => {\n            temporarilyHeldBuffersForPostMessage.delete(zapBuffer);\n        });\n    }\n    else {\n        unregisterMutableBuffer(zapBuffer);\n    }\n    return {\n        bufferData: zapBuffer.__zaplibBufferData,\n        byteOffset: zapArray.byteOffset,\n        byteLength: zapArray.byteLength,\n    };\n};\nexport const callRust = (name, params = []) => __awaiter(void 0, void 0, void 0, function* () {\n    checkWasm();\n    const transformedParams = params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else if (isZapBuffer(param.buffer)) {\n            checkValidZapArray(param);\n            return serializeZapArrayForPostMessage(param);\n        }\n        else {\n            if (!(param.buffer instanceof SharedArrayBuffer)) {\n                console.warn(\"Consider passing Uint8Arrays backed by ZapBuffer or SharedArrayBuffer into `callRust` to prevent copying data\");\n            }\n            return param;\n        }\n    });\n    return transformParamsFromRust(yield rpc.send(WorkerEvent.CallRust, { name, params: transformedParams }));\n});\nexport const createMutableBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    checkWasm();\n    const bufferLen = data.byteLength;\n    const bufferPtr = yield rpc.send(WorkerEvent.CreateBuffer, data, [\n        data.buffer,\n    ]);\n    return transformParamsFromRust([\n        {\n            paramType: getZapParamType(data, false),\n            bufferPtr,\n            bufferLen,\n            bufferCap: bufferLen,\n            readonly: false,\n        },\n    ])[0];\n});\nexport const createReadOnlyBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    checkWasm();\n    const bufferLen = data.byteLength;\n    const { bufferPtr, arcPtr } = yield rpc.send(WorkerEvent.CreateReadOnlyBuffer, data, [data.buffer]);\n    return transformParamsFromRust([\n        {\n            paramType: getZapParamType(data, true),\n            bufferPtr,\n            bufferLen,\n            arcPtr,\n            readonly: true,\n        },\n    ])[0];\n});\nexport const deserializeZapArrayFromPostMessage = (postMessageData) => {\n    const zapBuffer = getZapBufferWasm(wasmMemory, postMessageData.bufferData, destructor, mutableDestructor);\n    return new Uint8Array(zapBuffer, postMessageData.byteOffset, postMessageData.byteLength);\n};\nexport const callRustInSameThreadSync = (name, _params = []) => {\n    throw new Error(\"`callRustInSameThreadSync` is currently not supported on the main thread in WASM\");\n};\nfunction initializeCanvas(canvas) {\n    canvas.className = \"zaplib_canvas\";\n    document.addEventListener(\"contextmenu\", (event) => {\n        var _a;\n        if (event.target instanceof Element &&\n            !((_a = document.getElementById(\"zaplib_js_root\")) === null || _a === void 0 ? void 0 : _a.contains(event.target))) {\n            event.preventDefault();\n        }\n    });\n    document.addEventListener(\"mousedown\", (event) => {\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.CanvasMouseDown, makeRpcMouseEvent(event));\n    });\n    window.addEventListener(\"mouseup\", (event) => {\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.WindowMouseUp, makeRpcMouseEvent(event));\n    });\n    window.addEventListener(\"mousemove\", (event) => {\n        document.body.scrollTop = 0;\n        document.body.scrollLeft = 0;\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.WindowMouseMove, makeRpcMouseEvent(event));\n    });\n    window.addEventListener(\"mouseout\", (event) => {\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.WindowMouseOut, makeRpcMouseEvent(event));\n    });\n    document.addEventListener(\"touchstart\", (event) => {\n        event.preventDefault();\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.WindowTouchStart, makeRpcTouchEvent(event));\n    }, { passive: false });\n    window.addEventListener(\"touchmove\", (event) => {\n        event.preventDefault();\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.WindowTouchMove, makeRpcTouchEvent(event));\n    }, { passive: false });\n    const touchEndCancelLeave = (event) => {\n        event.preventDefault();\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.WindowTouchEndCancelLeave, makeRpcTouchEvent(event));\n    };\n    window.addEventListener(\"touchend\", touchEndCancelLeave);\n    window.addEventListener(\"touchcancel\", touchEndCancelLeave);\n    document.addEventListener(\"wheel\", (event) => {\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.CanvasWheel, makeRpcWheelEvent(event));\n    });\n    window.addEventListener(\"focus\", () => {\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.WindowFocus);\n    });\n    window.addEventListener(\"blur\", () => {\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.WindowBlur);\n    });\n    const isMobileSafari = self.navigator.platform.match(/iPhone|iPad/i);\n    const isAndroid = self.navigator.userAgent.match(/Android/i);\n    if (!isMobileSafari && !isAndroid) {\n        // mobile keyboards are unusable on a UI like this\n        const { showTextIME } = makeTextarea((taEvent) => {\n            if (wasmInitialized())\n                rpc.send(taEvent.type, taEvent);\n        });\n        rpc.receive(WorkerEvent.ShowTextIME, showTextIME);\n    }\n    const getSizingData = () => {\n        const canFullscreen = !!(document.fullscreenEnabled ||\n            document.webkitFullscreenEnabled ||\n            document.mozFullscreenEnabled);\n        const isFullscreen = !!(document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            document.mozFullscreenElement);\n        return {\n            width: canvas.offsetWidth,\n            height: canvas.offsetHeight,\n            dpiFactor: window.devicePixelRatio,\n            canFullscreen,\n            isFullscreen,\n        };\n    };\n    let webglRenderer;\n    const onScreenResize = () => {\n        // TODO(JP): Some day bring this back?\n        // if (is_add_to_homescreen_safari) { // extremely ugly. but whatever.\n        //     if (window.orientation == 90 || window.orientation == -90) {\n        //         h = screen.width;\n        //         w = screen.height - 90;\n        //     }\n        //     else {\n        //         w = screen.width;\n        //         h = screen.height - 80;\n        //     }\n        // }\n        const sizingData = getSizingData();\n        if (webglRenderer) {\n            webglRenderer.resize(sizingData);\n        }\n        if (wasmInitialized())\n            rpc.send(WorkerEvent.ScreenResize, sizingData);\n    };\n    window.addEventListener(\"resize\", () => onScreenResize());\n    window.addEventListener(\"orientationchange\", () => onScreenResize());\n    let dpiFactor = window.devicePixelRatio;\n    const mqString = \"(resolution: \" + window.devicePixelRatio + \"dppx)\";\n    const mq = matchMedia(mqString);\n    if (mq && mq.addEventListener) {\n        mq.addEventListener(\"change\", () => onScreenResize());\n    }\n    else {\n        // poll for it. yes. its terrible\n        self.setInterval(() => {\n            if (window.devicePixelRatio != dpiFactor) {\n                dpiFactor = window.devicePixelRatio;\n                onScreenResize();\n            }\n        }, 1000);\n    }\n    // If the browser supports OffscreenCanvas, then we'll use that. Otherwise, we render on\n    // the browser's main thread using WebGLRenderer.\n    let renderingMethod;\n    try {\n        renderingMethod = canvas.transferControlToOffscreen();\n    }\n    catch (_) {\n        webglRenderer = new WebGLRenderer(canvas, wasmMemory, getSizingData(), () => {\n            rpc.send(WorkerEvent.ShowIncompatibleBrowserNotification);\n        });\n        rpc.receive(WorkerEvent.RunWebGL, (zerdeParserPtr) => {\n            webglRenderer.processMessages(zerdeParserPtr);\n            return new Promise((resolve) => {\n                requestAnimationFrame(() => {\n                    resolve(undefined);\n                });\n            });\n        });\n        renderingMethod = webglRenderer;\n    }\n    return { renderingMethod, onScreenResize, getSizingData };\n}\nlet alreadyCalledInitialize = false;\nexport const initialize = (initParams) => {\n    if (alreadyCalledInitialize) {\n        throw new Error(\"Only call zaplib.initialize() once\");\n    }\n    alreadyCalledInitialize = true;\n    if (inWorker) {\n        throw new Error(\"zaplib.initialize() can only be called on the browser's main thread\");\n    }\n    overwriteTypedArraysWithZapArrays();\n    return new Promise((resolve) => {\n        var _a;\n        _rpc = new Rpc(new MainWorker());\n        const baseUri = (_a = initParams.baseUri) !== null && _a !== void 0 ? _a : window.location.protocol + \"//\" + window.location.host + \"/\";\n        let wasmModulePromise;\n        if (typeof initParams.wasmModule == \"string\") {\n            const wasmPath = new URL(initParams.wasmModule, baseUri).href;\n            // Safari (as of version 15.2) needs the WebAssembly Module to be compiled on the browser's\n            // main thread. This also allows us to start compiling while still waiting for the DOM to load.\n            wasmModulePromise = WebAssembly.compileStreaming(fetch(wasmPath));\n        }\n        else {\n            wasmModulePromise = initParams.wasmModule;\n        }\n        // TODO(JP): These file handles are only sent to a worker when it starts running;\n        // it currently can't receive any file handles added after that.\n        const fileHandles = [];\n        const loader = () => {\n            if (initParams.defaultStyles) {\n                addDefaultStyles();\n                addLoadingIndicator();\n            }\n            // Some browsers (e.g. Safari 15.2) require SharedArrayBuffers to be initialized\n            // on the browser's main thread; so that's why this has to happen here.\n            //\n            // We also do this before initializing `WebAssembly.Memory`, to make sure we have\n            // enough memory for both.. (This is mostly relevant on mobile; see note below.)\n            const taskWorkerSab = initTaskWorkerSab();\n            const taskWorkerRpc = new Rpc(new TaskWorker());\n            taskWorkerRpc.send(TaskWorkerEvent.Init, {\n                taskWorkerSab,\n                wasmMemory,\n            });\n            // Initial has to be equal to or higher than required by the app (which at the time of writing\n            // is around 20 pages).\n            // Maximum has to be equal to or lower than that of the app, which we've currently set to\n            // the maximum for wasm32 (4GB). Browsers should use virtual memory, as to not actually take up\n            // all this space until requested by the app. TODO(JP): We might need to check this behavior in\n            // different browsers at some point (in Chrome it seems to work fine).\n            //\n            // In Safari on my phone (JP), using maximum:65535 causes an out-of-memory error, so we instead\n            // try a hardcoded value of ~400MB.. Note that especially on mobile, all of\n            // this is quite tricky; see e.g. https://github.com/WebAssembly/design/issues/1397\n            //\n            // TODO(JP): It looks like when using shared memory, the maximum might get fully allocated on\n            // some devices (mobile?), which means that there is little room left for JS objects, and it\n            // means that the web page is at higher risk of getting evicted when switching tabs. There are a\n            // few options here:\n            // 1. Allow the user to specify a maximum by hand for mobile in general; or for specific\n            //    devices (cumbersome!).\n            // 2. Allow single-threaded operation, where we don't specify a maximum (but run the risk of\n            //    getting much less memory to use and therefore the app crashing; see again\n            //    https://github.com/WebAssembly/design/issues/1397 for more details).\n            try {\n                wasmMemory = new WebAssembly.Memory({\n                    initial: 40,\n                    maximum: 65535,\n                    shared: true,\n                });\n            }\n            catch (_) {\n                console.log(\"Can't allocate full WebAssembly memory; trying ~400MB\");\n                try {\n                    wasmMemory = new WebAssembly.Memory({\n                        initial: 40,\n                        maximum: 6000,\n                        shared: true,\n                    });\n                }\n                catch (_) {\n                    throw new Error(\"Can't initilialize WebAssembly memory..\");\n                }\n            }\n            rpc.receive(WorkerEvent.ShowIncompatibleBrowserNotification, () => {\n                const span = document.createElement(\"span\");\n                span.style.color = \"white\";\n                span.innerHTML =\n                    \"Sorry, we need browser support for WebGL to run<br/>Please update your browser to a more modern one<br/>Update to at least iOS 10, Safari 10, latest Chrome, Edge or Firefox<br/>Go and update and come back, your browser will be better, faster and more secure!<br/>If you are using chrome on OSX on a 2011/2012 mac please enable your GPU at: Override software rendering list:Enable (the top item) in: <a href='about://flags'>about://flags</a>. Or switch to Firefox or Safari.\";\n            });\n            // TODO(JP): See if we can instead do this when we resolve the `initialize` Promise.\n            rpc.receive(WorkerEvent.RemoveLoadingIndicators, () => {\n                if (initParams.defaultStyles) {\n                    removeLoadingIndicator();\n                }\n            });\n            rpc.receive(WorkerEvent.SetDocumentTitle, (title) => {\n                document.title = title;\n            });\n            rpc.receive(WorkerEvent.SetMouseCursor, (style) => {\n                document.body.style.cursor = style;\n            });\n            rpc.receive(WorkerEvent.Fullscreen, () => {\n                if (document.body.requestFullscreen) {\n                    document.body.requestFullscreen();\n                }\n                else if (document.body.webkitRequestFullscreen) {\n                    document.body.webkitRequestFullscreen();\n                }\n                else if (document.body.mozRequestFullscreen) {\n                    document.body.mozRequestFullscreen();\n                }\n            });\n            rpc.receive(WorkerEvent.Normalscreen, () => {\n                if (document.exitFullscreen) {\n                    document.exitFullscreen();\n                }\n                else if (document.webkitExitFullscreen) {\n                    document.webkitExitFullscreen();\n                }\n                else if (document.mozExitFullscreen) {\n                    document.mozExitFullscreen();\n                }\n            });\n            rpc.receive(WorkerEvent.TextCopyResponse, (textCopyResponse) => {\n                window.navigator.clipboard.writeText(textCopyResponse);\n            });\n            rpc.receive(WorkerEvent.EnableGlobalFileDropTarget, () => {\n                document.addEventListener(\"dragenter\", (ev) => {\n                    const dataTransfer = ev.dataTransfer;\n                    // dataTransfer isn't guaranteed to exist by spec, so it must be checked\n                    if (dataTransfer &&\n                        dataTransfer.types.length === 1 &&\n                        dataTransfer.types[0] === \"Files\") {\n                        ev.stopPropagation();\n                        ev.preventDefault();\n                        dataTransfer.dropEffect = \"copy\";\n                        if (wasmInitialized())\n                            rpc.send(WorkerEvent.DragEnter);\n                    }\n                });\n                document.addEventListener(\"dragover\", (ev) => {\n                    ev.stopPropagation();\n                    ev.preventDefault();\n                    if (wasmInitialized())\n                        rpc.send(WorkerEvent.DragOver, { x: ev.clientX, y: ev.clientY });\n                });\n                document.addEventListener(\"dragleave\", (ev) => {\n                    ev.stopPropagation();\n                    ev.preventDefault();\n                    if (wasmInitialized())\n                        rpc.send(WorkerEvent.DragLeave);\n                });\n                document.addEventListener(\"drop\", (ev) => {\n                    if (!ev.dataTransfer) {\n                        return;\n                    }\n                    const files = Array.from(ev.dataTransfer.files);\n                    if (!files.length) {\n                        return;\n                    }\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                    const fileHandlesToSend = [];\n                    for (const file of files) {\n                        const fileHandle = {\n                            id: fileHandles.length,\n                            basename: file.name,\n                            file,\n                            lastReadStart: -1,\n                            lastReadEnd: -1,\n                        };\n                        fileHandlesToSend.push(fileHandle);\n                        fileHandles.push(fileHandle);\n                    }\n                    if (wasmInitialized()) {\n                        rpc.send(WorkerEvent.Drop, { fileHandles, fileHandlesToSend });\n                    }\n                });\n            });\n            rpc.receive(WorkerEvent.CallJs, ({ fnName, params }) => {\n                const fn = jsFunctions[fnName];\n                if (!fn) {\n                    console.error(`call_js with ${fnName} is not available. Have you registered it using \\`registerCallJsCallbacks\\`?`);\n                    return;\n                }\n                fn(transformParamsFromRust(params));\n            });\n            let canvasData = {\n                getSizingData: () => {\n                    // Dummy sizing data if we're not rendering.\n                    // TODO(JP): We should make it so we're not even sending SizingData\n                    // at all if we're not rendering.\n                    return {\n                        width: 0,\n                        height: 0,\n                        dpiFactor: 1,\n                        canFullscreen: false,\n                        isFullscreen: false,\n                    };\n                },\n                onScreenResize: () => {\n                    // Dummy function for if we're note rendering.\n                },\n                renderingMethod: undefined,\n            };\n            let canvas = initParams.canvas;\n            if (!canvas && initParams.defaultStyles) {\n                canvas = document.createElement(\"canvas\");\n                document.body.appendChild(canvas);\n            }\n            if (canvas) {\n                canvasData = initializeCanvas(canvas);\n            }\n            rpc.receive(WorkerEvent.Panic, (e) => {\n                if (initParams.onRenderingPanic) {\n                    initParams.onRenderingPanic(e);\n                }\n                else {\n                    console.warn(\"Specify `onRenderingPanic` to catch errors from rendering. See https://zaplib.com/docs/bridge_api_basics.html#zaplibinitialize.\");\n                    throw e;\n                }\n            });\n            wasmModulePromise.then((wasmModule) => {\n                // Threads need to be spawned on the browser's main thread, otherwise Safari (as of version 15.2)\n                // throws errors.\n                const asyncWorkers = new Set();\n                const threadSpawn = ({ ctxPtr, tlsAndStackData, }) => {\n                    const worker = new AsyncWorker();\n                    const workerErrorHandler = (event) => {\n                        console.log(\"Async worker error event: \", event);\n                    };\n                    worker.onerror = workerErrorHandler;\n                    worker.onmessageerror = workerErrorHandler;\n                    const workerRpc = new Rpc(worker);\n                    // Add the worker to an array of workers, to prevent them getting killed when\n                    // during garbage collection in Firefox; see https://bugzilla.mozilla.org/show_bug.cgi?id=1592227\n                    asyncWorkers.add(worker);\n                    const channel = new MessageChannel();\n                    rpc.send(WorkerEvent.BindMainWorkerPort, channel.port1, [\n                        channel.port1,\n                    ]);\n                    workerRpc.receive(AsyncWorkerEvent.ThreadSpawn, threadSpawn);\n                    workerRpc\n                        .send(AsyncWorkerEvent.Run, {\n                        wasmModule,\n                        memory: wasmMemory,\n                        taskWorkerSab,\n                        ctxPtr,\n                        fileHandles,\n                        baseUri,\n                        tlsAndStackData,\n                        mainWorkerPort: channel.port2,\n                    }, [channel.port2])\n                        .catch((e) => {\n                        console.error(\"async worker failed\", e);\n                    })\n                        .finally(() => {\n                        worker.terminate();\n                        asyncWorkers.delete(worker);\n                    });\n                };\n                rpc.receive(WorkerEvent.ThreadSpawn, threadSpawn);\n                const offscreenCanvas = self.OffscreenCanvas &&\n                    canvasData.renderingMethod instanceof OffscreenCanvas\n                    ? canvasData.renderingMethod\n                    : undefined;\n                rpc\n                    .send(WorkerEvent.Init, {\n                    wasmModule,\n                    offscreenCanvas,\n                    sizingData: canvasData.getSizingData(),\n                    baseUri,\n                    memory: wasmMemory,\n                    taskWorkerSab,\n                    wasmOnline,\n                }, offscreenCanvas ? [offscreenCanvas] : [])\n                    .then(() => {\n                    canvasData.onScreenResize();\n                    resolve();\n                });\n            });\n        };\n        if (document.readyState !== \"loading\") {\n            loader();\n        }\n        else {\n            document.addEventListener(\"DOMContentLoaded\", loader);\n        }\n    });\n};\n","import { assertNotNull } from \"common\";\nexport function addLoadingIndicator() {\n    const style = document.createElement(\"style\");\n    style.innerHTML = `\n    .zaplib_loading_indicator {\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        color: #666;\n        font-size: 40px;\n    }\n    .zaplib_loading_indicator > span {\n        display: inline-block;\n        animation-name: wiggle;\n        animation-duration: 1000ms;\n        animation-iteration-count: infinite;\n        animation-timing-function: ease-in-out;\n    }\n    @keyframes wiggle {\n        0% {transform: rotate(0deg);}\n        10% {transform: rotate(10deg);}\n        30% {transform: rotate(-10deg);}\n        50% {transform: rotate(20deg);}\n        70% {transform: rotate(-5deg);}\n        90% {transform: rotate(2deg);}\n        95% {transform: rotate(0deg);}\n    }\n\n    .zaplib_loading_indicator > div {\n        position: absolute;\n        width: max-content;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, 40px);\n        font-family: Verdana, Arial Black;\n        font-weight: bold;\n        font-size: 28px;\n\n        background: #222 -webkit-gradient(linear, left top, right top, from(#222), to(#222), color-stop(0.5, #fff)) 0 0 no-repeat;\n        background-image: -webkit-linear-gradient(-40deg, transparent 0%, transparent 40%, #fff 50%, transparent 60%, transparent 100%);\n        background-size: 200px;\n        -webkit-background-clip: text;\n        background-clip: text;\n        animation-name: shine;\n        animation-duration: 1s;\n        animation-iteration-count: infinite;\n        text-shadow: 0 0px 0px rgba(255, 255, 255, 0.5);\n    }\n    @keyframes shine {\n        0% {\n            background-position: -200px 0;\n        }\n        100% {\n            background-position: 250px 0;\n        }\n    }`;\n    document.body.appendChild(style);\n    const loadingIndicator = document.createElement(\"div\");\n    loadingIndicator.className = \"zaplib_loading_indicator\";\n    loadingIndicator.innerHTML =\n        '<span></span><div style=\"color: rgba(255, 202, 0, 0.5);\">Loading</div>';\n    document.body.appendChild(loadingIndicator);\n}\nexport function removeLoadingIndicator() {\n    const loaders = document.getElementsByClassName(\"zaplib_loading_indicator\");\n    for (let i = 0; i < loaders.length; i++) {\n        assertNotNull(loaders[i].parentNode).removeChild(loaders[i]);\n    }\n}\n","// Be sure to keep this in sync with cursor.rs!\nexport const cursorMap = [\n    \"none\",\n    \"default\",\n    \"crosshair\",\n    \"pointer\",\n    \"default\",\n    \"move\",\n    \"text\",\n    \"wait\",\n    \"help\",\n    \"not-allowed\",\n    \"n-resize\",\n    \"ne-resize\",\n    \"e-resize\",\n    \"se-resize\",\n    \"s-resize\",\n    \"sw-resize\",\n    \"w-resize\",\n    \"nw-resize\",\n    \"ns-resize\",\n    \"nesw-resize\",\n    \"ew-resize\",\n    \"nwse-resize\",\n    \"col-resize\",\n    \"row-resize\", // RowResize=>23,\n];\n","export function packKeyModifier(e) {\n    return ((e.shiftKey ? 1 : 0) |\n        (e.ctrlKey ? 2 : 0) |\n        (e.altKey ? 4 : 0) |\n        (e.metaKey ? 8 : 0));\n}\nexport const zerdeKeyboardHandlers = {\n    keyDown(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(12);\n        zerdeBuilder.sendU32(data.event.keyCode);\n        zerdeBuilder.sendU32(data.event.repeat ? 1 : 0);\n        zerdeBuilder.sendU32(packKeyModifier(data.event));\n        zerdeBuilder.sendF64(performance.now() / 1000.0);\n    },\n    keyUp(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(13);\n        zerdeBuilder.sendU32(data.event.keyCode);\n        zerdeBuilder.sendU32(data.event.repeat ? 1 : 0);\n        zerdeBuilder.sendU32(packKeyModifier(data.event));\n        zerdeBuilder.sendF64(performance.now() / 1000.0);\n    },\n    textInput(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(14);\n        zerdeBuilder.sendU32(data.wasPaste ? 1 : 0),\n            zerdeBuilder.sendU32(data.replaceLast ? 1 : 0),\n            zerdeBuilder.sendString(data.input);\n    },\n    textCopy(zerdeBuilder) {\n        zerdeBuilder.sendU32(17);\n    },\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { cursorMap } from \"cursor_map\";\nimport { copyArrayToRustBuffer, getZapParamType } from \"common\";\nimport { makeTextarea } from \"make_textarea\";\nimport { ZapParamType, } from \"types\";\nimport { getCachedZapBuffer, overwriteTypedArraysWithZapArrays, isZapBuffer, checkValidZapArray, getZapBufferCef, } from \"zap_buffer\";\nimport { ZerdeBuilder } from \"zerde\";\nimport { zerdeKeyboardHandlers } from \"zerde_keyboard_handlers\";\nimport { WorkerEvent } from \"rpc_types\";\nimport { addDefaultStyles } from \"default_styles\";\nlet newCallbackId = 0;\n// keeping track of pending callbacks from rust side\nconst pendingCallbacks = {};\nconst transformParamsForRust = (params) => params.map((param) => {\n    if (typeof param === \"string\") {\n        return param;\n    }\n    else {\n        if (isZapBuffer(param.buffer)) {\n            checkValidZapArray(param);\n            const zapBuffer = param.buffer;\n            return [\n                zapBuffer.__zaplibWasmBuffer,\n                getZapParamType(param, zapBuffer.readonly),\n            ];\n        }\n        const paramType = getZapParamType(param, false);\n        const [cefBuffer] = window.cefCreateArrayBuffer(param.length, paramType);\n        // TODO(Dmitry): implement optimization to avoid copying when possible\n        copyArrayToRustBuffer(param, cefBuffer, 0);\n        return [cefBuffer, paramType];\n    }\n});\nexport const callRust = (name, params = []) => {\n    const callbackId = newCallbackId++;\n    const promise = new Promise((resolve, _reject) => {\n        pendingCallbacks[callbackId] = (data) => {\n            // TODO(Dmitry): implement retrun_error on rust side and use reject(...) to communicate the error\n            resolve(data);\n        };\n    });\n    window.cefCallRust(name, transformParamsForRust(params), callbackId);\n    return promise;\n};\nfunction _zaplibReturnParams(params) {\n    const callbackId = JSON.parse(params[0]);\n    pendingCallbacks[callbackId](params.slice(1));\n    delete pendingCallbacks[callbackId];\n}\n// Initial set of framework-specific functions\nconst fromCefJsFunctions = {\n    _zaplibReturnParams,\n};\n/// Users must call this function to register functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const registerCallJsCallbacks = (fns) => {\n    // Check that all new functions are unique\n    for (const key of Object.keys(fns)) {\n        if (key in fromCefJsFunctions) {\n            throw new Error(`Error: overwriting existing function \"${key}\"`);\n        }\n    }\n    Object.assign(fromCefJsFunctions, fns);\n    window.cefReadyForMessages();\n};\n/// Users must call this function to unregister functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const unregisterCallJsCallbacks = (fnNames) => {\n    fnNames.forEach((name) => {\n        // Check that functions are registered\n        if (!(name in fromCefJsFunctions)) {\n            throw new Error(`Error: unregistering non-existent function \"${name}\"`);\n        }\n        delete fromCefJsFunctions[name];\n    });\n};\nconst transformReturnParams = (returnParams) => returnParams.map((param) => {\n    if (typeof param === \"string\") {\n        return param;\n    }\n    else {\n        const [buffer, arcPtr, paramType] = param;\n        const zapBuffer = getZapBufferCef(buffer, arcPtr, paramType);\n        if (paramType === ZapParamType.String) {\n            throw new Error(\"ZapParam buffer type called with string paramType\");\n        }\n        // These are actually ZapArray types, since we overwrite TypedArrays in overwriteTypedArraysWithZapArrays()\n        const ParamTypeToArrayConstructor = {\n            [ZapParamType.U8Buffer]: Uint8Array,\n            [ZapParamType.ReadOnlyU8Buffer]: Uint8Array,\n            [ZapParamType.F32Buffer]: Float32Array,\n            [ZapParamType.ReadOnlyF32Buffer]: Float32Array,\n        };\n        // Creating array with stable identity as that's what underlying underlying API expects\n        return getCachedZapBuffer(zapBuffer, new ParamTypeToArrayConstructor[paramType](zapBuffer));\n    }\n});\n// TODO(JP): Some of this code is duplicated with callRust/call_js; see if we can reuse some.\nexport const callRustInSameThreadSync = (name, params = []) => transformReturnParams(window.cefCallRustInSameThreadSync(name, transformParamsForRust(params)));\nexport const newWorkerPort = () => {\n    throw new Error(\"`newWorkerPort` is currently not supported on CEF\");\n};\nexport const serializeZapArrayForPostMessage = (_postMessageData) => {\n    throw new Error(\"`serializeZapArrayForPostMessage` is currently not supported on CEF\");\n};\nexport const deserializeZapArrayFromPostMessage = (_postMessageData) => {\n    throw new Error(\"`deserializeZapArrayFromPostMessage` is currently not supported on CEF\");\n};\nexport const initialize = (initParams) => new Promise((resolve) => {\n    overwriteTypedArraysWithZapArrays();\n    window.fromCefSetMouseCursor = (cursorId) => {\n        if (document.body) {\n            document.body.style.cursor = cursorMap[cursorId] || \"default\";\n        }\n    };\n    window.fromCefCallJsFunction = (name, params) => {\n        fromCefJsFunctions[name](transformReturnParams(params));\n    };\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        if (initParams.defaultStyles) {\n            addDefaultStyles();\n        }\n        const { showTextIME, textareaHasFocus } = makeTextarea((taEvent) => {\n            const slots = 20;\n            const [buffer] = window.cefCreateArrayBuffer(slots * 4, ZapParamType.U8Buffer);\n            const zerdeBuilder = new ZerdeBuilder({\n                buffer,\n                byteOffset: 0,\n                slots,\n                growCallback: () => {\n                    throw new Error(\"Growing of this buffer is not supported\");\n                },\n            });\n            if (taEvent.type === WorkerEvent.KeyDown) {\n                zerdeKeyboardHandlers.keyDown(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === WorkerEvent.KeyUp) {\n                zerdeKeyboardHandlers.keyUp(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === WorkerEvent.TextInput) {\n                zerdeKeyboardHandlers.textInput(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === WorkerEvent.TextCopy) {\n                zerdeKeyboardHandlers.textCopy(zerdeBuilder);\n            }\n            window.cefHandleKeyboardEvent(buffer);\n        });\n        window.fromCefSetIMEPosition = (x, y) => {\n            showTextIME({ x, y });\n        };\n        document.addEventListener(\"keydown\", (event) => {\n            const code = event.keyCode;\n            if (event.metaKey || event.ctrlKey) {\n                if (!textareaHasFocus()) {\n                    // TODO(JP): Maybe at some point we should use some library for these keycodes,\n                    // e.g. see https://stackoverflow.com/questions/1465374/event-keycode-constants\n                    if (code == 67 /* c */) {\n                        window.cefTriggerCopy();\n                    }\n                    else if (code == 88 /* x */) {\n                        window.cefTriggerCut();\n                    }\n                    else if (code == 65 /* a */) {\n                        window.cefTriggerSelectAll();\n                    }\n                }\n                // We want pastes to also be triggered when the textarea has focus, so we can\n                // handle the paste event in JS.\n                if (code == 86 /* v */) {\n                    window.cefTriggerPaste();\n                }\n            }\n        });\n        resolve();\n    });\n});\n// TODO(JP): See comment at CreateBuffer type.\nexport const createMutableBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const paramType = getZapParamType(data, false);\n    const [cefBuffer] = window.cefCreateArrayBuffer(data.length, paramType);\n    copyArrayToRustBuffer(data, cefBuffer, 0);\n    return transformReturnParams([\n        [cefBuffer, undefined, paramType],\n    ])[0];\n});\n// TODO(JP): See comment at CreateBuffer type.\nexport const createReadOnlyBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const paramType = getZapParamType(data, true);\n    const [cefBuffer, arcPtr] = window.cefCreateArrayBuffer(data.length, paramType);\n    copyArrayToRustBuffer(data, cefBuffer, 0);\n    return transformReturnParams([\n        [cefBuffer, arcPtr, paramType],\n    ])[0];\n});\n","\n      import API from \"!./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!./node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!./node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!./node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!./node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!./node_modules/css-loader/dist/cjs.js!./zaplib.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!./node_modules/css-loader/dist/cjs.js!./zaplib.css\";\n       export default content && content.locals ? content.locals : undefined;\n","// This is the universal Zaplib Runtime which will work on both CEF and WebAssembly environments,\n// doing runtime detection of which modules to load. No other file besides this one should conditionally\n// branch based on environments, such that cef/wasm runtimes can work without including unnecessary code.\nimport * as wasm from \"wasm_runtime\";\nimport * as cef from \"cef_runtime\";\nimport { jsRuntime } from \"type_of_runtime\";\nimport \"./zaplib.css\";\nconst { initialize, newWorkerPort, registerCallJsCallbacks, unregisterCallJsCallbacks, callRust, serializeZapArrayForPostMessage, deserializeZapArrayFromPostMessage, callRustInSameThreadSync, createMutableBuffer, createReadOnlyBuffer, } = jsRuntime === \"cef\" ? cef : wasm;\nexport { initialize, newWorkerPort, registerCallJsCallbacks, unregisterCallJsCallbacks, callRust, serializeZapArrayForPostMessage, deserializeZapArrayFromPostMessage, callRustInSameThreadSync, jsRuntime, createMutableBuffer, createReadOnlyBuffer, };\n","// Zerde is our lightweight manual serialization/deserialization system.\n//\n// Keep in sync with zerde.rs, and see there for more information.\nimport { ZapParamType } from \"types\";\n// Construct a buffer that can be read in Rust, using the corresponding `ZerderParser` struct in Rust.\nexport class ZerdeBuilder {\n    constructor({ buffer, byteOffset, slots, growCallback, }) {\n        this._buffer = buffer;\n        this._byteOffset = byteOffset;\n        this._slots = slots;\n        this._growCallback = growCallback;\n        this._used = 2; // Skip 8 byte header which contains the size.\n        this._updateRefs();\n    }\n    _updateRefs() {\n        this._f32 = new Float32Array(this._buffer, this._byteOffset, this._slots);\n        this._u32 = new Uint32Array(this._buffer, this._byteOffset, this._slots);\n        this._f64 = new Float64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64 = new BigUint64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64[0] = BigInt(this._slots) * BigInt(4); // Write size to header.\n    }\n    _fit(slots) {\n        if (this._used + slots > this._slots) {\n            let newSlots = Math.max(this._used + slots, this._slots * 2); // Exponential growth\n            if (newSlots & 1)\n                newSlots++; // 64-bit align it\n            const newBytes = newSlots * 4;\n            const { buffer, byteOffset } = this._growCallback(this._buffer, this._byteOffset, newBytes);\n            this._buffer = buffer;\n            this._byteOffset = byteOffset;\n            this._slots = newSlots;\n            this._updateRefs();\n        }\n        const pos = this._used;\n        this._used += slots;\n        return pos;\n    }\n    sendF32(value) {\n        const pos = this._fit(1);\n        this._f32[pos] = value;\n    }\n    sendU32(value) {\n        const pos = this._fit(1);\n        this._u32[pos] = value;\n    }\n    sendF64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._f64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._f64[pos >> 1] = value;\n        }\n    }\n    sendU64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._u64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._u64[pos >> 1] = value;\n        }\n    }\n    sendString(str) {\n        let pos = this._fit(str.length + 1);\n        this._u32[pos++] = str.length;\n        for (let i = 0; i < str.length; i++) {\n            this._u32[pos++] = str.charCodeAt(i);\n        }\n    }\n    getData() {\n        return { buffer: this._buffer, byteOffset: this._byteOffset };\n    }\n}\nexport class ZerdeParser {\n    constructor(memory, zerdePtr) {\n        this._memory = memory;\n        // set up local shortcuts to the zerde memory chunk for faster parsing\n        this._usedSlots = 2; // skip the 8 byte header\n        this._f32 = new Float32Array(this._memory.buffer, zerdePtr);\n        this._u32 = new Uint32Array(this._memory.buffer, zerdePtr);\n        this._f64 = new Float64Array(this._memory.buffer, zerdePtr);\n        this._u64 = new BigUint64Array(this._memory.buffer, zerdePtr);\n    }\n    parseU32() {\n        return this._u32[this._usedSlots++];\n    }\n    parseF32() {\n        return this._f32[this._usedSlots++];\n    }\n    parseF64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._f64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseU64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._u64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseString() {\n        let str = \"\";\n        const len = this.parseU32();\n        for (let i = 0; i < len; i++) {\n            const c = this.parseU32();\n            if (c != 0)\n                str += String.fromCharCode(c);\n        }\n        return str;\n    }\n    parseU8Slice() {\n        const u8Len = this.parseU32();\n        const len = u8Len >> 2;\n        const data = new Uint8Array(u8Len);\n        const spare = u8Len & 3;\n        for (let i = 0; i < len; i++) {\n            const u8Pos = i << 2;\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n            data[u8Pos + 3] = (u32 >> 24) & 0xff;\n        }\n        const u8Pos = len << 2;\n        if (spare == 1) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n        }\n        else if (spare == 2) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n        }\n        else if (spare == 3) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n        }\n        return data;\n    }\n    parseZapParams() {\n        const len = this.parseU32();\n        const params = [];\n        for (let i = 0; i < len; ++i) {\n            const paramType = this.parseU32();\n            if (paramType === ZapParamType.String) {\n                params.push(this.parseString());\n            }\n            else if (paramType === ZapParamType.ReadOnlyU8Buffer ||\n                paramType === ZapParamType.ReadOnlyF32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const arcPtr = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    arcPtr,\n                    readonly: true,\n                });\n            }\n            else if (paramType === ZapParamType.U8Buffer ||\n                paramType === ZapParamType.F32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const bufferCap = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    bufferCap,\n                    readonly: false,\n                });\n            }\n            else {\n                throw new Error(`Unknown ZapParam type: ${paramType}`);\n            }\n        }\n        return params;\n    }\n}\n","\"use strict\";\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { ZapParamType } from \"types\";\nimport { ZapBuffer, classesToExtend, containsZapBuffer } from \"zap_buffer\";\nimport { expect, expectThrow } from \"test_suite/test_helpers\";\nconst { ZapUint8Array, ZapUint16Array } = window;\n// Test that ZapArray is created like a DataView\nfunction testBuffer() {\n    const wasmMemory = new SharedArrayBuffer(1024);\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 10,\n        bufferLen: 4,\n        bufferCap: 4,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const a = new ZapUint8Array(buffer, 10, 4);\n    expect(a.byteOffset, 10);\n    expect(a.length, 4);\n}\n// Test that new ZapArray shares the same ZapBuffer\nfunction testShare() {\n    const wasmMemory = new SharedArrayBuffer(1024);\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 0,\n        bufferLen: 1024,\n        bufferCap: 1024,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const a = new ZapUint8Array(buffer);\n    const b = new ZapUint16Array(a.buffer);\n    expect(a.buffer, buffer);\n    expect(a.buffer, b.buffer);\n}\n// Test ZapArray out-of-bounds behavior\nfunction testOutOfBounds() {\n    const wasmMemory = new SharedArrayBuffer(1024);\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 1,\n        bufferLen: 16,\n        bufferCap: 16,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    // start is outside of the view - should throw\n    expectThrow(() => {\n        new ZapUint8Array(buffer, 0);\n    }, \"Byte_offset 0 is out of bounds\");\n    // these doesn't throw but overwrites the end of the data\n    const a = new ZapUint8Array(buffer, 1);\n    expect(a.length, 16);\n    const b = new ZapUint8Array(buffer, 2);\n    expect(b.length, 15);\n    // end is outside of the view - should throw\n    expectThrow(() => {\n        new ZapUint8Array(buffer, 15, 3);\n    }, \"Byte_offset 15 + length 3 is out of bounds\");\n}\n// Test that ZapBuffer and ZapArray could be created from ArrayBuffer\nfunction testArrayBuffer() {\n    const array = new ArrayBuffer(16);\n    const buffer = new ZapBuffer(array, {\n        bufferPtr: 0,\n        bufferLen: array.byteLength,\n        bufferCap: array.byteLength,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const a = new ZapUint8Array(buffer);\n    expect(a.byteOffset, 0);\n    expect(a.byteLength, 16);\n}\n// Check that all names follow the convetion of having Zap as prefix\n// e.g. ZapUint8Array overrides Uint8Array\nfunction testZapNameMatches() {\n    for (const [cls, zapCls] of Object.entries(classesToExtend)) {\n        const expectedName = \"Zap\" + cls;\n        expect(expectedName, zapCls);\n    }\n}\nfunction testSubarray() {\n    const wasmMemory = new SharedArrayBuffer(5);\n    const regularArray = new Uint8Array(wasmMemory);\n    regularArray.set(Uint8Array.from([0, 1, 2, 3, 4]));\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 0,\n        bufferLen: 5,\n        bufferCap: 5,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const zapArray = new ZapUint8Array(buffer);\n    expect(zapArray.subarray().buffer, buffer);\n    expect(zapArray.subarray().toString(), regularArray.subarray().toString());\n    expect(zapArray.subarray(1, 3).toString(), regularArray.subarray(1, 3).toString());\n    expect(zapArray.subarray(-2, 0).toString(), regularArray.subarray(-2, 0).toString());\n    expect(zapArray.subarray(-3, -1).toString(), regularArray.subarray(-3, -1).toString());\n    expect(zapArray.subarray(1, -1).toString(), regularArray.subarray(1, -1).toString());\n}\nfunction testContainsZapBuffer() {\n    const wasmMemory = new SharedArrayBuffer(16);\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 0,\n        bufferLen: 16,\n        bufferCap: 16,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const a = new ZapUint8Array(buffer);\n    expect(containsZapBuffer(a), true);\n    expect(containsZapBuffer([a]), true);\n    expect(containsZapBuffer({ key: a }), true);\n    expect(containsZapBuffer(new Set([a])), true);\n    const map = new Map();\n    map.set(\"key\", a);\n    expect(containsZapBuffer(map), true);\n    // calling slice removes the error\n    expect(containsZapBuffer(a.slice()), false);\n    // edge cases\n    expect(containsZapBuffer(undefined), false);\n    expect(containsZapBuffer(null), false);\n}\nexport const zapBufferTests = {\n    testBuffer,\n    testShare,\n    testOutOfBounds,\n    testZapNameMatches,\n    testArrayBuffer,\n    testSubarray,\n    testContainsZapBuffer,\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// @ts-ignore\nimport TestSuiteWorker from \"worker-loader?inline=no-fallback!test_suite/test_suite_worker\";\nimport { assertNotNull, Rpc } from \"common\";\nimport { zapBufferTests } from \"test_suite/zap_buffer_test\";\nimport * as zaplib from \"zaplib_runtime\";\nimport { expect, expectDeallocationOrUnregister as _expectDeallocationOrUnregister, expectThrowAsync, setInTest, } from \"test_suite/test_helpers\";\nimport { inWorker } from \"type_of_runtime\";\nconst expectDeallocationOrUnregister = (buffer) => _expectDeallocationOrUnregister(zaplib.callRust, buffer);\nconst rpc = new Rpc(new TestSuiteWorker());\nconst runWorkerTest = (testName) => () => rpc.send(\"runTest\", testName);\nconst env = new URL(window.document.location.toString()).searchParams.has(\"release\")\n    ? \"release\"\n    : \"debug\";\nlet onRenderingPanicCalled = false;\nzaplib\n    .initialize({\n    wasmModule: `target/wasm32-unknown-unknown/${env}/test_suite.wasm`,\n    defaultStyles: true,\n    onRenderingPanic: () => {\n        onRenderingPanicCalled = true;\n    },\n})\n    .then(() => __awaiter(void 0, void 0, void 0, function* () {\n    // Initialize the worker by sending a \"zap worker port\" to it in the first message.\n    if (zaplib.jsRuntime === \"wasm\") {\n        const zapWorkerPort = zaplib.newWorkerPort();\n        yield rpc.send(\"initWasm\", zapWorkerPort, [zapWorkerPort]);\n    }\n    zaplib.registerCallJsCallbacks({\n        log(params) {\n            console.log(\"log fn called\", params[0]);\n            const div = document.createElement(\"div\");\n            div.innerText = \"log fn called: \" + params[0];\n            assertNotNull(document.getElementById(\"root\")).append(div);\n        },\n        sendWorker(params) {\n            const toSend = params[0];\n            console.log(\"sending data\", toSend);\n            // Note: uncomment to see the error about sending typed arrays\n            // worker.postMessage(buffers[0]);\n            rpc.send(\"sendWorker\", zaplib.serializeZapArrayForPostMessage(toSend));\n        },\n    });\n    const runtimeSpecificTests = zaplib.jsRuntime === \"wasm\"\n        ? {\n            \"Call rust from worker\": runWorkerTest(\"testCallRustFromWorker\"),\n            \"Call rust (no return) from worker\": runWorkerTest(\"testCallRustNoReturnFromWorker\"),\n            \"Call rust with Float32Array from worker\": runWorkerTest(\"testCallRustFloat32ArrayFromWorker\"),\n            \"Call rust in same thread sync with Float32Array from worker\": runWorkerTest(\"testCallRustInSameThreadSyncFloat32ArrayFromWorker\"),\n            \"Test that for a worker 'inWorker' returns true\": runWorkerTest(\"testInWorker\"),\n            \"Send zap array to main thread\": () => __awaiter(void 0, void 0, void 0, function* () {\n                const result = yield rpc.send(\"testSendZapArrayToMainThread\");\n                const array = zaplib.deserializeZapArrayFromPostMessage(result.array);\n                const subarray = zaplib.deserializeZapArrayFromPostMessage(result.subarray);\n                expect(array.length, 4);\n                expect(array[0], 30);\n                expect(array[1], 40);\n                expect(array[2], 50);\n                expect(array[3], 60);\n                expect(subarray.length, 2);\n                expect(subarray[0], 40);\n                expect(subarray[1], 50);\n            }),\n            \"Call Rust in same thread with zapbuffer\": () => __awaiter(void 0, void 0, void 0, function* () {\n                const result = yield rpc.send(\"testCallRustInSameThreadSyncWithZapbuffer\");\n                const array = zaplib.deserializeZapArrayFromPostMessage(result);\n                expect(array.length, 8);\n                expect(array[0], 10);\n                expect(array[1], 20);\n                expect(array[2], 30);\n                expect(array[3], 40);\n                expect(array[4], 50);\n                expect(array[5], 60);\n                expect(array[6], 70);\n                expect(array[7], 80);\n            }),\n            \"Send signal from worker\": runWorkerTest(\"testCallRustInSameThreadSyncWithSignal\"),\n        }\n        : {\n            \"Call Rust (in same thread)\": () => {\n                const buffer = new SharedArrayBuffer(8);\n                new Uint8Array(buffer).set([1, 2, 3, 4, 5, 6, 7, 8]);\n                const uint8Part = new Uint8Array(buffer, 2, 4);\n                const [result] = zaplib.callRustInSameThreadSync(\"array_multiply_u8\", [JSON.stringify(10), uint8Part]);\n                expect(result.length, 4);\n                expect(result[0], 30);\n                expect(result[1], 40);\n                expect(result[2], 50);\n                expect(result[3], 60);\n            },\n            \"Call Rust with Float32Array (in same thread)\": () => __awaiter(void 0, void 0, void 0, function* () {\n                // Using a normal array\n                const input = new Float32Array([0.1, 0.9, 0.3]);\n                const result = zaplib.callRustInSameThreadSync(\"array_multiply_f32\", [JSON.stringify(10), input])[0];\n                expect(result.length, 3);\n                expect(result[0], 1);\n                expect(result[1], 9);\n                expect(result[2], 3);\n                // Using a ZapArray\n                const input2 = yield zaplib.createMutableBuffer(new Float32Array([0.1, 0.9, 0.3]));\n                const result2 = zaplib.callRustInSameThreadSync(\"array_multiply_f32\", [JSON.stringify(10), input2])[0];\n                expect(result2.length, 3);\n                expect(result2[0], 1);\n                expect(result2[1], 9);\n                expect(result2[2], 3);\n                // Using a readonly ZapArray\n                const input3 = yield zaplib.createReadOnlyBuffer(new Float32Array([0.1, 0.9, 0.3]));\n                const result3 = zaplib.callRustInSameThreadSync(\"array_multiply_f32_readonly\", [JSON.stringify(10), input3])[0];\n                expect(result3.length, 3);\n                expect(result3[0], 1);\n                expect(result3[1], 9);\n                expect(result3[2], 3);\n            }),\n        };\n    const tests = Object.assign(Object.assign({ \"Call Rust\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const buffer = new SharedArrayBuffer(8);\n            new Uint8Array(buffer).set([1, 2, 3, 4, 5, 6, 7, 8]);\n            const uint8Part = new Uint8Array(buffer, 2, 4);\n            const [result] = yield zaplib.callRust(\"array_multiply_u8\", [\n                JSON.stringify(10),\n                uint8Part,\n            ]);\n            expect(result.length, 4);\n            expect(result[0], 30);\n            expect(result[1], 40);\n            expect(result[2], 50);\n            expect(result[3], 60);\n        }), \"Call Rust (no return)\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const result = yield zaplib.callRust(\"call_rust_no_return\");\n            expect(result.length, 0);\n        }), \"Call Rust (string return)\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const buffer = new SharedArrayBuffer(8);\n            const data = new Uint8Array(buffer);\n            data.set([1, 2, 3, 4, 5, 6, 7, 8]);\n            const [result] = yield zaplib.callRust(\"total_sum\", [data]);\n            expect(result, \"36\");\n        }), \"Call Rust (with ZapBuffer)\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const buffer = yield zaplib.createReadOnlyBuffer(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]));\n            const result = (yield zaplib.callRust(\"array_multiply_u8_readonly\", [\n                JSON.stringify(10),\n                buffer,\n            ]))[0];\n            expect(result.length, 8);\n            expect(result[0], 10);\n            expect(result[1], 20);\n            expect(result[2], 30);\n            expect(result[3], 40);\n            expect(result[4], 50);\n            expect(result[5], 60);\n            expect(result[6], 70);\n            expect(result[7], 80);\n            return Promise.all([\n                expectDeallocationOrUnregister(buffer),\n                expectDeallocationOrUnregister(result),\n            ]);\n        }), \"Call Rust (with Mutable ZapBuffer)\": () => __awaiter(void 0, void 0, void 0, function* () {\n            // TODO(Paras): Add enforcement of readonly ZapArrays and test it.\n            // const [buffer] = await zaplib.callRust(\"make_zapbuffer\");\n            // let err;\n            // try {\n            //     buffer[0] = 0;\n            // } catch (e) {\n            //     err = e;\n            // } finally {\n            //     expect(err?.message, \"Cannot mutate a read-only array\");\n            // }\n            const mutableBuffer = yield zaplib.createMutableBuffer(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]));\n            expect(mutableBuffer.length, 8);\n            expect(mutableBuffer[0], 1);\n            expect(mutableBuffer[1], 2);\n            expect(mutableBuffer[2], 3);\n            expect(mutableBuffer[3], 4);\n            expect(mutableBuffer[4], 5);\n            expect(mutableBuffer[5], 6);\n            expect(mutableBuffer[6], 7);\n            expect(mutableBuffer[7], 8);\n            // Mutate the buffer to ensure the changes are detected in Rust code\n            mutableBuffer[0] = 0;\n            mutableBuffer[1] = 0;\n            mutableBuffer[2] = 0;\n            mutableBuffer[3] = 0;\n            const result = (yield zaplib.callRust(\"array_multiply_u8\", [\n                JSON.stringify(10),\n                mutableBuffer,\n            ]))[0];\n            expect(result.length, 8);\n            expect(result[0], 0);\n            expect(result[1], 0);\n            expect(result[2], 0);\n            expect(result[3], 0);\n            expect(result[4], 50);\n            expect(result[5], 60);\n            expect(result[6], 70);\n            expect(result[7], 80);\n            return Promise.all([\n                expectDeallocationOrUnregister(mutableBuffer),\n                expectDeallocationOrUnregister(result),\n            ]);\n        }), \"Call Rust with Float32Array\": () => __awaiter(void 0, void 0, void 0, function* () {\n            // Using a normal array\n            const input = new Float32Array([0.1, 0.9, 0.3]);\n            const result = (yield zaplib.callRust(\"array_multiply_f32\", [\n                JSON.stringify(10),\n                input,\n            ]))[0];\n            expect(result.length, 3);\n            expect(result[0], 1);\n            expect(result[1], 9);\n            expect(result[2], 3);\n            // Using a ZapArray\n            const input2 = yield zaplib.createMutableBuffer(new Float32Array([0.1, 0.9, 0.3]));\n            const result2 = (yield zaplib.callRust(\"array_multiply_f32\", [\n                JSON.stringify(10),\n                input2,\n            ]))[0];\n            expect(result2.length, 3);\n            expect(result2[0], 1);\n            expect(result2[1], 9);\n            expect(result2[2], 3);\n            // Using a readonly ZapArray\n            const input3 = yield zaplib.createReadOnlyBuffer(new Float32Array([0.1, 0.9, 0.3]));\n            const result3 = (yield zaplib.callRust(\"array_multiply_f32_readonly\", [\n                JSON.stringify(10),\n                input3,\n            ]))[0];\n            expect(result3.length, 3);\n            expect(result3[0], 1);\n            expect(result3[1], 9);\n            expect(result3[2], 3);\n            return Promise.all([\n                expectDeallocationOrUnregister(result),\n                expectDeallocationOrUnregister(input2),\n                expectDeallocationOrUnregister(result2),\n                expectDeallocationOrUnregister(input3),\n                expectDeallocationOrUnregister(result3),\n            ]);\n        }), \"Cast WrBuffers\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const input = yield zaplib.createMutableBuffer(new Float32Array([0.1]));\n            const castArray = new Uint8Array(input.buffer);\n            expect(castArray.length, 4);\n            expect(castArray[0], 205);\n            expect(castArray[1], 204);\n            expect(castArray[2], 204);\n            expect(castArray[3], 61);\n            yield expectThrowAsync(() => zaplib.callRust(\"verify_cast_array\", [castArray]), \"Cannot call Rust with a buffer which has been cast to a different type. Expected F32Buffer but got U8Buffer\");\n            const input2 = yield zaplib.createReadOnlyBuffer(new Float32Array([0.1]));\n            const castArray2 = new Uint8Array(input2.buffer);\n            expect(castArray2.length, 4);\n            expect(castArray2[0], 205);\n            expect(castArray2[1], 204);\n            expect(castArray2[2], 204);\n            expect(castArray2[3], 61);\n            yield expectThrowAsync(() => zaplib.callRust(\"verify_cast_array\", [castArray2]), \"Cannot call Rust with a buffer which has been cast to a different type. Expected ReadOnlyF32Buffer but got ReadOnlyU8Buffer\");\n        }), \"On the main thread inWorker returns false\": () => {\n            expect(inWorker, false);\n        } }, runtimeSpecificTests), zapBufferTests);\n    const checkWasmOffline = () => __awaiter(void 0, void 0, void 0, function* () {\n        const funcs = [\n            () => zaplib.callRust(\"call_rust_no_return\"),\n            () => zaplib.createMutableBuffer(new Uint8Array()),\n            () => zaplib.createReadOnlyBuffer(new Uint8Array()),\n        ];\n        for (const f of funcs) {\n            yield expectThrowAsync(f, \"Zaplib WebAssembly instance crashed\");\n        }\n        yield rpc.send(\"runTest\", \"testErrorAfterPanic\");\n    });\n    const otherTests = zaplib.jsRuntime === \"wasm\"\n        ? {\n            \"Disable RPC after panic\": () => __awaiter(void 0, void 0, void 0, function* () {\n                yield expectThrowAsync(() => __awaiter(void 0, void 0, void 0, function* () {\n                    yield zaplib.callRust(\"panic\");\n                }), \n                // TODO(Paras): An exact line number here is kind of annoying. Later we can have some sort of partial matcher.\n                \"panicked at 'I am panicking!', zaplib/web/test_suite/src/main.rs:109:17\");\n                yield checkWasmOffline();\n            }),\n            \"Throw error from event handling to user provided callback\": () => __awaiter(void 0, void 0, void 0, function* () {\n                yield zaplib.callRust(\"panic_signal\");\n                // TODO(Paras): Since event handling happens in a setTimeout, we have\n                // to do this check some time after `callRust`. For now, use a 10ms delay.\n                setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n                    expect(onRenderingPanicCalled, true);\n                    yield checkWasmOffline();\n                }), 10);\n            }),\n            \"Throw error from draw to user provided callback\": () => __awaiter(void 0, void 0, void 0, function* () {\n                yield zaplib.callRust(\"panic_draw\");\n                // TODO(Paras): Since event handling happens in a setTimeout, we have\n                // to do this check some time after `callRust`. For now, use a 10ms delay.\n                setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n                    expect(onRenderingPanicCalled, true);\n                    yield checkWasmOffline();\n                }), 10);\n            }),\n        }\n        : {};\n    const makeButtons = () => {\n        const jsRoot = assertNotNull(document.getElementById(\"root\"));\n        window.runAllTests3x = () => __awaiter(void 0, void 0, void 0, function* () {\n            setInTest(true);\n            for (let i = 0; i < 3; i++) {\n                for (const [testName, test] of Object.entries(tests)) {\n                    console.log(`Running test: ${testName}`);\n                    yield test();\n                    console.log(` Success`);\n                    const button = document.getElementById(testName);\n                    if (button) {\n                        button.innerText += \"\";\n                    }\n                }\n            }\n            console.log(` All tests completed (3x to ensure no memory corruption!)`);\n            setInTest(false);\n        });\n        const runAllButton = document.createElement(\"button\");\n        runAllButton.innerText = \"Run All Tests 3x\";\n        runAllButton.onclick = window.runAllTests3x;\n        const buttonDiv = document.createElement(\"div\");\n        buttonDiv.append(runAllButton);\n        jsRoot.append(buttonDiv);\n        for (const [name, test] of Object.entries(tests)) {\n            const button = document.createElement(\"button\");\n            button.innerText = name;\n            button.id = name;\n            button.onclick = () => __awaiter(void 0, void 0, void 0, function* () {\n                setInTest(true);\n                console.log(`Running test: ${name}`);\n                yield test();\n                console.log(` Success`);\n                button.innerText += \"\";\n                setInTest(false);\n            });\n            const buttonDiv = document.createElement(\"div\");\n            buttonDiv.append(button);\n            jsRoot.append(buttonDiv);\n        }\n        const otherTestsRoot = assertNotNull(document.getElementById(\"other-tests\"));\n        for (const [name, test] of Object.entries(otherTests)) {\n            const button = document.createElement(\"button\");\n            button.innerText = name;\n            button.onclick = () => __awaiter(void 0, void 0, void 0, function* () {\n                setInTest(true);\n                console.log(`Running test: ${name}`);\n                yield test();\n                console.log(` Success`);\n                button.innerText += \"\";\n                setInTest(false);\n            });\n            const buttonDiv = document.createElement(\"div\");\n            buttonDiv.append(button);\n            otherTestsRoot.append(buttonDiv);\n        }\n    };\n    if (document.readyState !== \"loading\") {\n        makeButtons();\n    }\n    else {\n        document.addEventListener(\"DOMContentLoaded\", makeButtons);\n    }\n}));\n","\nimport worker from \"!!../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";var e;!function(e){e[e.String=0]=\\\"String\\\",e[e.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",e[e.U8Buffer=2]=\\\"U8Buffer\\\",e[e.F32Buffer=3]=\\\"F32Buffer\\\",e[e.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\"}(e||(e={})),self;const r=\\\"function\\\"==typeof importScripts;const t=(e,r)=>{if(r!==e)throw new Error(`Failure: Got ${e}, Expected ${r}`);console.debug(`Success: Got ${e}, Expected ${r}`)},n=(e,r)=>{let n;try{e()}catch(e){n=e}t(!!n,!0),n&&r&&t(n.message,r)};class a extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function s(e){return class r extends e{constructor(...r){const t=r[0];if(\\\"object\\\"==typeof t&&t instanceof a){if(r.length<2&&(r[1]=t.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((t.__zaplibBufferData.bufferPtr+t.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<t.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>t.__zaplibBufferData.bufferPtr+t.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=t.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=t}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const o={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,r]of Object.entries(o))e in self&&(self[r]=s(self[e]));function i(e){if(\\\"object\\\"!=typeof e||null===e)return!1;if(Object.prototype.hasOwnProperty.call(e,\\\"__zaplibBuffer\\\"))return!0;if(Array.isArray(e)||e instanceof Set||e instanceof Map){for(const r of e)if(i(r))return!0}else if(Object.getPrototypeOf(e)===Object.getPrototypeOf({}))for(const r of Object.entries(e))if(i(r))return!0;return!1}function f(e){const r=e.postMessage;e.postMessage=function(...e){if(i(e[0]))throw new Error(\\\"Sending ZapBuffers to/from workers is not supported - use .slice() on typed array instead to make an explicit copy\\\");r.apply(this,e)}}const u=new WeakMap;function l(e){return\\\"object\\\"==typeof e&&e instanceof a}function c(r){if(!l(r.buffer))throw new Error(\\\"zapArray.buffer is not a ZapBuffer in checkValidZapArray\\\");const t=r.buffer;if(r.byteOffset!==t.__zaplibBufferData.bufferPtr||r.byteLength!==t.__zaplibBufferData.bufferLen)throw new Error(\\\"Called Rust with a buffer that does not span the entire underlying ZapBuffer\\\");const n=A(r,t.readonly);if(n!==t.__zaplibBufferData.paramType)throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${e[t.__zaplibBufferData.paramType]} but got ${e[n]}`)}const h={},y=new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete h[e],r&&r(e)})),d=new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)})),p=(e,r,t,n)=>{var s;if(r.readonly){if(null===(s=h[r.arcPtr])||void 0===s?void 0:s.deref())t(r.arcPtr);else{const n=new a(e.buffer,r);y.register(n,{arcPtr:r.arcPtr,destructor:t}),h[r.arcPtr]=new WeakRef(n)}return h[r.arcPtr].deref()}{const t=new a(e.buffer,r);return d.register(t,{bufferData:r,destructor:n},t),t}},b=e=>{if(e.readonly)throw new Error(\\\"`unregisterMutableBuffer` should only be called on mutable ZapBuffers\\\");d.unregister(e)};class _{constructor({buffer:e,byteOffset:r,slots:t,growCallback:n}){this._buffer=e,this._byteOffset=r,this._slots=t,this._growCallback=n,this._used=2,this._updateRefs()}_updateRefs(){this._f32=new Float32Array(this._buffer,this._byteOffset,this._slots),this._u32=new Uint32Array(this._buffer,this._byteOffset,this._slots),this._f64=new Float64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64=new BigUint64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64[0]=BigInt(this._slots)*BigInt(4)}_fit(e){if(this._used+e>this._slots){let r=Math.max(this._used+e,2*this._slots);1&r&&r++;const t=4*r,{buffer:n,byteOffset:a}=this._growCallback(this._buffer,this._byteOffset,t);this._buffer=n,this._byteOffset=a,this._slots=r,this._updateRefs()}const r=this._used;return this._used+=e,r}sendF32(e){const r=this._fit(1);this._f32[r]=e}sendU32(e){const r=this._fit(1);this._u32[r]=e}sendF64(e){if(1&this._used){const r=this._fit(3)+1;this._f64[r>>1]=e}else{const r=this._fit(2);this._f64[r>>1]=e}}sendU64(e){if(1&this._used){const r=this._fit(3)+1;this._u64[r>>1]=e}else{const r=this._fit(2);this._u64[r>>1]=e}}sendString(e){let r=this._fit(e.length+1);this._u32[r++]=e.length;for(let t=0;t<e.length;t++)this._u32[r++]=e.charCodeAt(t)}getData(){return{buffer:this._buffer,byteOffset:this._byteOffset}}}class g{constructor(e,r){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,r),this._u32=new Uint32Array(this._memory.buffer,r),this._f64=new Float64Array(this._memory.buffer,r),this._u64=new BigUint64Array(this._memory.buffer,r)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e=\\\"\\\";const r=this.parseU32();for(let t=0;t<r;t++){const r=this.parseU32();0!=r&&(e+=String.fromCharCode(r))}return e}parseU8Slice(){const e=this.parseU32(),r=e>>2,t=new Uint8Array(e),n=3&e;for(let e=0;e<r;e++){const r=e<<2,n=this.parseU32();t[r+0]=255&n,t[r+1]=n>>8&255,t[r+2]=n>>16&255,t[r+3]=n>>24&255}const a=r<<2;if(1==n){const e=this.parseU32();t[a+0]=255&e}else if(2==n){const e=this.parseU32();t[a+0]=255&e,t[a+1]=e>>8&255}else if(3==n){const e=this.parseU32();t[a+0]=255&e,t[a+1]=e>>8&255,t[a+2]=e>>16&255}return t}parseZapParams(){const r=this.parseU32(),t=[];for(let n=0;n<r;++n){const r=this.parseU32();if(r===e.String)t.push(this.parseString());else if(r===e.ReadOnlyU8Buffer||r===e.ReadOnlyF32Buffer){const e=this.parseU32(),n=this.parseU32(),a=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,arcPtr:a,readonly:!0})}else{if(r!==e.U8Buffer&&r!==e.F32Buffer)throw new Error(`Unknown ZapParam type: ${r}`);{const e=this.parseU32(),n=this.parseU32(),a=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,bufferCap:a,readonly:!1})}}}return t}}const w=\\\"$$RESPONSE\\\",m=\\\"$$ERROR\\\";class E{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===w)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:w,id:r},[]);const t=e[E.transferrables];delete e[E.transferrables];const n={topic:w,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:w,id:r,data:{[m]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,a={topic:e,id:n,data:r},s=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[m]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(a,t),s}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}E.transferrables=\\\"$$TRANSFERRABLES\\\";const v=(e,r,t)=>{new e.constructor(r,t,e.length).set(e)},A=(r,t)=>{if(r instanceof Uint8Array)return t?e.ReadOnlyU8Buffer:e.U8Buffer;if(r instanceof Float32Array)return t?e.ReadOnlyF32Buffer:e.F32Buffer;throw new Error(\\\"Invalid array type\\\")},B=(e,r,t)=>{const n=Number(r.allocWasmVec(BigInt(t.byteLength)));return v(t,e.buffer,n),n};class W extends Error{constructor(e){super(e),this.name=\\\"RustPanic\\\"}}var k,S,U,R,C;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\",e.Panic=\\\"WorkerEvent.Panic\\\"}(k||(k={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(S||(S={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(U||(U={})),(C=R||(R={})).Init=\\\"MainWorkerChannelEvent.Init\\\",C.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",C.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",C.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\";let T,O,F,I,M,P=!1;const{checkWasm:D,wrapWasmExports:L}=(e=>{const r=()=>{if(1!==Atomics.load(M,0))throw new Error(\\\"Zaplib WebAssembly instance crashed\\\")};return{checkWasm:r,wrapWasmExports:e=>new Proxy(e,{get:function(e,t){return r(),e[t]}})}})(),z=e=>{if(P)throw new Error(\\\"Only call zaplib.initializeWorker once\\\");if(P=!0,!r)throw new Error(\\\"zaplib.initializeWorker() can only be called in a WebWorker\\\");return function(){for(const[e,r]of Object.entries(o))e in self&&(self[e]=self[r]);f(self),self.Worker&&f(self.Worker),self.MessagePort&&f(self.MessagePort)}(),new Promise((r=>{T=new E(e),T.send(R.Init).then((({wasmModule:e,memory:t,taskWorkerSab:n,baseUri:a,appPtr:s,tlsAndStackData:o,wasmOnline:i})=>{M=i,F=t,I=s;const f=(({getExports:e,memory:r,taskWorkerSab:t,fileHandles:n,sendEventFromAnyThread:a,threadSpawn:s,baseUri:o})=>{const i=(e,t)=>{let n=\\\"\\\";const a=new Uint32Array(r.buffer,e,t);for(let e=0;e<t;e++)n+=String.fromCharCode(a[e]);return n};return{memory:r,_consoleLog:(e,r)=>{const t=i(parseInt(e),parseInt(r));console.log(t)},_throwError:(e,r)=>{throw new W(i(parseInt(e),parseInt(r)))},readUserFileRange:(e,t,a,s)=>{const o=n[e],i=Number(s),f=i+Number(a);o.lastReadStart<=i&&i<o.lastReadEnd&&console.warn(`Read start (${i}) fell in the range of the last read (${o.lastReadStart}-${o.lastReadEnd}); this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.`),o.lastReadStart=i,o.lastReadEnd=f;const u=(new FileReaderSync).readAsArrayBuffer(o.file.slice(i,f));return v(new Uint8Array(u),r.buffer,Number(t)),BigInt(u.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{s(e)},_sendEventFromAnyThread:e=>{a(e)},readUrlSync:(t,n,a,s)=>{const f=i(t,n),u=new XMLHttpRequest;if(u.responseType=\\\"arraybuffer\\\",u.open(\\\"GET\\\",new URL(f,o).href,!1),u.send(null),200===u.status){const t=e(),n=B(r,t,new Uint8Array(u.response));return new Uint32Array(r.buffer,a,1)[0]=n,new Uint32Array(r.buffer,s,1)[0]=u.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,r)=>{const t=new Int32Array(e);((e,r)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(t);const n=t[1];new Uint32Array(e)[n+2]=r,t[1]=n+1,((e,r)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,0,1)})(t),Atomics.notify(t,1)})(t,parseInt(e))}}})({getExports:function(){return O},memory:t,taskWorkerSab:n,fileHandles:[],sendEventFromAnyThread:e=>{T.send(R.SendEventFromAnyThread,e)},threadSpawn:()=>{throw new Error(\\\"Not yet implemented\\\")},baseUri:a});WebAssembly.instantiate(e,{env:f}).then((e=>{((e,r)=>{e.__stack_pointer.value=Number(r.ptr)+r.size-8,e.__wasm_init_tls(Number(r.ptr))})(e.exports,o),O=L(e.exports),r()}))}))}))},N=e=>{O.decrementArc(BigInt(e))},x=({bufferPtr:e,bufferLen:r,bufferCap:t})=>{O.deallocVec(BigInt(e),BigInt(r),BigInt(t))},Z=r=>function(r,t,n,a){return a.map((a=>{if(\\\"string\\\"==typeof a)return a;{const s=p(r,a,t,n);if(a.paramType===e.String)throw new Error(\\\"ZapParam buffer type called with string paramType\\\");const o={[e.U8Buffer]:Uint8Array,[e.ReadOnlyU8Buffer]:Uint8Array,[e.F32Buffer]:Float32Array,[e.ReadOnlyF32Buffer]:Float32Array}[a.paramType];return function(e,r){var t;return(null===(t=u.get(e))||void 0===t?void 0:t.BYTES_PER_ELEMENT)!==r.BYTES_PER_ELEMENT&&u.set(e,r),u.get(e)}(s,new o(s,a.bufferPtr,a.bufferLen/o.BYTES_PER_ELEMENT))}}))}(F,N,x,r),$=(e,r=[])=>{return t=void 0,n=void 0,s=function*(){D();const t=r.map((e=>\\\"string\\\"==typeof e?e:l(e.buffer)?(c(e),G(e)):(e.buffer instanceof SharedArrayBuffer||console.warn(\\\"Consider passing Uint8Arrays backed by ZapBuffer or SharedArrayBuffer into `callRust` to prevent copying data\\\"),e)));return Z(yield T.send(R.CallRust,{name:e,params:t}))},new((a=void 0)||(a=Promise))((function(e,r){function o(e){try{f(s.next(e))}catch(e){r(e)}}function i(e){try{f(s.throw(e))}catch(e){r(e)}}function f(r){var t;r.done?e(r.value):(t=r.value,t instanceof a?t:new a((function(e){e(t)}))).then(o,i)}f((s=s.apply(t,n||[])).next())}));var t,n,a,s},J=(r,t=[])=>{D();const n=((e,r)=>{const t=Number(r.allocWasmMessage(BigInt(4096)));return new _({buffer:e.buffer,byteOffset:t,slots:1024,growCallback:(t,n,a)=>{const s=Number(r.reallocWasmMessage(BigInt(n),BigInt(a)));return{buffer:e.buffer,byteOffset:s}}})})(F,O);n.sendString(r),n.sendU32(t.length);for(const r of t)if(\\\"string\\\"==typeof r)n.sendU32(e.String),n.sendString(r);else if(r.buffer instanceof a)if(c(r),r.buffer.__zaplibBufferData.readonly){n.sendU32(A(r,!0));const e=r.buffer.__zaplibBufferData.arcPtr;O.incrementArc(BigInt(e)),n.sendU32(e)}else b(r.buffer),n.sendU32(A(r,!1)),n.sendU32(r.buffer.__zaplibBufferData.bufferPtr),n.sendU32(r.buffer.__zaplibBufferData.bufferLen),n.sendU32(r.buffer.__zaplibBufferData.bufferCap);else{console.warn(\\\"Consider passing Uint8Arrays backed by ZapBuffer to prevent copying data\\\");const e=r.byteLength,t=B(F,O,r);n.sendU32(A(r,!1)),n.sendU32(t),n.sendU32(e),n.sendU32(e)}const s=O.callRustInSameThreadSync(I,BigInt(n.getData().byteOffset)),o=new g(F,Number(s)).parseZapParams();return Z(o)},j=e=>{D();const r=e.byteLength,t=B(F,O,e);return Z([{paramType:A(e,!1),bufferPtr:t,bufferLen:r,bufferCap:r,readonly:!1}])[0]},V=e=>{D();const r=B(F,O,e),t=A(e,!0),n=Number(O.createArcVec(BigInt(r),BigInt(e.length),BigInt(t)));return Z([{paramType:t,bufferPtr:r,bufferLen:e.byteLength,arcPtr:n,readonly:!0}])[0]},G=e=>{if(\\\"object\\\"!=typeof e||!l(e.buffer))throw new Error(\\\"Only pass Zap arrays to serializeZapArrayForPostMessage\\\");const r=e.buffer;return r.__zaplibBufferData.readonly?O.incrementArc(BigInt(r.__zaplibBufferData.arcPtr)):b(r),{bufferData:r.__zaplibBufferData,byteOffset:e.byteOffset,byteLength:e.byteLength}};var Y=function(e,r,t,n){return new(t||(t=Promise))((function(a,s){function o(e){try{f(n.next(e))}catch(e){s(e)}}function i(e){try{f(n.throw(e))}catch(e){s(e)}}function f(e){var r;e.done?a(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(o,i)}f((n=n.apply(e,r||[])).next())}))};const K=new E(self),H={testCallRustFromWorker:function(){return Y(this,void 0,void 0,(function*(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const r=new Uint8Array(e,2,4),[n]=yield $(\\\"array_multiply_u8\\\",[JSON.stringify(10),r]);t(n.length,4),t(n[0],30),t(n[1],40),t(n[2],50),t(n[3],60)}))},testCallRustNoReturnFromWorker:function(){return Y(this,void 0,void 0,(function*(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const r=new Uint8Array(e,2,4),n=yield $(\\\"call_rust_no_return\\\",[JSON.stringify(10),r]);t(n.length,0)}))},testCallRustInSameThreadSyncWithSignal:function(){const e=J(\\\"send_signal\\\");t(e.length,0)},testCallRustFloat32ArrayFromWorker:()=>Y(void 0,void 0,void 0,(function*(){const e=new Float32Array([.1,.9,.3]),r=(yield $(\\\"array_multiply_f32\\\",[JSON.stringify(10),e]))[0];t(r.length,3),t(r[0],1),t(r[1],9),t(r[2],3);const n=j(new Float32Array([.1,.9,.3])),a=(yield $(\\\"array_multiply_f32\\\",[JSON.stringify(10),n]))[0];t(a.length,3),t(a[0],1),t(a[1],9),t(a[2],3);const s=V(new Float32Array([.1,.9,.3])),o=(yield $(\\\"array_multiply_f32_readonly\\\",[JSON.stringify(10),s]))[0];t(o.length,3),t(o[0],1),t(o[1],9),t(o[2],3)})),testCallRustInSameThreadSyncFloat32ArrayFromWorker:()=>Y(void 0,void 0,void 0,(function*(){const e=new Float32Array([.1,.9,.3]),r=J(\\\"array_multiply_f32\\\",[JSON.stringify(10),e])[0];t(r.length,3),t(r[0],1),t(r[1],9),t(r[2],3);const n=j(new Float32Array([.1,.9,.3])),a=J(\\\"array_multiply_f32\\\",[JSON.stringify(10),n])[0];t(a.length,3),t(a[0],1),t(a[1],9),t(a[2],3);const s=V(new Float32Array([.1,.9,.3])),o=J(\\\"array_multiply_f32_readonly\\\",[JSON.stringify(10),s])[0];t(o.length,3),t(o[0],1),t(o[1],9),t(o[2],3)})),testInWorker:()=>{t(r,!0)},testErrorAfterPanic:()=>Y(void 0,void 0,void 0,(function*(){const e=[()=>J(\\\"call_rust_no_return\\\"),()=>j(new Uint8Array),()=>V(new Uint8Array)];for(const r of e)n(r,\\\"Zaplib WebAssembly instance crashed\\\");var r,a,s,o,i,f;yield(r=()=>$(\\\"call_rust_no_return\\\"),a=\\\"Zaplib WebAssembly instance crashed\\\",s=void 0,o=void 0,i=void 0,f=function*(){let e;try{yield r()}catch(r){e=r}t(!!e,!0),e&&t(e.message,a)},new(i||(i=Promise))((function(e,r){function t(e){try{a(f.next(e))}catch(e){r(e)}}function n(e){try{a(f.throw(e))}catch(e){r(e)}}function a(r){var a;r.done?e(r.value):(a=r.value,a instanceof i?a:new i((function(e){e(a)}))).then(t,n)}a((f=f.apply(s,o||[])).next())})))}))};K.receive(\\\"initWasm\\\",(e=>z(e))),K.receive(\\\"runTest\\\",(e=>Y(void 0,void 0,void 0,(function*(){return H[e]()})))),K.receive(\\\"sendWorker\\\",(function(e){const r=(e=>{const r=p(F,e.bufferData,N,x);return new Uint8Array(r,e.byteOffset,e.byteLength)})(e);console.log(\\\"got data\\\",r)})),K.receive(\\\"testSendZapArrayToMainThread\\\",(function(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const r=new Uint8Array(e,2,4),t=J(\\\"array_multiply_u8\\\",[JSON.stringify(10),r])[0];return{array:G(t),subarray:G(t.subarray(1,3))}})),K.receive(\\\"testCallRustInSameThreadSyncWithZapbuffer\\\",(function(){const e=j(new Uint8Array([1,2,3,4,5,6,7,8])),[r]=J(\\\"array_multiply_u8\\\",[JSON.stringify(10),e]);if(\\\"string\\\"==typeof r)throw new Error(\\\"didn't expect result2 to be a string\\\");return G(r)}))})();\\n\", \"Worker\", undefined, undefined);\n}\n"],"names":["root","factory","exports","module","define","amd","self","___CSS_LOADER_EXPORT___","push","id","cssWithMappingToString","list","toString","this","map","item","content","needLayer","concat","length","join","i","modules","media","dedupe","supports","layer","undefined","alreadyImportedModules","k","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","data","sourceMapping","sourceURLs","sources","source","sourceRoot","stylesInDOM","getIndexByIdentifier","identifier","result","modulesToDom","options","idCountMap","identifiers","base","count","indexByIdentifier","obj","css","sourceMap","references","updater","addElementStyle","byIndex","splice","api","domAPI","update","newObj","remove","lastIdentifiers","newList","index","newLastIdentifiers","_i","_index","memo","insert","style","target","styleTarget","document","querySelector","window","HTMLIFrameElement","contentDocument","head","e","getTarget","Error","appendChild","element","createElement","setAttributes","attributes","styleElement","nonce","setAttribute","insertStyleElement","styleTagTransform","apply","parentNode","removeChild","removeStyleElement","styleSheet","cssText","firstChild","createTextNode","RESPONSE","ERROR","Rpc","constructor","channel","_messageId","_pendingCallbacks","_receivers","Map","_onChannelMessage","ev","topic","Promise","resolve","handler","get","then","postMessage","transferrables","message","catch","err","name","stack","_channel","onmessage","send","transfer","reject","info","error","receive","has","set","console","initTaskWorkerSab","taskWorkerSab","SharedArrayBuffer","taskWorkerSabi32","Int32Array","copyArrayToRustBuffer","inputBuffer","outputBuffer","outputPtr","getZapParamType","array","readonly","Uint8Array","Float32Array","transformParamsFromRustImpl","memory","destructor","mutableDestructor","params","param","zapBuffer","paramType","ArrayConstructor","bufferPtr","bufferLen","BYTES_PER_ELEMENT","assertNotNull","value","objectName","createErrorCheckers","wasmInitialized","checkWasm","wrapWasmExports","Proxy","prop","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","done","expect","actual","expected","debug","expectThrow","f","expectedMessage","expectThrowAsync","sleep","ms","setTimeout","checkConditionTimeout","condition","timeout","startTime","performance","now","generateGarbage","expectDeallocationOrUnregister","callRust","zapArray","buffer","__zaplibBufferData","arcPtr","BigInt","countBeforeDeallocation","arcAllocated","arcDeallocated","inTest","setInTest","v","jsRuntime","inWorker","importScripts","ZapParamType","ZapBuffer","bufferData","super","__zaplibWasmBuffer","byteLength","slice","args","zapBufferExtends","cls","ZapTypedArray","Math","floor","__zaplibBuffer","subarray","begin","end","byteOffset","classesToExtend","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint16ClampedArray","Uint32Array","Float64Array","BigInt64Array","BigUint64Array","DataView","zapCls","Object","entries","containsZapBuffer","object","prototype","hasOwnProperty","call","Array","isArray","Set","entry","getPrototypeOf","patchPostMessage","origPostMessage","overwriteTypedArraysWithZapArrays","Worker","MessagePort","zapBufferCache","WeakMap","getCachedZapBuffer","fallbackArray","_a","isZapBuffer","potentialZapBuffer","checkValidZapArray","bufferCache","allocatedArcs","allocatedVecs","bufferRegistry","FinalizationRegistry","mutableZapBufferRegistry","getZapBufferWasm","wasmMemory","deref","register","WeakRef","unregisterMutableBuffer","unregister","getZapBufferCef","bufferCap","Worker_fn","makeRpcMouseEvent","event","pageX","pageY","button","shiftKey","ctrlKey","metaKey","altKey","makeRpcTouchEvent","changedTouches","from","touch","makeRpcKeyboardEvent","keyCode","repeat","WorkerEvent","TaskWorkerEvent","AsyncWorkerEvent","MainWorkerChannelEvent","makeTextarea","callback","ta","textAreaPos","fixFocus","activeElement","getElementById","contains","focus","addEventListener","updateTextAreaPos","left","round","x","top","y","wasPaste","lastLen","uglyIMEHack","recreateTextarea","body","className","height","width","preventDefault","input","substring","type","TextInput","replaceLast","textValue","code","TextCopy","readOnly","KeyDown","KeyUp","showTextIME","textareaHasFocus","WebGLRenderer","canvas","sizingData","incompatibleBrowserCallback","uniformFnTable","float","loc","off","slot","gl","uniform1f","basef32","vec2","uniform2f","vec3","uniform3f","vec4","uniform4f","mat2","uniformMatrix2fv","mat3","uniformMatrix3fv","mat4","uniformMatrix4fv","sendFnTable","_self","parseShvarvec","len","zerdeParser","parseU32","vars","ty","parseString","ash","shaderId","fragment","vertex","geometrySlots","instanceSlots","passUniforms","viewUniforms","drawUniforms","userUniforms","textureSlots","compileWebGLShader","arrayBufferId","pointer","allocArrayBuffer","indexBufferId","allocIndexBuffer","vaoId","geomIbId","geomVbId","instVbId","allocVao","uniformsPassPtr","uniformsViewPtr","uniformsDrawPtr","uniformsUserPtr","textures","drawCall","textureId","dataPtr","allocTexture","passId","beginRenderTargets","initOnly","r","parseF32","g","b","a","addColorTarget","depth","setDepthTarget","endRenderTargets","setDefaultDepthAndBlendMode","beginMainCanvas","shaders","indexBuffers","arrayBuffers","vaos","framebuffers","targetWidth","targetHeight","clearFlags","clearR","clearG","clearB","clearA","clearDepth","preferLowPowerToHighPerformance","getContext","OESVertexArrayObject","getExtension","ANGLEInstancedArrays","resize","processMessages","zerdeParserPtr","baseu32","msgType","dpiFactor","getAttribLocations","program","slots","attribLocs","attribs","size","getAttribLocation","offset","stride","getUniformLocations","uniforms","uniformLocs","uniform","uniformSizeTable","getUniformLocation","fn","vsh","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","log","getShaderInfoLog","addLineNumbersToString","fsh","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","geomAttribs","instAttribs","buf","glBuf","createBuffer","bindBuffer","ARRAY_BUFFER","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","oldVao","deleteVertexArrayOES","glVao","createVertexArrayOES","vao","bindVertexArrayOES","shader","attr","vertexAttribPointer","FLOAT","enableVertexAttribArray","vertexAttribDivisorANGLE","passUniformsPtr","viewUniformsPtr","drawUniformsPtr","userUniformsPtr","texturesPtr","useProgram","indexBuffer","instanceBuffer","uni","texSlot","texId","texObj","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","uniform1i","indices","instances","drawElementsInstancedANGLE","TRIANGLES","UNSIGNED_INT","glTex","createTexture","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","RGBA","UNSIGNED_BYTE","glFramebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","mpWidth","mpHeight","COLOR_BUFFER_BIT","framebufferTexture2D","COLOR_ATTACHMENT0","glRenderBuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","DEPTH_BUFFER_BIT","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","DEPTH_ATTACHMENT","viewport","clearColor","clear","enable","DEPTH_TEST","depthFunc","LEQUAL","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","ONE_MINUS_SRC_ALPHA","BLEND","lines","split","out","addDefaultStyles","innerHTML","jsFunctions","registerCallJsCallbacks","fns","key","keys","assign","unregisterCallJsCallbacks","fnNames","wasmOnline","Atomics","store","load","_rpc","rpc","newWorkerPort","MessageChannel","BindMainWorkerPort","port1","port2","DecrementArc","DeallocVec","transformParamsFromRust","temporarilyHeldBuffersForPostMessage","serializeZapArrayForPostMessage","add","IncrementArc","delete","transformedParams","warn","CallRust","createMutableBuffer","CreateBuffer","createReadOnlyBuffer","CreateReadOnlyBuffer","deserializeZapArrayFromPostMessage","postMessageData","callRustInSameThreadSync","_params","alreadyCalledInitialize","initialize","initParams","baseUri","location","protocol","host","wasmModulePromise","wasmModule","wasmPath","URL","href","WebAssembly","compileStreaming","fetch","fileHandles","loader","defaultStyles","loadingIndicator","addLoadingIndicator","Init","Memory","initial","maximum","shared","_","ShowIncompatibleBrowserNotification","span","color","RemoveLoadingIndicators","loaders","getElementsByClassName","removeLoadingIndicator","SetDocumentTitle","title","SetMouseCursor","cursor","Fullscreen","requestFullscreen","webkitRequestFullscreen","mozRequestFullscreen","Normalscreen","exitFullscreen","webkitExitFullscreen","mozExitFullscreen","TextCopyResponse","textCopyResponse","navigator","clipboard","writeText","EnableGlobalFileDropTarget","dataTransfer","types","stopPropagation","dropEffect","DragEnter","DragOver","clientX","clientY","DragLeave","files","fileHandlesToSend","file","fileHandle","basename","lastReadStart","lastReadEnd","Drop","CallJs","fnName","canvasData","getSizingData","canFullscreen","isFullscreen","onScreenResize","renderingMethod","Element","CanvasMouseDown","WindowMouseUp","scrollTop","scrollLeft","WindowMouseMove","WindowMouseOut","WindowTouchStart","passive","WindowTouchMove","touchEndCancelLeave","WindowTouchEndCancelLeave","CanvasWheel","timeStamp","deltaMode","deltaX","deltaY","wheelDeltaY","makeRpcWheelEvent","WindowFocus","WindowBlur","isMobileSafari","platform","match","isAndroid","userAgent","taEvent","ShowTextIME","fullscreenEnabled","webkitFullscreenEnabled","mozFullscreenEnabled","fullscreenElement","webkitFullscreenElement","mozFullscreenElement","offsetWidth","offsetHeight","devicePixelRatio","webglRenderer","ScreenResize","mqString","mq","matchMedia","setInterval","transferControlToOffscreen","RunWebGL","requestAnimationFrame","initializeCanvas","Panic","onRenderingPanic","asyncWorkers","threadSpawn","ctxPtr","tlsAndStackData","worker","workerErrorHandler","onerror","onmessageerror","workerRpc","ThreadSpawn","Run","mainWorkerPort","finally","terminate","offscreenCanvas","OffscreenCanvas","readyState","cursorMap","packKeyModifier","zerdeKeyboardHandlers","keyDown","zerdeBuilder","sendU32","sendF64","keyUp","textInput","sendString","textCopy","newCallbackId","pendingCallbacks","transformParamsForRust","cefBuffer","cefCreateArrayBuffer","callbackId","promise","_reject","cefCallRust","fromCefJsFunctions","_zaplibReturnParams","parse","cefReadyForMessages","forEach","transformReturnParams","returnParams","ParamTypeToArrayConstructor","cefCallRustInSameThreadSync","_postMessageData","fromCefSetMouseCursor","cursorId","fromCefCallJsFunction","growCallback","cefHandleKeyboardEvent","fromCefSetIMEPosition","cefTriggerCopy","cefTriggerCut","cefTriggerSelectAll","cefTriggerPaste","ZerdeBuilder","_buffer","_byteOffset","_slots","_growCallback","_used","_updateRefs","_f32","_u32","_f64","_u64","_fit","newSlots","max","newBytes","pos","sendF32","sendU64","str","charCodeAt","getData","ZerdeParser","zerdePtr","_memory","_usedSlots","parseF64","ret","parseU64","c","String","fromCharCode","parseU8Slice","u8Len","spare","u8Pos","u32","parseZapParams","workerConstructor","workerOptions","url","globalScope","blob","Blob","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","append","getBlob","webkitURL","objectURL","createObjectURL","revokeObjectURL","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","definition","o","defineProperty","enumerable","Symbol","toStringTag","ZapUint8Array","ZapUint16Array","zapBufferTests","testBuffer","testShare","testOutOfBounds","testZapNameMatches","expectedName","testArrayBuffer","ArrayBuffer","testSubarray","regularArray","testContainsZapBuffer","runWorkerTest","testName","env","searchParams","onRenderingPanicCalled","zapWorkerPort","div","innerText","sendWorker","toSend","runtimeSpecificTests","uint8Part","input2","result2","input3","result3","tests","all","mutableBuffer","castArray","castArray2","checkWasmOffline","funcs","otherTests","makeButtons","jsRoot","runAllTests3x","test","runAllButton","onclick","buttonDiv","otherTestsRoot"],"sourceRoot":""}