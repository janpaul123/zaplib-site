{"version":3,"file":"test_suite.js","mappings":"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","sources":["webpack://zaplib/webpack/universalModuleDefinition","webpack://zaplib/./zaplib.css","webpack://zaplib/./node_modules/css-loader/dist/runtime/api.js","webpack://zaplib/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack://zaplib/./common.ts","webpack://zaplib/./test_helpers.ts","webpack://zaplib/./type_of_runtime.ts","webpack://zaplib/./types.ts","webpack://zaplib/./zap_buffer.ts","webpack://zaplib/./main_worker.ts","webpack://zaplib/./async_worker.ts","webpack://zaplib/./task_worker.ts","webpack://zaplib/./make_rpc_event.ts","webpack://zaplib/./rpc_types.ts","webpack://zaplib/./make_textarea.ts","webpack://zaplib/./webgl_renderer.ts","webpack://zaplib/./default_styles.ts","webpack://zaplib/./wasm_runtime.ts","webpack://zaplib/./loading_indicator.ts","webpack://zaplib/./cursor_map.ts","webpack://zaplib/./zerde_keyboard_handlers.ts","webpack://zaplib/./cef_runtime.ts","webpack://zaplib/./zaplib.css?4485","webpack://zaplib/./zaplib_runtime.ts","webpack://zaplib/./zerde.ts","webpack://zaplib/./node_modules/worker-loader/dist/runtime/inline.js","webpack://zaplib/webpack/bootstrap","webpack://zaplib/webpack/runtime/compat get default export","webpack://zaplib/webpack/runtime/define property getters","webpack://zaplib/webpack/runtime/hasOwnProperty shorthand","webpack://zaplib/webpack/runtime/make namespace object","webpack://zaplib/./zap_buffer.test.ts","webpack://zaplib/./test_suite.ts","webpack://zaplib/./test_suite_worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"zaplib\"] = factory();\n\telse\n\t\troot[\"zaplib\"] = factory();\n})(self, function() {\nreturn ","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"./node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"./node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".zaplib_canvas {\\n    position: absolute; /* For z-index */\\n    top: 0;\\n    left: 0;\\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\\n    z-index: 2147483647;\\n    width: 100%;\\n    height: 100%;\\n    pointer-events: none;\\n    user-select: none;\\n    touch-action: pan-x pan-y; /* Mobile Safari doesn't support \\\"none\\\" */\\n}\\n\\ntextarea.zaplib_textarea {\\n    z-index: 1000;\\n    position: absolute;\\n    opacity: 0;\\n    border-radius: 4px;\\n    color:white;\\n    font-size: 6;\\n    background: gray;\\n    -moz-appearance: none;\\n    appearance:none;\\n    border:none;\\n    resize: none;\\n    outline: none;\\n    overflow: hidden;\\n    text-indent: 0px;\\n    padding: 0 0px;\\n    margin: 0 -1px;\\n    text-indent: 0px;\\n    -ms-user-select: text;\\n    -moz-user-select: text;\\n    -webkit-user-select: text;\\n    user-select: text;\\n    white-space: pre!important;\\n}\\ntextarea:focus.zaplib_textarea {\\n    outline: 0px !important;\\n    -webkit-appearance: none;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./zaplib.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,kBAAkB,EAAE,gBAAgB;IACpC,MAAM;IACN,OAAO;IACP,uHAAuH;IACvH,mBAAmB;IACnB,WAAW;IACX,YAAY;IACZ,oBAAoB;IACpB,iBAAiB;IACjB,yBAAyB,EAAE,yCAAyC;AACxE;;AAEA;IACI,aAAa;IACb,kBAAkB;IAClB,UAAU;IACV,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,gBAAgB;IAChB,qBAAqB;IACrB,eAAe;IACf,WAAW;IACX,YAAY;IACZ,aAAa;IACb,gBAAgB;IAChB,gBAAgB;IAChB,cAAc;IACd,cAAc;IACd,gBAAgB;IAChB,qBAAqB;IACrB,sBAAsB;IACtB,yBAAyB;IACzB,iBAAiB;IACjB,0BAA0B;AAC9B;AACA;IACI,uBAAuB;IACvB,wBAAwB;AAC5B\",\"sourcesContent\":[\".zaplib_canvas {\\n    position: absolute; /* For z-index */\\n    top: 0;\\n    left: 0;\\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\\n    z-index: 2147483647;\\n    width: 100%;\\n    height: 100%;\\n    pointer-events: none;\\n    user-select: none;\\n    touch-action: pan-x pan-y; /* Mobile Safari doesn't support \\\"none\\\" */\\n}\\n\\ntextarea.zaplib_textarea {\\n    z-index: 1000;\\n    position: absolute;\\n    opacity: 0;\\n    border-radius: 4px;\\n    color:white;\\n    font-size: 6;\\n    background: gray;\\n    -moz-appearance: none;\\n    appearance:none;\\n    border:none;\\n    resize: none;\\n    outline: none;\\n    overflow: hidden;\\n    text-indent: 0px;\\n    padding: 0 0px;\\n    margin: 0 -1px;\\n    text-indent: 0px;\\n    -ms-user-select: text;\\n    -moz-user-select: text;\\n    -webkit-user-select: text;\\n    user-select: text;\\n    white-space: pre!important;\\n}\\ntextarea:focus.zaplib_textarea {\\n    outline: 0px !important;\\n    -webkit-appearance: none;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","\"use strict\";\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","\"use strict\";\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;","// This file should only be imported by WebWorkers\n/// <reference lib=\"WebWorker\" />\nimport { ZapParamType, } from \"./types\";\nimport { getCachedZapBuffer, getZapBufferWasm } from \"./zap_buffer\";\nimport { ZerdeBuilder } from \"./zerde\";\nconst RESPONSE = \"$$RESPONSE\";\nconst ERROR = \"$$ERROR\";\n// helper function to create linked channels for testing\nfunction _createLinkedChannels() {\n    const local = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (remote.onmessage) {\n                remote.onmessage(ev);\n            }\n        },\n    };\n    const remote = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (local.onmessage) {\n                local.onmessage(ev);\n            }\n        },\n    };\n    return { local, remote };\n}\n// This class allows you to hook up bi-directional async calls across web-worker\n// boundaries where a single call to or from a worker can 'wait' on the response.\n// Errors in receivers are propigated back to the caller as a rejection.\n// It also supports returning transferrables over the web-worker postMessage api,\n// which was the main shortcomming with the worker-rpc npm module.\n// To attach rpc to an instance of a worker in the main thread:\n//   const rpc = new Rpc(workerInstace);\n// To attach rpc within an a web worker:\n//   const rpc = new Rpc(global);\n// Check out the tests for more examples.\n// See `rpc_types.ts` for descriptions of how to set up typed interactions.\nexport class Rpc {\n    constructor(channel) {\n        this._messageId = 0;\n        this._pendingCallbacks = {};\n        this._receivers = new Map();\n        this._onChannelMessage = (ev) => {\n            const { id, topic, data } = ev.data;\n            if (topic === RESPONSE) {\n                this._pendingCallbacks[id](ev.data);\n                delete this._pendingCallbacks[id];\n                return;\n            }\n            // invoke the receive handler in a promise so if it throws synchronously we can reject\n            new Promise((resolve) => {\n                const handler = this._receivers.get(topic);\n                if (!handler) {\n                    throw new Error(`no receiver registered for ${topic}`);\n                }\n                // This works both when `handler` returns a value or a Promise.\n                resolve(handler(data));\n            })\n                .then((result) => {\n                if (!result) {\n                    this.postMessage({ topic: RESPONSE, id }, []);\n                    return;\n                }\n                const transferrables = result[Rpc.transferrables];\n                delete result[Rpc.transferrables];\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: result,\n                };\n                this.postMessage(message, transferrables);\n            })\n                .catch((err) => {\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: {\n                        [ERROR]: true,\n                        name: err.name,\n                        message: err.message,\n                        stack: err.stack,\n                    },\n                };\n                this.postMessage(message, []);\n            });\n        };\n        this._channel = channel;\n        if (this._channel.onmessage) {\n            throw new Error(\"channel.onmessage is already set. Can only use one Rpc instance per channel.\");\n        }\n        this._channel.onmessage = this._onChannelMessage;\n    }\n    // send a message across the rpc boundary to a receiver on the other side\n    // this returns a promise for the receiver's response.  If there is no registered\n    // receiver for the given topic, this method throws\n    send(topic, data, transfer) {\n        const id = this._messageId++;\n        const message = { topic, id, data };\n        const result = new Promise((resolve, reject) => {\n            this._pendingCallbacks[id] = (info) => {\n                if (info.data && info.data[ERROR]) {\n                    const error = new Error(info.data.message);\n                    error.name = info.data.name;\n                    error.stack = info.data.stack;\n                    reject(error);\n                }\n                else {\n                    resolve(info.data);\n                }\n            };\n        });\n        this.postMessage(message, transfer);\n        return result;\n    }\n    // register a receiver for a given message on a topic\n    // only one receiver can be registered per topic and currently\n    // 'deregistering' a receiver is not supported since this is not common\n    receive(topic, handler) {\n        if (this._receivers.has(topic)) {\n            throw new Error(`Receiver already registered for topic: ${topic}`);\n        }\n        this._receivers.set(topic, handler);\n    }\n    postMessage(message, transfer) {\n        try {\n            this._channel.postMessage(message, transfer);\n        }\n        catch (e) {\n            console.error(\"Rpc postMessage call itself failed: \", e);\n        }\n    }\n}\nRpc.transferrables = \"$$TRANSFERRABLES\";\n////////////////////////////////////////////////////////////////\n// Mutex\n////////////////////////////////////////////////////////////////\nconst MUTEX_UNLOCKED = 0;\nconst MUTEX_LOCKED = 1;\nexport const mutexLock = (sabi32, offset) => {\n    // This needs to be in a loop, because between the `wait` and `compareExchange` another thread might\n    // take the Mutex.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (Atomics.compareExchange(sabi32, offset, MUTEX_UNLOCKED, MUTEX_LOCKED) ==\n            MUTEX_UNLOCKED) {\n            return;\n        }\n        Atomics.wait(sabi32, offset, MUTEX_LOCKED);\n    }\n};\nexport const mutexUnlock = (sabi32, offset) => {\n    if (Atomics.compareExchange(sabi32, offset, MUTEX_LOCKED, MUTEX_UNLOCKED) !=\n        MUTEX_LOCKED) {\n        throw new Error(\"Called mutex_unlock on an already unlocked mutex\");\n    }\n    Atomics.notify(sabi32, offset, 1);\n};\n////////////////////////////////////////////////////////////////\n// Task worker\n////////////////////////////////////////////////////////////////\nexport const TW_SAB_MUTEX_PTR = 0;\nexport const TW_SAB_MESSAGE_COUNT_PTR = 1;\n// Initialize a SharedArrayBuffer used to communicate with task_worker.ts. This\n// is a one-way communication channel; use pointers into `memory` for communicating\n// information back.\n//\n// We use this because we typically can't use `postMessage`; see task_worker.ts\n// for more details.\n//\n// Format:\n// * i32 (4 bytes)         - read/write mutex\n// * i32 (4 bytes)         - number of messages in queue (notify on this to wake up the task worker - it will\n//                           read this before taking a mutex, but then reread it after taking the mutex)\n// * n * u32 (n * 4 bytes) - pointers to messages serialized with `ZerdeBuilder`\nexport const initTaskWorkerSab = () => {\n    const bufferSizeBytes = 10000;\n    const taskWorkerSab = new SharedArrayBuffer(bufferSizeBytes);\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    taskWorkerSabi32[TW_SAB_MUTEX_PTR] = MUTEX_UNLOCKED;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = 0;\n    return taskWorkerSab;\n};\n// Append a new message pointer to the SharedArrayBuffer used by task_worker.ts,\n// and wake it up so it can process this new message (unless it's currently in polling\n// mode, in that case the `Atomics.notify` will just not do anything).\nconst sendTaskWorkerMessage = (taskWorkerSab, twMessagePtr) => {\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    mutexLock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    const currentNumberOfMessages = taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR];\n    // Use unsigned numbers for the actual pointer, since they can be >2GB.\n    new Uint32Array(taskWorkerSab)[currentNumberOfMessages + 2] = twMessagePtr;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = currentNumberOfMessages + 1;\n    mutexUnlock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    Atomics.notify(taskWorkerSabi32, 1);\n};\n////////////////////////////////////////////////////////////////\n// Wasm Thread initialization\n////////////////////////////////////////////////////////////////\n// Threads in WebAssembly! They are.. fun! Here's what happens.\n//\n// The first Wasm instance we start is in the main worker. It does the following:\n// - It initializes static memory using `__wasm_init_memory`, which is automatically set\n//   by LLVM as the special \"start\" function.\n// - It already has memory allocated for the \"shadow stack\". This is like any stack in a\n//   native program, but in WebAssembly it's called the \"shadow stack\" because WebAssembly\n//   itself also has a notion of a stack built-in. It is however not suitable for all\n//   kinds of data, which is why we need another separate stack.\n// - We allocate Thread Local Storage (TLS) by allocating some memory on the heap (an\n//   operation which by itself should not require TLS; otherwise we'd have a Catch-22\n//   situation..), and calling `initThreadLocalStorageMainWorker` with it.\n//\n// Then, when we make any other WebAssembly threads (e.g. in our own WebWorkers, or in\n// the WebWorkers of users), we do the following:\n// - `__wasm_init_memory` is again called automatically, but will be skipped, since an\n//   (atomic) flag has been set not to initialize static memory again.\n// - We need to initialize memory for both the shadow stack and the Thread Local\n//   Storage (TLS), using `makeThreadLocalStorageAndStackDataOnExistingThread`. We do this\n//   by allocating memory on the heap on an already initialized thread, since allocating memory DOES\n//   require the shadow stack to be initialized.\n// - We then use this memory for both the TLS (on the lower side) and the shadow stack\n//   (on the upper side, since it moves downward), using `initThreadLocalStorageAndStackOtherWorkers`.\n//\n// TODO(JP): This currently leaks memory since we never deallocate the TLS/shadow stack!\n//\n// TODO(JP): Even if we do deallocate the memory, there is currently no way to call TLS\n// destructors; so we'd still leak memory. See https://github.com/rust-lang/rust/issues/77839\n// The \"shadow stack\" size for new threads. Note that the main thread will\n// keep using its own shadow stack size.\nconst WASM_STACK_SIZE_BYTES = 2 * 1024 * 1024; // 2 MB\n// For the main worker, we only need to initialize Thread Local Storage (TLS).\nexport const initThreadLocalStorageMainWorker = (wasmExports) => {\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(wasmExports.__tls_size.value));\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    wasmExports.__wasm_init_tls(Number(ptr));\n};\n// For non-main workers, we need to allocate enough data for Thread Local Storage (TLS)\n// and the \"shadow stack\". We allocate this data in the main worker, and then send the\n// pointer + size to other workers.\n//\n// This is easier than trying to allocate the appropriate amount of data in the other\n// itself, which is possible (e.g. using memory.grow) but kind of cumbersome.\nexport const makeThreadLocalStorageAndStackDataOnExistingThread = (wasmExports) => {\n    // Align size to 64 bits / 8 bytes.\n    const size = Math.ceil((wasmExports.__tls_size.value + WASM_STACK_SIZE_BYTES) / 8) * 8;\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(size));\n    return { ptr, size };\n};\n// Set the shadow stack pointer and initialize thet Thread Local Storage (TLS).\n//\n// Note that the TLS sits on the lower side of the memory, wheras the shadow stack\n// starts on the upper side of the memory and grows downwards.\n//\n// TODO(JP): __wasm_init_tls takes a Number, which might not work when it is >2GB.\nexport const initThreadLocalStorageAndStackOtherWorkers = (wasmExports, tlsAndStackData) => {\n    // Start the shadow stack pointer on the upper side of the memory, though subtract\n    // 8 so we don't overwrite the byte right after the memory, while still keeping it\n    // 64-bit aligned. TODO(JP): Is the 64-bit alignment necessary for the shadow stack?\n    wasmExports.__stack_pointer.value =\n        Number(tlsAndStackData.ptr) + tlsAndStackData.size - 8;\n    wasmExports.__wasm_init_tls(\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    Number(tlsAndStackData.ptr));\n};\n////////////////////////////////////////////////////////////////\n// Common wasm functions\n////////////////////////////////////////////////////////////////\nexport const copyArrayToRustBuffer = (inputBuffer, outputBuffer, outputPtr) => {\n    // should be the same type as inputBuffer\n    // @ts-ignore: constructor is getting typed as Function instead of a constructor\n    new inputBuffer.constructor(outputBuffer, outputPtr, inputBuffer.length).set(inputBuffer);\n};\nexport const getZapParamType = (array, readonly) => {\n    if (array instanceof Uint8Array) {\n        return readonly ? ZapParamType.ReadOnlyU8Buffer : ZapParamType.U8Buffer;\n    }\n    else if (array instanceof Float32Array) {\n        return readonly ? ZapParamType.ReadOnlyF32Buffer : ZapParamType.F32Buffer;\n    }\n    else {\n        throw new Error(\"Invalid array type\");\n    }\n};\nexport const createWasmBuffer = (memory, exports, data) => {\n    const vecPtr = Number(exports.allocWasmVec(BigInt(data.byteLength)));\n    copyArrayToRustBuffer(data, memory.buffer, vecPtr);\n    return vecPtr;\n};\nexport const makeZerdeBuilder = (memory, wasmExports) => {\n    const slots = 1024;\n    // We have get memory.buffer *after* calling `allocWasmMessage`, because\n    // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n    const byteOffset = Number(wasmExports.allocWasmMessage(BigInt(slots * 4)));\n    return new ZerdeBuilder({\n        buffer: memory.buffer,\n        byteOffset: byteOffset,\n        slots,\n        growCallback: (_buffer, oldByteOffset, newBytes) => {\n            const newByteOffset = Number(wasmExports.reallocWasmMessage(BigInt(oldByteOffset), BigInt(newBytes)));\n            // We have get memory.buffer *after* calling `reallocWasmMessage`, because\n            // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n            return { buffer: memory.buffer, byteOffset: newByteOffset };\n        },\n    });\n};\nexport const getWasmEnv = ({ getExports, memory, taskWorkerSab, fileHandles, sendEventFromAnyThread, threadSpawn, baseUri, }) => {\n    const fileReaderSync = new FileReaderSync();\n    const parseString = (ptr, len) => {\n        let out = \"\";\n        // Can't use TextDecoder here since it doesn't work with SharedArrayBuffer.\n        // TODO(JP): If it becomes important enough, we can see if making a copy to a regular\n        // ArrayBuffer and then using TextDecoder is faster than what we do here.\n        const array = new Uint32Array(memory.buffer, ptr, len);\n        for (let i = 0; i < len; i++) {\n            out += String.fromCharCode(array[i]);\n        }\n        return out;\n    };\n    return {\n        memory,\n        _consoleLog: (charsPtr, len, error) => {\n            const out = parseString(parseInt(charsPtr), parseInt(len));\n            if (error) {\n                console.error(out);\n            }\n            else {\n                console.log(out);\n            }\n        },\n        readUserFileRange: (userFileId, bufPtr, bufLen, fileOffset) => {\n            const file = fileHandles[userFileId];\n            const start = Number(fileOffset);\n            const end = start + Number(bufLen);\n            if (file.lastReadStart <= start && start < file.lastReadEnd) {\n                console.warn(`Read start (${start}) fell in the range of the last read (${file.lastReadStart}-${file.lastReadEnd}); ` +\n                    \"this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.\");\n            }\n            file.lastReadStart = start;\n            file.lastReadEnd = end;\n            // TODO(JP): This creates a new buffer instead of reading directly into the wasm memory.\n            // Maybe we can avoid this by using a stream with a ReadableStreamBYOBReader, but that is\n            // asynchronous, so we'd have to do a dance with another thread and atomics and all that,\n            // and I don't know if that overhead would be worth it..\n            const buffer = fileReaderSync.readAsArrayBuffer(file.file.slice(start, end));\n            copyArrayToRustBuffer(new Uint8Array(buffer), memory.buffer, Number(bufPtr));\n            return BigInt(buffer.byteLength);\n        },\n        performanceNow: () => {\n            return performance.now();\n        },\n        threadSpawn: (ctxPtr) => {\n            threadSpawn(ctxPtr);\n        },\n        _sendEventFromAnyThread: (eventPtr) => {\n            sendEventFromAnyThread(eventPtr);\n        },\n        readUrlSync: (urlPtr, urlLen, bufPtrOut, bufLenOut) => {\n            const url = parseString(urlPtr, urlLen);\n            const request = new XMLHttpRequest();\n            request.responseType = \"arraybuffer\";\n            request.open(\"GET\", new URL(url, baseUri).href, false /* synchronous */);\n            request.send(null);\n            if (request.status === 200) {\n                const exports = getExports();\n                const outputBufPtr = createWasmBuffer(memory, exports, new Uint8Array(request.response));\n                new Uint32Array(memory.buffer, bufPtrOut, 1)[0] = outputBufPtr;\n                new Uint32Array(memory.buffer, bufLenOut, 1)[0] =\n                    request.response.byteLength;\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        },\n        randomU64: () => new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],\n        sendTaskWorkerMessage: (twMessagePtr) => {\n            sendTaskWorkerMessage(taskWorkerSab, parseInt(twMessagePtr));\n        },\n    };\n};\nexport function transformParamsFromRustImpl(memory, destructor, mutableDestructor, params) {\n    return params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else {\n            const zapBuffer = getZapBufferWasm(memory, param, destructor, mutableDestructor);\n            if (param.paramType === ZapParamType.String) {\n                throw new Error(\"ZapParam buffer type called with string paramType\");\n            }\n            // These are actually ZapArray types, since we overwrite TypedArrays in overwriteTypedArraysWithZapArrays()\n            const ArrayConstructor = {\n                [ZapParamType.U8Buffer]: Uint8Array,\n                [ZapParamType.ReadOnlyU8Buffer]: Uint8Array,\n                [ZapParamType.F32Buffer]: Float32Array,\n                [ZapParamType.ReadOnlyF32Buffer]: Float32Array,\n            }[param.paramType];\n            return getCachedZapBuffer(zapBuffer, new ArrayConstructor(zapBuffer, param.bufferPtr, param.bufferLen / ArrayConstructor.BYTES_PER_ELEMENT));\n        }\n    });\n}\nexport function assertNotNull(value, objectName = \"Value\") {\n    if (value === null || value === undefined) {\n        throw new Error(`Assertion failed: ${objectName} is null`);\n    }\n    return value;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { jsRuntime } from \"./type_of_runtime\";\nimport { allocatedArcs, allocatedVecs } from \"./zap_buffer\";\nexport const expect = (actual, expected) => {\n    if (expected === actual) {\n        console.debug(`Success: Got ${actual}, Expected ${expected}`);\n    }\n    else {\n        throw new Error(`Failure: Got ${actual}, Expected ${expected}`);\n    }\n};\n// TODO(Paras): Would be nice to combine the two functions below at some point.\nexport const expectThrow = (f, expectedMessage) => {\n    let error;\n    try {\n        f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n};\nexport const expectThrowAsync = (f, expectedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n    let error;\n    try {\n        yield f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n});\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst checkConditionTimeout = (condition, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n    const startTime = performance.now();\n    while (!condition() && performance.now() < startTime + timeout) {\n        yield sleep(10);\n    }\n    return condition();\n});\n// Generate some dummy data and then delete it. This usually triggers the garbage collector.\nconst generateGarbage = () => {\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        self[\"garbage_\" + i] = { i };\n    }\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        delete self[\"garbage_\" + i];\n    }\n};\nconst arcAllocated = (callRust, buffer) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!buffer.__zaplibBufferData.readonly)\n        throw new Error(\"arcAllocated called on mutable buffer\");\n    const arcPtr = buffer.__zaplibBufferData.arcPtr;\n    // We still have the buffer here! So it should still be allocated.\n    expect(allocatedArcs[arcPtr], true);\n    const [result] = yield callRust(\"check_arc_count\", [`${BigInt(arcPtr)}`]);\n    const [countBeforeDeallocation] = result;\n    expect(countBeforeDeallocation, 1);\n    return arcPtr;\n});\nconst arcDeallocated = (arcPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // From here on out we don't refer to `buffer` anymore, so it should get\n    // deallocated, if the garbage collector is any good.\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return allocatedArcs[arcPtr] === false;\n    }, 20000), true);\n});\nconst vecDeallocated = (bufferPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // Even though we have the buffer, it might have already been unregistered\n    // when passed to Rust. We shouldn't read/write to it anymore. If this is the\n    // case, let's just bail.\n    if (!allocatedVecs[bufferPtr])\n        return;\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return allocatedVecs[bufferPtr] === false;\n    }, 20000), true);\n});\n// Test that ZapBuffers were deallocated at some point in the next 20 seconds.\n// This is a bit brittle given that there are no guarantees for garbage collection during this time,\n// but observationally this ends up being enough time. The caller must also ensure that the buffer will go out of scope\n// shortly after calling this.\n// We have to pass in `callRust` because we can call this function from a variety of runtimes.\n// Note that assertions on garbage collection are extremely sensitive to exactly how these functions are written,\n// and can easily break if you restucture the function, use a different/newer browser, etc!\nexport const expectDeallocationOrUnregister = (callRust, zapArray) => {\n    // Deallocation code is only run in WASM for now.\n    if (jsRuntime === \"cef\")\n        return Promise.resolve();\n    const buffer = zapArray.buffer;\n    return buffer.readonly\n        ? arcAllocated(callRust, buffer).then((arcPtr) => arcDeallocated(arcPtr))\n        : vecDeallocated(buffer.__zaplibBufferData.bufferPtr);\n};\nexport let inTest = false;\n// Set this to true to enable testing code\nexport const setInTest = (v) => {\n    inTest = v;\n};\n","// We only define `cefCallRust` if in CEF, so we can use this for environment detection.\n// This should only be used at the top level `zaplib_runtime` file or in test, since we want to keep\n// CEF and WASM code separate for bundle size.\nexport const jsRuntime = \"cefCallRust\" in self ? \"cef\" : \"wasm\";\n// Whether or not we're in a WebWorker.\n// From https://stackoverflow.com/a/23619712\nexport const inWorker = typeof importScripts === \"function\";\n","// Keep in sync with `param.rs`\nexport var ZapParamType;\n(function (ZapParamType) {\n    ZapParamType[ZapParamType[\"String\"] = 0] = \"String\";\n    ZapParamType[ZapParamType[\"ReadOnlyU8Buffer\"] = 1] = \"ReadOnlyU8Buffer\";\n    ZapParamType[ZapParamType[\"U8Buffer\"] = 2] = \"U8Buffer\";\n    ZapParamType[ZapParamType[\"F32Buffer\"] = 3] = \"F32Buffer\";\n    ZapParamType[ZapParamType[\"ReadOnlyF32Buffer\"] = 4] = \"ReadOnlyF32Buffer\";\n})(ZapParamType || (ZapParamType = {}));\n","// Wrapper around SharedArrayBuffer to encapsulate ownership of particular segments of it\nimport { getZapParamType } from \"./common\";\nimport { ZapParamType } from \"./types\";\nimport { inTest } from \"./test_helpers\";\n// TODO(Paras) - Make sure we monkeypatch on web workers as well\nexport class ZapBuffer extends SharedArrayBuffer {\n    constructor(buffer, bufferData) {\n        super(0);\n        this.__zaplibWasmBuffer = buffer;\n        this.__zaplibBufferData = bufferData;\n    }\n    // TODO(Paras): Actually enforce this flag and prevent mutation of ZapArrays marked as readonly.\n    // Potentially, we can do this by hashing read only buffer data and periodically checking in debug\n    // builds if they have been modified/raising errors.\n    get readonly() {\n        return this.__zaplibBufferData.readonly;\n    }\n    // The only 2 methods on SharedArrayBuffer class to override:\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#instance_properties\n    get byteLength() {\n        return this.__zaplibWasmBuffer.byteLength;\n    }\n    slice(...args) {\n        return this.__zaplibWasmBuffer.slice(...args);\n    }\n}\n// This class is a drop-in replacement for all typed arrays\n// It uses ZapBuffer as a handle for underlying buffer as the object that keeps underlying data around\n// Requirements:\n//  * The underlying typed array behaves like it was created over the original view\n//  * When the new typed array (potentially with different class name) is created from the buffer of the original one,\n//  they share the same handle\n//\n// The Rust side assumes that underlying data buffer is immutable,\n// however it still could be accidentally modified on JS side leading to weird behavior\n// TODO(Dmitry): Throw an error if there is mutation of the data\nfunction zapBufferExtends(cls) {\n    return class ZapTypedArray extends cls {\n        constructor(...args) {\n            const buffer = args[0];\n            if (typeof buffer === \"object\" && buffer instanceof ZapBuffer) {\n                // Fill in byteOffset if that's omitted.\n                if (args.length < 2) {\n                    args[1] = buffer.__zaplibBufferData.bufferPtr;\n                }\n                // Fill in length (in elements, not in bytes) if that's omitted.\n                if (args.length < 3) {\n                    args[2] = Math.floor((buffer.__zaplibBufferData.bufferPtr +\n                        buffer.__zaplibBufferData.bufferLen -\n                        args[1]) /\n                        cls.BYTES_PER_ELEMENT);\n                }\n                if (args[1] < buffer.__zaplibBufferData.bufferPtr) {\n                    throw new Error(`Byte_offset ${args[1]} is out of bounds`);\n                }\n                if (args[1] + args[2] * cls.BYTES_PER_ELEMENT >\n                    buffer.__zaplibBufferData.bufferPtr +\n                        buffer.__zaplibBufferData.bufferLen) {\n                    throw new Error(`Byte_offset ${args[1]} + length ${args[2]} is out of bounds`);\n                }\n                // Whenever we create ZapUintArray using ZapBuffer as first argument\n                // pass the underlying full wasm_buffer further\n                args[0] = buffer.__zaplibWasmBuffer;\n                super(...args);\n                this.__zaplibBuffer = buffer;\n            }\n            else {\n                super(...args);\n            }\n        }\n        get buffer() {\n            return this.__zaplibBuffer || super.buffer;\n        }\n        subarray(begin = 0, end = this.length) {\n            if (begin < 0) {\n                begin = this.length + begin;\n            }\n            if (end < 0) {\n                end = this.length + end;\n            }\n            if (end < begin) {\n                end = begin;\n            }\n            return new ZapTypedArray(this.buffer, this.byteOffset + begin * this.BYTES_PER_ELEMENT, end - begin);\n        }\n    };\n}\n// Extending all typed arrays\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#indexed_collections\nexport const classesToExtend = {\n    Int8Array: \"ZapInt8Array\",\n    Uint8Array: \"ZapUint8Array\",\n    Uint8ClampedArray: \"ZapUint8ClampedArray\",\n    Int16Array: \"ZapInt16Array\",\n    Uint16Array: \"ZapUint16Array\",\n    Uint16ClampedArray: \"ZapUint16ClampedArray\",\n    Int32Array: \"ZapInt32Array\",\n    Uint32Array: \"ZapUint32Array\",\n    Float32Array: \"ZapFloat32Array\",\n    Float64Array: \"ZapFloat64Array\",\n    BigInt64Array: \"ZapBigInt64Array\",\n    BigUint64Array: \"ZapBigUint64Array\",\n    DataView: \"ZapDataView\",\n};\nfor (const [cls, zapCls] of Object.entries(classesToExtend)) {\n    // Get a new type name by prefixing old one with \"Zaplib\".\n    // e.g. Uint8Array is extended by ZapUint8Array, etc\n    if (cls in self) {\n        // @ts-ignore\n        self[zapCls] = zapBufferExtends(self[cls]);\n    }\n}\n// Checks if the given object itself or recursively contains ZapBuffers.\n// Exported for tests.\nexport function containsZapBuffer(object) {\n    if (typeof object != \"object\" || object === null) {\n        return false;\n    }\n    if (Object.prototype.hasOwnProperty.call(object, \"__zaplibBuffer\")) {\n        return true;\n    }\n    // Only supporting nesting for arrays, plain objects, maps and sets similar to StructuredClone algorithm\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types\n    if (Array.isArray(object) || object instanceof Set || object instanceof Map) {\n        for (const entry of object) {\n            if (containsZapBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    else if (Object.getPrototypeOf(object) === Object.getPrototypeOf({})) {\n        for (const entry of Object.entries(object)) {\n            if (containsZapBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction patchPostMessage(cls) {\n    const origPostMessage = cls.postMessage;\n    // Explicitly NOT a fat arrow (=>) since we want to keep the original `this`.\n    cls.postMessage = function (...args) {\n        if (containsZapBuffer(args[0])) {\n            // TODO(Dmitry): add a better error message showing the exact location of typed arrays\n            throw new Error(\"Sending ZapBuffers to/from workers is not supported - \" +\n                \"use .slice() on typed array instead to make an explicit copy\");\n        }\n        origPostMessage.apply(this, args);\n    };\n}\nexport function overwriteTypedArraysWithZapArrays() {\n    for (const [cls, zapCls] of Object.entries(classesToExtend)) {\n        if (cls in self) {\n            // @ts-ignore\n            self[cls] = self[zapCls];\n        }\n    }\n    patchPostMessage(self);\n    patchPostMessage(self.Worker);\n    patchPostMessage(self.MessagePort);\n}\nconst zapBufferCache = new WeakMap();\nexport function getCachedZapBuffer(zapBuffer, fallbackArray) {\n    var _a;\n    if (!(\n    // Overwrite the cached value if we return a pointer to a buffer of a different type\n    // For example, Rust code may cast a float to an u8 and return the same buffer pointer.\n    (((_a = zapBufferCache.get(zapBuffer)) === null || _a === void 0 ? void 0 : _a.BYTES_PER_ELEMENT) ===\n        fallbackArray.BYTES_PER_ELEMENT))) {\n        zapBufferCache.set(zapBuffer, fallbackArray);\n    }\n    return zapBufferCache.get(zapBuffer);\n}\nexport function isZapBuffer(potentialZapBuffer) {\n    return (typeof potentialZapBuffer === \"object\" &&\n        potentialZapBuffer instanceof ZapBuffer);\n}\nexport function checkValidZapArray(zapArray) {\n    if (!isZapBuffer(zapArray.buffer)) {\n        throw new Error(\"zapArray.buffer is not a ZapBuffer in checkValidZapArray\");\n    }\n    const buffer = zapArray.buffer;\n    const bufferCoversZapBuffer = zapArray.byteOffset === buffer.__zaplibBufferData.bufferPtr &&\n        zapArray.byteLength === buffer.__zaplibBufferData.bufferLen;\n    if (!bufferCoversZapBuffer) {\n        throw new Error(\"Called Rust with a buffer that does not span the entire underlying ZapBuffer\");\n    }\n    const paramType = getZapParamType(zapArray, buffer.readonly);\n    if (paramType !== buffer.__zaplibBufferData.paramType) {\n        throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${ZapParamType[buffer.__zaplibBufferData.paramType]} but got ${ZapParamType[paramType]}`);\n    }\n}\n// Cache ZapBuffers so that we have a stable identity for ZapBuffers pointing to the same\n// Arc. This is useful for any downstream caches in user code.\nconst bufferCache = {};\nexport const allocatedArcs = {};\nexport const allocatedVecs = {};\nconst bufferRegistry = new FinalizationRegistry(({ arcPtr, destructor, }) => {\n    if (inTest) {\n        if (allocatedArcs[arcPtr] === false) {\n            throw new Error(`Deallocating an already deallocated arcPtr ${arcPtr}`);\n        }\n        else if (allocatedArcs[arcPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated arcPtr ${arcPtr}`);\n        }\n        allocatedArcs[arcPtr] = false;\n    }\n    delete bufferCache[arcPtr];\n    if (destructor)\n        destructor(arcPtr);\n});\nconst mutableZapBufferRegistry = new FinalizationRegistry(({ bufferData, destructor, }) => {\n    if (inTest) {\n        const { bufferPtr } = bufferData;\n        if (allocatedVecs[bufferPtr] === false) {\n            throw new Error(`Deallocating an already deallocated bufferPtr ${bufferPtr}`);\n        }\n        else if (allocatedVecs[bufferPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated bufferPtr ${bufferPtr}`);\n        }\n        allocatedVecs[bufferPtr] = false;\n    }\n    destructor(bufferData);\n});\n// Return a buffer with a stable identity based on arcPtr.\n// Register callbacks so we de-allocate the buffer when it goes out of scope.\nexport const getZapBufferWasm = (wasmMemory, bufferData, destructor, mutableDestructor) => {\n    var _a;\n    if (bufferData.readonly) {\n        if (!((_a = bufferCache[bufferData.arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            if (inTest) {\n                allocatedArcs[bufferData.arcPtr] = true;\n            }\n            const zapBuffer = new ZapBuffer(wasmMemory.buffer, bufferData);\n            bufferRegistry.register(zapBuffer, {\n                arcPtr: bufferData.arcPtr,\n                destructor,\n                /* no unregisterToken here since we never need to unregister */\n            });\n            bufferCache[bufferData.arcPtr] = new WeakRef(zapBuffer);\n        }\n        else {\n            // If we already hold a reference, decrement the Arc we were just given;\n            // otherwise we leak memory.\n            destructor(bufferData.arcPtr);\n        }\n        return bufferCache[bufferData.arcPtr].deref();\n    }\n    else {\n        if (inTest) {\n            allocatedVecs[bufferData.bufferPtr] = true;\n        }\n        const zapBuffer = new ZapBuffer(wasmMemory.buffer, bufferData);\n        mutableZapBufferRegistry.register(zapBuffer, {\n            bufferData,\n            destructor: mutableDestructor,\n        }, zapBuffer);\n        return zapBuffer;\n    }\n};\n// Remove mutable ZapBuffers without running destructors. This is useful\n// when transferring ownership of buffers to Rust without deallocating data.\nexport const unregisterMutableBuffer = (zapBuffer) => {\n    if (zapBuffer.readonly) {\n        throw new Error(\"`unregisterMutableBuffer` should only be called on mutable ZapBuffers\");\n    }\n    mutableZapBufferRegistry.unregister(zapBuffer);\n    if (inTest) {\n        allocatedVecs[zapBuffer.__zaplibBufferData.bufferPtr] = false;\n    }\n};\n// Return a buffer with a stable identity based on arcPtr\nexport const getZapBufferCef = (buffer, arcPtr, paramType) => {\n    var _a;\n    if (arcPtr) {\n        if (!((_a = bufferCache[arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            const zapBuffer = new ZapBuffer(buffer, {\n                bufferPtr: 0,\n                bufferLen: buffer.byteLength,\n                readonly: true,\n                paramType,\n                // TODO(Paras): These fields below do not apply to CEF\n                arcPtr: -1,\n            });\n            bufferRegistry.register(zapBuffer, { arcPtr });\n            bufferCache[arcPtr] = new WeakRef(zapBuffer);\n        }\n        return bufferCache[arcPtr].deref();\n    }\n    else {\n        return new ZapBuffer(buffer, {\n            bufferPtr: 0,\n            bufferLen: buffer.byteLength,\n            bufferCap: buffer.byteLength,\n            paramType,\n            readonly: false,\n        });\n    }\n};\n","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";const e=[\\\"none\\\",\\\"default\\\",\\\"crosshair\\\",\\\"pointer\\\",\\\"default\\\",\\\"move\\\",\\\"text\\\",\\\"wait\\\",\\\"help\\\",\\\"not-allowed\\\",\\\"n-resize\\\",\\\"ne-resize\\\",\\\"e-resize\\\",\\\"se-resize\\\",\\\"s-resize\\\",\\\"sw-resize\\\",\\\"w-resize\\\",\\\"nw-resize\\\",\\\"ns-resize\\\",\\\"nesw-resize\\\",\\\"ew-resize\\\",\\\"nwse-resize\\\",\\\"col-resize\\\",\\\"row-resize\\\"];var t,r;(r=t||(t={}))[r.String=0]=\\\"String\\\",r[r.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",r[r.U8Buffer=2]=\\\"U8Buffer\\\",r[r.F32Buffer=3]=\\\"F32Buffer\\\",r[r.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\",self;class s extends SharedArrayBuffer{constructor(e,t){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=t}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class t extends e{constructor(...t){const r=t[0];if(\\\"object\\\"==typeof r&&r instanceof s){if(t.length<2&&(t[1]=r.__zaplibBufferData.bufferPtr),t.length<3&&(t[2]=Math.floor((r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen-t[1])/e.BYTES_PER_ELEMENT)),t[1]<r.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${t[1]} is out of bounds`);if(t[1]+t[2]*e.BYTES_PER_ELEMENT>r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${t[1]} + length ${t[2]} is out of bounds`);t[0]=r.__zaplibWasmBuffer,super(...t),this.__zaplibBuffer=r}else super(...t)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,r=this.length){return e<0&&(e=this.length+e),r<0&&(r=this.length+r),r<e&&(r=e),new t(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,r-e)}}}const i={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,t]of Object.entries(i))e in self&&(self[t]=n(self[e]));new WeakMap;const a={};new FinalizationRegistry((({arcPtr:e,destructor:t})=>{delete a[e],t&&t(e)})),new FinalizationRegistry((({bufferData:e,destructor:t})=>{t(e)}));class o{constructor({buffer:e,byteOffset:t,slots:r,growCallback:s}){this._buffer=e,this._byteOffset=t,this._slots=r,this._growCallback=s,this._used=2,this._updateRefs()}_updateRefs(){this._f32=new Float32Array(this._buffer,this._byteOffset,this._slots),this._u32=new Uint32Array(this._buffer,this._byteOffset,this._slots),this._f64=new Float64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64=new BigUint64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64[0]=BigInt(this._slots)*BigInt(4)}_fit(e){if(this._used+e>this._slots){let t=Math.max(this._used+e,2*this._slots);1&t&&t++;const r=4*t,{buffer:s,byteOffset:n}=this._growCallback(this._buffer,this._byteOffset,r);this._buffer=s,this._byteOffset=n,this._slots=t,this._updateRefs()}const t=this._used;return this._used+=e,t}sendF32(e){const t=this._fit(1);this._f32[t]=e}sendU32(e){const t=this._fit(1);this._u32[t]=e}sendF64(e){if(1&this._used){const t=this._fit(3)+1;this._f64[t>>1]=e}else{const t=this._fit(2);this._f64[t>>1]=e}}sendU64(e){if(1&this._used){const t=this._fit(3)+1;this._u64[t>>1]=e}else{const t=this._fit(2);this._u64[t>>1]=e}}sendString(e){let t=this._fit(e.length+1);this._u32[t++]=e.length;for(let r=0;r<e.length;r++)this._u32[t++]=e.charCodeAt(r)}getData(){return{buffer:this._buffer,byteOffset:this._byteOffset}}}class d{constructor(e,t){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,t),this._u32=new Uint32Array(this._memory.buffer,t),this._f64=new Float64Array(this._memory.buffer,t),this._u64=new BigUint64Array(this._memory.buffer,t)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e=\\\"\\\";const t=this.parseU32();for(let r=0;r<t;r++){const t=this.parseU32();0!=t&&(e+=String.fromCharCode(t))}return e}parseU8Slice(){const e=this.parseU32(),t=e>>2,r=new Uint8Array(e),s=3&e;for(let e=0;e<t;e++){const t=e<<2,s=this.parseU32();r[t+0]=255&s,r[t+1]=s>>8&255,r[t+2]=s>>16&255,r[t+3]=s>>24&255}const n=t<<2;if(1==s){const e=this.parseU32();r[n+0]=255&e}else if(2==s){const e=this.parseU32();r[n+0]=255&e,r[n+1]=e>>8&255}else if(3==s){const e=this.parseU32();r[n+0]=255&e,r[n+1]=e>>8&255,r[n+2]=e>>16&255}return r}parseZapParams(){const e=this.parseU32(),r=[];for(let s=0;s<e;++s){const e=this.parseU32();if(e===t.String)r.push(this.parseString());else if(e===t.ReadOnlyU8Buffer||e===t.ReadOnlyF32Buffer){const t=this.parseU32(),s=this.parseU32(),n=this.parseU32();r.push({paramType:e,bufferPtr:t,bufferLen:s,arcPtr:n,readonly:!0})}else{if(e!==t.U8Buffer&&e!==t.F32Buffer)throw new Error(`Unknown ZapParam type: ${e}`);{const t=this.parseU32(),s=this.parseU32(),n=this.parseU32();r.push({paramType:e,bufferPtr:t,bufferLen:s,bufferCap:n,readonly:!1})}}}return r}}const l=\\\"$$RESPONSE\\\",h=\\\"$$ERROR\\\";class c{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:t,topic:r,data:s}=e.data;if(r===l)return this._pendingCallbacks[t](e.data),void delete this._pendingCallbacks[t];new Promise((e=>{const t=this._receivers.get(r);if(!t)throw new Error(`no receiver registered for ${r}`);e(t(s))})).then((e=>{if(!e)return void this.postMessage({topic:l,id:t},[]);const r=e[c.transferrables];delete e[c.transferrables];const s={topic:l,id:t,data:e};this.postMessage(s,r)})).catch((e=>{const r={topic:l,id:t,data:{[h]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(r,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,t,r){const s=this._messageId++,n={topic:e,id:s,data:t},i=new Promise(((e,t)=>{this._pendingCallbacks[s]=r=>{if(r.data&&r.data[h]){const e=new Error(r.data.message);e.name=r.data.name,e.stack=r.data.stack,t(e)}else e(r.data)}}));return this.postMessage(n,r),i}receive(e,t){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,t)}postMessage(e,t){try{this._channel.postMessage(e,t)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}c.transferrables=\\\"$$TRANSFERRABLES\\\";const u=e=>{const t=8*Math.ceil((e.__tls_size.value+2097152)/8);return{ptr:e.allocWasmMessage(BigInt(t)),size:t}},f=(e,t,r)=>{new e.constructor(t,r,e.length).set(e)},p=(e,r)=>{if(e instanceof Uint8Array)return r?t.ReadOnlyU8Buffer:t.U8Buffer;if(e instanceof Float32Array)return r?t.ReadOnlyF32Buffer:t.F32Buffer;throw new Error(\\\"Invalid array type\\\")},g=(e,t,r)=>{const s=Number(t.allocWasmVec(BigInt(r.byteLength)));return f(r,e.buffer,s),s};function m(e,t=\\\"Value\\\"){if(null==e)throw new Error(`Assertion failed: ${t} is null`);return e}function _(e){return(e.shiftKey?1:0)|(e.ctrlKey?2:0)|(e.altKey?4:0)|(e.metaKey?8:0)}const E={keyDown(e,t){e.sendU32(12),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(_(t.event)),e.sendF64(performance.now()/1e3)},keyUp(e,t){e.sendU32(13),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(_(t.event)),e.sendF64(performance.now()/1e3)},textInput(e,t){e.sendU32(14),e.sendU32(t.wasPaste?1:0),e.sendU32(t.replaceLast?1:0),e.sendString(t.input)},textCopy(e){e.sendU32(17)}};class b{constructor(e){this._wasmApp=e,this._zerdeBuilder=((e,t)=>{const r=Number(t.allocWasmMessage(BigInt(4096)));return new o({buffer:e.buffer,byteOffset:r,slots:1024,growCallback:(r,s,n)=>{const i=Number(t.reallocWasmMessage(BigInt(s),BigInt(n)));return{buffer:e.buffer,byteOffset:i}}})})(e.memory,e.exports),this._zerdeBuilder.sendF64(0)}getWasmApp(){return this._wasmApp}createWasmBuffer(e){return g(this._wasmApp.memory,this._wasmApp.exports,e)}createArcVec(e,t){return Number(this._wasmApp.exports.createArcVec(BigInt(e),BigInt(t.length),BigInt(p(t,!0))))}init(e){this._zerdeBuilder.sendU32(1),this._zerdeBuilder.sendF32(e.width),this._zerdeBuilder.sendF32(e.height),this._zerdeBuilder.sendF32(e.dpiFactor),this._zerdeBuilder.sendU32(e.xrCanPresent?1:0),this._zerdeBuilder.sendU32(e.canFullscreen?1:0)}resize(e){this._zerdeBuilder.sendU32(4),this._zerdeBuilder.sendF32(e.width),this._zerdeBuilder.sendF32(e.height),this._zerdeBuilder.sendF32(e.dpiFactor),this._zerdeBuilder.sendU32(e.xrIsPresenting?1:0),this._zerdeBuilder.sendU32(e.xrCanPresent?1:0),this._zerdeBuilder.sendU32(e.isFullscreen?1:0)}animationFrame(){this._zerdeBuilder.sendU32(5)}pointerDown(e){this._zerdeBuilder.sendU32(6),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.button),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerUp(e){this._zerdeBuilder.sendU32(7),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.button),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerMove(e){this._zerdeBuilder.sendU32(8),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerHover(e){this._zerdeBuilder.sendU32(9),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerScroll(e){this._zerdeBuilder.sendU32(10),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendF32(e.scrollX),this._zerdeBuilder.sendF32(e.scrollY),this._zerdeBuilder.sendU32(e.isWheel?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerOut(e){this._zerdeBuilder.sendU32(11),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}keyDown(e){E.keyDown(this._zerdeBuilder,e)}keyUp(e){E.keyUp(this._zerdeBuilder,e)}textInput(e){E.textInput(this._zerdeBuilder,e)}textCopy(){E.textCopy(this._zerdeBuilder)}timerFired(e){this._zerdeBuilder.sendU32(18),this._zerdeBuilder.sendF64(e)}windowFocus(e){this._zerdeBuilder.sendU32(19),this._zerdeBuilder.sendU32(e?1:0)}xrUpdateHead(e,t){}xrUpdateInputs(e,t,r,s,n){}paintDirty(e,t){this._zerdeBuilder.sendU32(21)}httpSendResponse(e,t){this._zerdeBuilder.sendU32(22),this._zerdeBuilder.sendU32(e),this._zerdeBuilder.sendU32(t)}sendEventFromAnyThread(e){this._zerdeBuilder.sendU32(26),this._zerdeBuilder.sendU64(e)}websocketMessage(e,t){const r=t.byteLength,s=this.createWasmBuffer(new Uint8Array(t));this._zerdeBuilder.sendU32(23),this._zerdeBuilder.sendU32(s),this._zerdeBuilder.sendU32(r),this._zerdeBuilder.sendString(e)}websocketError(e,t){this._zerdeBuilder.sendU32(24),this._zerdeBuilder.sendString(e),this._zerdeBuilder.sendString(t)}appOpenFiles(e){this._zerdeBuilder.sendU32(25),this._zerdeBuilder.sendU32(e.length);for(const t of e)this._zerdeBuilder.sendU32(t.id),this._zerdeBuilder.sendU64(BigInt(t.file.size)),this._zerdeBuilder.sendString(t.basename)}dragenter(){this._zerdeBuilder.sendU32(27)}dragleave(){this._zerdeBuilder.sendU32(28)}dragover(e,t){this._zerdeBuilder.sendU32(29),this._zerdeBuilder.sendU32(e),this._zerdeBuilder.sendU32(t)}callRust(e,r,s){this._zerdeBuilder.sendU32(30),this._zerdeBuilder.sendString(e),this._zerdeBuilder.sendU32(r.length);for(const e of r)if(\\\"string\\\"==typeof e)this._zerdeBuilder.sendU32(t.String),this._zerdeBuilder.sendString(e);else if(\\\"bufferData\\\"in e)this._zerdeBuilder.sendU32(e.bufferData.paramType),e.bufferData.readonly?this._zerdeBuilder.sendU32(e.bufferData.arcPtr):(this._zerdeBuilder.sendU32(e.bufferData.bufferPtr),this._zerdeBuilder.sendU32(e.bufferData.bufferLen),this._zerdeBuilder.sendU32(e.bufferData.bufferCap));else{const t=e.byteLength,r=this.createWasmBuffer(e);this._zerdeBuilder.sendU32(p(e,!1)),this._zerdeBuilder.sendU32(r),this._zerdeBuilder.sendU32(t),this._zerdeBuilder.sendU32(t)}this._zerdeBuilder.sendU32(s)}end(){this._zerdeBuilder.sendU32(0);const{buffer:e,byteOffset:t}=this._zerdeBuilder.getData();return new Float64Array(e,t,2)[1]=performance.now()/1e3,t}}class v{constructor(e,t,r,s){this.uniformFnTable={float:function(e,t,r){const s=r>>2;e.gl.uniform1f(t,e.basef32[s])},vec2:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform2f(t,n[s],n[s+1])},vec3:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform3f(t,n[s],n[s+1],n[s+2])},vec4:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform4f(t,n[s],n[s+1],n[s+2],n[s+3])},mat2:function(e,t,r){e.gl.uniformMatrix2fv(t,!1,new Float32Array(e.memory.buffer,r,4))},mat3:function(e,t,r){e.gl.uniformMatrix3fv(t,!1,new Float32Array(e.memory.buffer,r,9))},mat4:function(e,t,r){const s=new Float32Array(e.memory.buffer,r,16);e.gl.uniformMatrix4fv(t,!1,s)}},this.sendFnTable=[function(e){return!0},function(e){function t(){const t=e.zerdeParser.parseU32(),r=[];for(let s=0;s<t;s++)r.push({ty:e.zerdeParser.parseString(),name:e.zerdeParser.parseString()});return r}const r={shaderId:e.zerdeParser.parseU32(),fragment:e.zerdeParser.parseString(),vertex:e.zerdeParser.parseString(),geometrySlots:e.zerdeParser.parseU32(),instanceSlots:e.zerdeParser.parseU32(),passUniforms:t(),viewUniforms:t(),drawUniforms:t(),userUniforms:t(),textureSlots:t()};e.compileWebGLShader(r)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=new Float32Array(e.memory.buffer,s,r);e.allocArrayBuffer(t,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=new Uint32Array(e.memory.buffer,s,r);e.allocIndexBuffer(t,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),i=e.zerdeParser.parseU32();e.allocVao(t,r,s,n,i)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),i=e.zerdeParser.parseU32(),a=e.zerdeParser.parseU32(),o=e.zerdeParser.parseU32();e.drawCall(t,r,s,n,i,a,o)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32();e.allocTexture(t,r,s,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32();e.beginRenderTargets(t,r,s)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseF32(),n=e.zerdeParser.parseF32(),i=e.zerdeParser.parseF32(),a=e.zerdeParser.parseF32();e.addColorTarget(t,r,s,n,i,a)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseF32();e.setDepthTarget(t,r,s)},function(e){e.endRenderTargets()},function(e){e.setDefaultDepthAndBlendMode()},function(e){const t=e.zerdeParser.parseF32(),r=e.zerdeParser.parseF32(),s=e.zerdeParser.parseF32(),n=e.zerdeParser.parseF32(),i=e.zerdeParser.parseF32();e.beginMainCanvas(t,r,s,n,i)}],this.canvas=e,this.memory=t,this.sizingData=r,this.shaders=[],this.indexBuffers=[],this.arrayBuffers=[],this.vaos=[],this.textures=[],this.framebuffers=[],this.targetWidth=0,this.targetHeight=0,this.clearFlags=0,this.clearR=0,this.clearG=0,this.clearB=0,this.clearA=0,this.clearDepth=0;const n={preferLowPowerToHighPerformance:!0};this.gl=e.getContext(\\\"webgl\\\",n)||e.getContext(\\\"webgl-experimental\\\",n)||e.getContext(\\\"experimental-webgl\\\",n),this.gl?(this.OESVertexArrayObject=m(this.gl.getExtension(\\\"OES_vertex_array_object\\\")),this.ANGLEInstancedArrays=m(this.gl.getExtension(\\\"ANGLE_instanced_arrays\\\")),this.gl.getExtension(\\\"OES_standard_derivatives\\\"),this.gl.getExtension(\\\"OES_element_index_uint\\\"),this.resize(r)):s()}processMessages(e){for(this.zerdeParser=new d(this.memory,e),this.basef32=new Float32Array(this.memory.buffer),this.baseu32=new Uint32Array(this.memory.buffer);;){const e=this.zerdeParser.parseU32();if(this.sendFnTable[e](this))break}}resize(e){this.sizingData=e,this.canvas.width=e.width*e.dpiFactor,this.canvas.height=e.height*e.dpiFactor}getAttribLocations(e,t,r){const s=this.gl,n=[];let i=r>>2;0!=(3&r)&&i++;for(let a=0;a<i;a++){let i=r-4*a;i>4&&(i=4),n.push({loc:s.getAttribLocation(e,t+a),offset:16*a,size:i,stride:4*r})}return n}getUniformLocations(e,t){const r=this.gl,s=[];let n=0;for(let i=0;i<t.length;i++){const a=t[i],o=z[a.ty];0!=(3&n)&&(3&n)+o>4&&(n+=4-(3&n)),s.push({name:a.name,offset:n<<2,ty:a.ty,loc:r.getUniformLocation(e,a.name),fn:this.uniformFnTable[a.ty]}),n+=o}return s}compileWebGLShader(e){const t=this.gl,r=m(t.createShader(t.VERTEX_SHADER));t.shaderSource(r,e.vertex),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(r),U(e.vertex));const s=m(t.createShader(t.FRAGMENT_SHADER));t.shaderSource(s,e.fragment),t.compileShader(s),t.getShaderParameter(s,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(s),U(e.fragment));const n=m(t.createProgram());t.attachShader(n,r),t.attachShader(n,s),t.linkProgram(n),t.getProgramParameter(n,t.LINK_STATUS)||console.log(t.getProgramInfoLog(n),U(e.vertex),U(e.fragment)),this.shaders[e.shaderId]={geomAttribs:this.getAttribLocations(n,\\\"mpsc_packed_geometry_\\\",e.geometrySlots),instAttribs:this.getAttribLocations(n,\\\"mpsc_packed_instance_\\\",e.instanceSlots),passUniforms:this.getUniformLocations(n,e.passUniforms),viewUniforms:this.getUniformLocations(n,e.viewUniforms),drawUniforms:this.getUniformLocations(n,e.drawUniforms),userUniforms:this.getUniformLocations(n,e.userUniforms),textureSlots:this.getUniformLocations(n,e.textureSlots),instanceSlots:e.instanceSlots,program:n,ash:e}}allocArrayBuffer(e,t){const r=this.gl;let s=this.arrayBuffers[e];void 0===s?s=this.arrayBuffers[e]={glBuf:m(r.createBuffer()),length:t.length}:s.length=t.length,r.bindBuffer(r.ARRAY_BUFFER,s.glBuf),r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,null)}allocIndexBuffer(e,t){const r=this.gl;let s=this.indexBuffers[e];void 0===s?s=this.indexBuffers[e]={glBuf:m(r.createBuffer()),length:t.length}:s.length=t.length,r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,s.glBuf),r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null)}allocVao(e,t,r,s,n){const i=this.gl,a=this.vaos[e];a&&this.OESVertexArrayObject.deleteVertexArrayOES(a.glVao);const o=m(this.OESVertexArrayObject.createVertexArrayOES()),d=this.vaos[e]={glVao:o,geomIbId:r,geomVbId:s,instVbId:n};this.OESVertexArrayObject.bindVertexArrayOES(d.glVao),i.bindBuffer(i.ARRAY_BUFFER,this.arrayBuffers[s].glBuf);const l=this.shaders[t];for(let e=0;e<l.geomAttribs.length;e++){const t=l.geomAttribs[e];t.loc<0||(i.vertexAttribPointer(t.loc,t.size,i.FLOAT,!1,t.stride,t.offset),i.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,0))}i.bindBuffer(i.ARRAY_BUFFER,this.arrayBuffers[n].glBuf);for(let e=0;e<l.instAttribs.length;e++){const t=l.instAttribs[e];t.loc<0||(i.vertexAttribPointer(t.loc,t.size,i.FLOAT,!1,t.stride,t.offset),i.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,1))}i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,this.indexBuffers[r].glBuf),this.OESVertexArrayObject.bindVertexArrayOES(null)}drawCall(e,t,r,s,n,i,a){const o=this.gl,d=this.shaders[e];o.useProgram(d.program);const l=this.vaos[t];this.OESVertexArrayObject.bindVertexArrayOES(l.glVao);const h=this.indexBuffers[l.geomIbId],c=this.arrayBuffers[l.instVbId],u=d.passUniforms,f=d.viewUniforms;for(let e=0;e<f.length;e++){const t=f[e];t.fn(this,t.loc,t.offset+s)}const p=d.drawUniforms;for(let e=0;e<p.length;e++){const t=p[e];t.fn(this,t.loc,t.offset+n)}const g=d.userUniforms;for(let e=0;e<g.length;e++){const t=g[e];t.fn(this,t.loc,t.offset+i)}const m=d.textureSlots;for(let e=0;e<m.length;e++){const t=m[e],r=this.baseu32[(a>>2)+e],s=this.textures[r];o.activeTexture(o.TEXTURE0+e),o.bindTexture(o.TEXTURE_2D,s),o.uniform1i(t.loc,e)}const _=h.length,E=c.length/d.instanceSlots;for(let e=0;e<u.length;e++){const t=u[e];t.fn(this,t.loc,t.offset+r)}this.ANGLEInstancedArrays.drawElementsInstancedANGLE(o.TRIANGLES,_,o.UNSIGNED_INT,0,E),this.OESVertexArrayObject.bindVertexArrayOES(null)}allocTexture(e,t,r,s){const n=this.gl,i=this.textures[e]||n.createTexture();n.bindTexture(n.TEXTURE_2D,i),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);const a=new Uint8Array(this.memory.buffer,s,t*r*4);n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t,r,0,n.RGBA,n.UNSIGNED_BYTE,a),this.textures[e]=i}beginRenderTargets(e,t,r){const s=this.gl;this.targetWidth=t,this.targetHeight=r,this.clearFlags=0;const n=this.framebuffers[e]||(this.framebuffers[e]=m(s.createFramebuffer()));s.bindFramebuffer(s.FRAMEBUFFER,n)}addColorTarget(e,t,r,s,n,i){this.clearR=r,this.clearG=s,this.clearB=n,this.clearA=i;const a=this.gl,o=this.textures[e]||(this.textures[e]=a.createTexture());o.mpWidth!=this.targetWidth||o.mpHeight!=this.targetHeight?(a.bindTexture(a.TEXTURE_2D,o),this.clearFlags|=a.COLOR_BUFFER_BIT,o.mpWidth=this.targetWidth,o.mpHeight=this.targetHeight,a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,o.mpWidth,o.mpHeight,0,a.RGBA,a.UNSIGNED_BYTE,null)):t||(this.clearFlags|=a.COLOR_BUFFER_BIT),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,o,0)}setDepthTarget(e,t,r){const s=this.gl;this.clearDepth=r;const n=this.textures[e]||(this.textures[e]=s.createRenderbuffer());n.mpWidth!=this.targetWidth||n.mpHeight!=this.targetHeight?(s.bindRenderbuffer(s.RENDERBUFFER,n),this.clearFlags|=s.DEPTH_BUFFER_BIT,n.mpWidth=this.targetWidth,n.mpHeight=this.targetHeight,s.renderbufferStorage(s.RENDERBUFFER,s.DEPTH_COMPONENT16,this.targetWidth,this.targetHeight)):t||(this.clearFlags|=s.DEPTH_BUFFER_BIT),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.RENDERBUFFER,n)}endRenderTargets(){const e=this.gl;e.viewport(0,0,this.targetWidth,this.targetHeight),this.clearFlags&&(e.clearColor(this.clearR,this.clearG,this.clearB,this.clearA),e.clearDepth(this.clearDepth),e.clear(this.clearFlags))}setDefaultDepthAndBlendMode(){const e=this.gl;e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.blendEquationSeparate(e.FUNC_ADD,e.FUNC_ADD),e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA),e.enable(e.BLEND)}beginMainCanvas(e,t,r,s,n){const i=this.gl;i.bindFramebuffer(i.FRAMEBUFFER,null),i.viewport(0,0,this.sizingData.width*this.sizingData.dpiFactor,this.sizingData.height*this.sizingData.dpiFactor),i.clearColor(e,t,r,s),i.clearDepth(n),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT)}}const z={float:1,vec2:2,vec3:3,vec4:4,mat2:4,mat3:9,mat4:16};function U(e){const t=e.split(\\\"\\\\n\\\");let r=\\\"\\\";for(let e=0;e<t.length;e++)r+=e+1+\\\": \\\"+t[e]+\\\"\\\\n\\\";return r}var B,y,A,w;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\"}(B||(B={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(y||(y={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(A||(A={})),function(e){e.Init=\\\"MainWorkerChannelEvent.Init\\\",e.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",e.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",e.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\"}(w||(w={}));var F=function(e,t,r,s){return new(r||(r=Promise))((function(n,i){function a(e){try{d(s.next(e))}catch(e){i(e)}}function o(e){try{d(s.throw(e))}catch(e){i(e)}}function d(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,o)}d((s=s.apply(e,t||[])).next())}))};const T=new c(self),R=self.navigator.userAgent.toLowerCase().indexOf(\\\"firefox\\\")>-1;class S{constructor({offscreenCanvas:e,wasmModule:t,wasmExports:r,memory:s,sizingData:n,baseUri:i,fileHandles:a,taskWorkerSab:o}){this.xrCanPresent=!1,this.xrIsPresenting=!1,this.sendFnTable=[function(e){return!0},function(e){const t=e.zerdeParser.parseU64();e.webglRenderer?(e.webglRenderer.processMessages(Number(t)),e.exports.deallocWasmMessage(t)):e.runWebGLPromise=T.send(B.RunWebGL,Number(t)).then((()=>{e.exports.deallocWasmMessage(t),e.runWebGLPromise=void 0}))},function(e){console.log(e.zerdeParser.parseString())},function(e){e.requestAnimationFrame()},function(e){e.setDocumentTitle(e.zerdeParser.parseString())},function(e){e.setMouseCursor(e.zerdeParser.parseU32())},function(e){const t=e.zerdeParser.parseF32(),r=e.zerdeParser.parseF32();T.send(B.ShowTextIME,{x:t,y:r})},function(e){},function(e){const t=e.zerdeParser.parseString();T.send(B.TextCopyResponse,t)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseF64(),s=e.zerdeParser.parseF64();e.startTimer(r,s,t)},function(e){const t=e.zerdeParser.parseF64();e.stopTimer(t)},function(e){e.xrStartPresenting()},function(e){e.xrStopPresenting()},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseString(),n=e.zerdeParser.parseString(),i=e.zerdeParser.parseString(),a=e.zerdeParser.parseString(),o=e.zerdeParser.parseString(),d=e.zerdeParser.parseU8Slice();e.httpSend(s,n,i,a,t,o,d,r)},function(e){T.send(B.Fullscreen)},function(e){T.send(B.Normalscreen)},function(e){const t=e.zerdeParser.parseString(),r=e.zerdeParser.parseU8Slice();e.websocketSend(t,r)},function(e){e.enableGlobalFileDropTarget()},function(e){const t=e.zerdeParser.parseString(),r=e.zerdeParser.parseZapParams();if(\\\"_zaplibReturnParams\\\"===t){const t=JSON.parse(r[0]);e.callRustPendingCallbacks[t](r.slice(1)),delete e.callRustPendingCallbacks[t]}else T.send(B.CallJs,{fnName:t,params:r})}],this.module=t,this.exports=r,this.memory=s,this.baseUri=i,this.sizingData=n,this.timers=[],this.hasRequestedAnimationFrame=!1,this.websockets={},this.fileHandles=a,this.callRustNewCallbackId=0,this.callRustPendingCallbacks={},e&&(this.webglRenderer=new v(e,this.memory,this.sizingData,(()=>{T.send(B.ShowIncompatibleBrowserNotification)}))),T.receive(B.ScreenResize,(e=>{this.sizingData=e,this.webglRenderer&&this.webglRenderer.resize(this.sizingData),this.zerdeEventloopEvents.resize({width:this.sizingData.width,height:this.sizingData.height,dpiFactor:this.sizingData.dpiFactor,xrIsPresenting:this.xrIsPresenting,xrCanPresent:this.xrCanPresent,isFullscreen:this.sizingData.isFullscreen}),this.requestAnimationFrame()})),this.bindMouseAndTouch(),this.bindKeyboard(),this.appPtr=this.exports.createWasmApp(),T.receive(B.WindowFocus,(()=>{this.zerdeEventloopEvents.windowFocus(!0),this.doWasmIo()})),T.receive(B.WindowBlur,(()=>{this.zerdeEventloopEvents.windowFocus(!1),this.doWasmIo()}));const d=({name:e,params:t})=>{const r=this.callRustNewCallbackId++,s=new Promise(((e,t)=>{this.callRustPendingCallbacks[r]=t=>{e(t)}}));return this.zerdeEventloopEvents.callRust(e,t,r),this.doWasmIo(),s};T.receive(B.CallRust,d),T.receive(B.CreateBuffer,(e=>this.zerdeEventloopEvents.createWasmBuffer(e))),T.receive(B.CreateReadOnlyBuffer,(e=>{const t=this.zerdeEventloopEvents.createWasmBuffer(e);return{bufferPtr:t,arcPtr:this.zerdeEventloopEvents.createArcVec(t,e)}})),T.receive(B.IncrementArc,(e=>{this.exports.incrementArc(BigInt(e))})),T.receive(B.DecrementArc,(e=>{this.exports.decrementArc(BigInt(e))})),T.receive(B.DeallocVec,(({bufferPtr:e,bufferLen:t,bufferCap:r})=>{this.exports.deallocVec(BigInt(e),BigInt(t),BigInt(r))}));const l=e=>{const t=new c(e);t.receive(w.Init,(()=>({wasmModule:this.module,memory:this.memory,taskWorkerSab:o,appPtr:this.appPtr,baseUri:i,tlsAndStackData:u(this.exports)}))),t.receive(w.BindMainWorkerPort,(e=>{l(e)})),t.receive(w.CallRust,d),t.receive(w.SendEventFromAnyThread,(e=>{this.sendEventFromAnyThread(e)}))};T.receive(B.BindMainWorkerPort,(e=>{l(e)})),this.zerdeEventloopEvents=new b(this),this.initApp()}initApp(){this.zerdeEventloopEvents.init({width:this.sizingData.width,height:this.sizingData.height,dpiFactor:this.sizingData.dpiFactor,xrCanPresent:this.xrCanPresent,canFullscreen:this.sizingData.canFullscreen,xrIsPresenting:!1}),this.doWasmIo(),T.send(B.RemoveLoadingIndicators)}doWasmIo(){if(this.doWasmBlock)return;const e=this.zerdeEventloopEvents.end(),t=Number(this.exports.processWasmEvents(this.appPtr,BigInt(e)));for(this.zerdeEventloopEvents=new b(this),this.zerdeParser=new d(this.memory,t);;){const e=this.zerdeParser.parseU32();if(this.sendFnTable[e](this))break}this.exports.deallocWasmMessage(BigInt(t))}setDocumentTitle(e){T.send(B.SetDocumentTitle,e)}bindMouseAndTouch(){let e;const t=[];function r(e){const r=t[e.button]||(t[e.button]={});return r.x=e.pageX,r.y=e.pageY,r.button=e.button,r.digit=e.button,r.time=performance.now()/1e3,r.modifiers=_(e),r.touch=!1,r}const s=[];T.receive(B.CanvasMouseDown,(e=>{s[e.button]=!0,this.zerdeEventloopEvents.pointerDown(r(e)),this.doWasmIo()})),T.receive(B.WindowMouseUp,(e=>{s[e.button]=!1,this.zerdeEventloopEvents.pointerUp(r(e)),this.doWasmIo()})),T.receive(B.WindowMouseMove,(t=>{for(let e=0;e<s.length;e++)if(s[e]){const s=r(t);s.digit=e,this.zerdeEventloopEvents.pointerMove(s)}e=r(t),this.zerdeEventloopEvents.pointerHover(e),this.doWasmIo()})),T.receive(B.WindowMouseOut,(e=>{this.zerdeEventloopEvents.pointerOut(r(e)),this.doWasmIo()}));const n=[];let i,a;T.receive(B.WindowTouchStart,(e=>{for(const t of e.changedTouches){let r=n.indexOf(void 0);-1===r&&(r=n.length),n[r]=t.identifier,this.zerdeEventloopEvents.pointerDown({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0})}this.doWasmIo()})),T.receive(B.WindowTouchMove,(e=>{for(const t of e.changedTouches){const r=n.indexOf(t.identifier);-1!=r?this.zerdeEventloopEvents.pointerMove({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0}):console.error(\\\"Unrecognized digit in WorkerEvent.WindowTouchMove\\\")}this.doWasmIo()})),T.receive(B.WindowTouchEndCancelLeave,(e=>{for(const t of e.changedTouches){const r=n.indexOf(t.identifier);-1!=r?(n[r]=void 0,this.zerdeEventloopEvents.pointerUp({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0})):console.error(\\\"Unrecognized digit in WorkerEvent.WindowTouchMove\\\")}this.doWasmIo()})),T.receive(B.CanvasWheel,(e=>{const t=r(e),s=e.timeStamp-i;i=e.timeStamp,a=R?1==e.deltaMode:!(Math.abs(Math.abs(e.deltaY/e.wheelDeltaY)-1/3)<1e-5||!a&&s<250);let n=1;1===e.deltaMode?n=40:2===e.deltaMode&&(n=800);const o=Object.assign(Object.assign({},t),{scrollX:e.deltaX*n,scrollY:e.deltaY*n,isWheel:a});this.zerdeEventloopEvents.pointerScroll(o),this.doWasmIo()}))}bindKeyboard(){T.receive(B.TextInput,(e=>{this.zerdeEventloopEvents.textInput(e),this.doWasmIo()})),T.receive(B.TextCopy,(()=>{this.zerdeEventloopEvents.textCopy(),this.doWasmIo()})),T.receive(B.KeyDown,(e=>{this.zerdeEventloopEvents.keyDown(e),this.doWasmIo()})),T.receive(B.KeyUp,(e=>{this.zerdeEventloopEvents.keyUp(e),this.doWasmIo()}))}setMouseCursor(t){T.send(B.SetMouseCursor,e[t]||\\\"default\\\")}startTimer(e,t,r){for(let t=0;t<this.timers.length;t++)if(this.timers[t].id==e)return void console.log(\\\"Timer ID collision!\\\");const s=0!==r?self.setInterval((()=>{this.zerdeEventloopEvents.timerFired(e),this.doWasmIo()}),1e3*t):self.setTimeout((()=>{for(let t=0;t<this.timers.length;t++)if(this.timers[t].id==e){this.timers.splice(t,1);break}this.zerdeEventloopEvents.timerFired(e),this.doWasmIo()}),1e3*t);this.timers.push({id:e,repeats:r,sysId:s})}stopTimer(e){for(let t=0;t<this.timers.length;t++){const r=this.timers[t];if(r.id==e)return r.repeats?self.clearInterval(r.sysId):self.clearTimeout(r.sysId),void this.timers.splice(t,1)}}httpSend(e,t,r,s,n,i,a,o){const d=new XMLHttpRequest;d.addEventListener(\\\"error\\\",(e=>{this.zerdeEventloopEvents.httpSendResponse(o,2),this.doWasmIo()})),d.addEventListener(\\\"load\\\",(e=>{200!==d.status?this.zerdeEventloopEvents.httpSendResponse(o,2):this.zerdeEventloopEvents.httpSendResponse(o,1),this.doWasmIo()})),d.open(e,r+\\\"://\\\"+s+\\\":\\\"+n+t,!0),console.log(e,r+\\\"://\\\"+s+\\\":\\\"+n+t,a),d.send(a.buffer)}websocketSend(e,t){const r=this.websockets[e];if(r)r.sendStack?r.sendStack.push(t):r.send(t);else{const r=new WebSocket(e);this.websockets[e]=r,r.sendStack=[t],r.addEventListener(\\\"close\\\",(()=>{this.websockets[e]=null})),r.addEventListener(\\\"error\\\",(t=>{this.websockets[e]=null,this.zerdeEventloopEvents.websocketError(e,\\\"\\\"+t),this.doWasmIo()})),r.addEventListener(\\\"message\\\",(t=>{t.data.arrayBuffer().then((t=>{this.zerdeEventloopEvents.websocketMessage(e,t),this.doWasmIo()}))})),r.addEventListener(\\\"open\\\",(()=>{const e=r.sendStack;for(t of(r.sendStack=null,e))r.send(t)}))}}enableGlobalFileDropTarget(){T.send(B.EnableGlobalFileDropTarget),T.receive(B.DragEnter,(()=>{this.zerdeEventloopEvents.dragenter(),this.doWasmIo()})),T.receive(B.DragOver,(({x:e,y:t})=>{this.zerdeEventloopEvents.dragover(e,t),this.doWasmIo()})),T.receive(B.DragLeave,(()=>{this.zerdeEventloopEvents.dragleave(),this.doWasmIo()})),T.receive(B.Drop,(({fileHandles:e,fileHandlesToSend:t})=>{this.fileHandles.splice(0,this.fileHandles.length),this.fileHandles.push(...e),this.zerdeEventloopEvents.appOpenFiles(t),this.doWasmIo()}))}requestAnimationFrame(){return F(this,void 0,void 0,(function*(){this.xrIsPresenting||this.hasRequestedAnimationFrame||(this.hasRequestedAnimationFrame=!0,this.runWebGLPromise&&(yield this.runWebGLPromise),(self.requestAnimationFrame||self.setTimeout)((()=>F(this,void 0,void 0,(function*(){this.runWebGLPromise&&(yield this.runWebGLPromise),this.hasRequestedAnimationFrame=!1,this.xrIsPresenting||(this.zerdeEventloopEvents.animationFrame(),this.doWasmIo())})))))}))}xrStartPresenting(){}xrStopPresenting(){}sendEventFromAnyThread(e){setTimeout((()=>{this.zerdeEventloopEvents.sendEventFromAnyThread(e),this.doWasmIo()}))}}T.receive(B.Init,(({wasmModule:e,offscreenCanvas:t,sizingData:r,baseUri:s,memory:n,taskWorkerSab:i})=>{let a;return new Promise(((o,d)=>{const l=[],h=(({getExports:e,memory:t,taskWorkerSab:r,fileHandles:s,sendEventFromAnyThread:n,threadSpawn:i,baseUri:a})=>{const o=new FileReaderSync,d=(e,r)=>{let s=\\\"\\\";const n=new Uint32Array(t.buffer,e,r);for(let e=0;e<r;e++)s+=String.fromCharCode(n[e]);return s};return{memory:t,_consoleLog:(e,t,r)=>{const s=d(parseInt(e),parseInt(t));r?console.error(s):console.log(s)},readUserFileRange:(e,r,n,i)=>{const a=s[e],d=Number(i),l=d+Number(n);a.lastReadStart<=d&&d<a.lastReadEnd&&console.warn(`Read start (${d}) fell in the range of the last read (${a.lastReadStart}-${a.lastReadEnd}); this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.`),a.lastReadStart=d,a.lastReadEnd=l;const h=o.readAsArrayBuffer(a.file.slice(d,l));return f(new Uint8Array(h),t.buffer,Number(r)),BigInt(h.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{i(e)},_sendEventFromAnyThread:e=>{n(e)},readUrlSync:(r,s,n,i)=>{const o=d(r,s),l=new XMLHttpRequest;if(l.responseType=\\\"arraybuffer\\\",l.open(\\\"GET\\\",new URL(o,a).href,!1),l.send(null),200===l.status){const r=e(),s=g(t,r,new Uint8Array(l.response));return new Uint32Array(t.buffer,n,1)[0]=s,new Uint32Array(t.buffer,i,1)[0]=l.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,t)=>{const r=new Int32Array(e);((e,t)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(r);const s=r[1];new Uint32Array(e)[s+2]=t,r[1]=s+1,((e,t)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,0,1)})(r),Atomics.notify(r,1)})(r,parseInt(e))}}})({getExports:()=>a.exports,memory:n,taskWorkerSab:i,fileHandles:l,sendEventFromAnyThread:e=>{a.sendEventFromAnyThread(e)},threadSpawn:e=>{T.send(B.ThreadSpawn,{ctxPtr:e,tlsAndStackData:u(a.exports)})},baseUri:s});WebAssembly.instantiate(e,{env:h}).then((d=>{const h=d.exports;(e=>{const t=e.allocWasmMessage(BigInt(e.__tls_size.value));e.__wasm_init_tls(Number(t))})(h),a=new S({offscreenCanvas:t,wasmModule:e,wasmExports:h,memory:n,sizingData:r,baseUri:s,fileHandles:l,taskWorkerSab:i}),o()}),d)}))}))})();\\n\", \"Worker\", undefined, undefined);\n}\n","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";var e,r;(r=e||(e={}))[r.String=0]=\\\"String\\\",r[r.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",r[r.U8Buffer=2]=\\\"U8Buffer\\\",r[r.F32Buffer=3]=\\\"F32Buffer\\\",r[r.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\",self;class t extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class r extends e{constructor(...r){const n=r[0];if(\\\"object\\\"==typeof n&&n instanceof t){if(r.length<2&&(r[1]=n.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<n.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=n.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=n}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const a={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,r]of Object.entries(a))e in self&&(self[r]=n(self[e]));new WeakMap;const o={};new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete o[e],r&&r(e)})),new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)}));const s=\\\"$$RESPONSE\\\",i=\\\"$$ERROR\\\";class l{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===s)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:s,id:r},[]);const t=e[l.transferrables];delete e[l.transferrables];const n={topic:s,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:s,id:r,data:{[i]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,a={topic:e,id:n,data:r},o=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[i]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(a,t),o}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}l.transferrables=\\\"$$TRANSFERRABLES\\\";const c=e=>{const r=8*Math.ceil((e.__tls_size.value+2097152)/8);return{ptr:e.allocWasmMessage(BigInt(r)),size:r}},f=(e,r,t)=>{new e.constructor(r,t,e.length).set(e)},u=({getExports:e,memory:r,taskWorkerSab:t,fileHandles:n,sendEventFromAnyThread:a,threadSpawn:o,baseUri:s})=>{const i=new FileReaderSync,l=(e,t)=>{let n=\\\"\\\";const a=new Uint32Array(r.buffer,e,t);for(let e=0;e<t;e++)n+=String.fromCharCode(a[e]);return n};return{memory:r,_consoleLog:(e,r,t)=>{const n=l(parseInt(e),parseInt(r));t?console.error(n):console.log(n)},readUserFileRange:(e,t,a,o)=>{const s=n[e],l=Number(o),c=l+Number(a);s.lastReadStart<=l&&l<s.lastReadEnd&&console.warn(`Read start (${l}) fell in the range of the last read (${s.lastReadStart}-${s.lastReadEnd}); this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.`),s.lastReadStart=l,s.lastReadEnd=c;const u=i.readAsArrayBuffer(s.file.slice(l,c));return f(new Uint8Array(u),r.buffer,Number(t)),BigInt(u.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{o(e)},_sendEventFromAnyThread:e=>{a(e)},readUrlSync:(t,n,a,o)=>{const i=l(t,n),c=new XMLHttpRequest;if(c.responseType=\\\"arraybuffer\\\",c.open(\\\"GET\\\",new URL(i,s).href,!1),c.send(null),200===c.status){const t=e(),n=((e,r,t)=>{const n=Number(r.allocWasmVec(BigInt(t.byteLength)));return f(t,e.buffer,n),n})(r,t,new Uint8Array(c.response));return new Uint32Array(r.buffer,a,1)[0]=n,new Uint32Array(r.buffer,o,1)[0]=c.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,r)=>{const t=new Int32Array(e);((e,r)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(t);const n=t[1];new Uint32Array(e)[n+2]=r,t[1]=n+1,((e,r)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,0,1)})(t),Atomics.notify(t,1)})(t,parseInt(e))}}};var d,p,h,E;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\"}(d||(d={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(p||(p={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(h||(h={})),function(e){e.Init=\\\"MainWorkerChannelEvent.Init\\\",e.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",e.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",e.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\"}(E||(E={}));const y=new l(self);y.receive(h.Run,(({wasmModule:e,memory:r,taskWorkerSab:t,ctxPtr:n,fileHandles:a,baseUri:o,tlsAndStackData:s,mainWorkerPort:i})=>{let f;const d=new l(i),p=u({getExports:()=>f,memory:r,taskWorkerSab:t,fileHandles:a,sendEventFromAnyThread:e=>{d.send(E.SendEventFromAnyThread,e)},threadSpawn:e=>{y.send(h.ThreadSpawn,{ctxPtr:e,tlsAndStackData:c(f)})},baseUri:o});return new Promise(((r,t)=>{WebAssembly.instantiate(e,{env:p}).then((e=>{f=e.exports,((e,r)=>{e.__stack_pointer.value=Number(r.ptr)+r.size-8,e.__wasm_init_tls(Number(r.ptr))})(f,s),f.runFunctionPointer(n),r()}),t)}))}))})();\\n\", \"Worker\", undefined, undefined);\n}\n","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";var e,r;(r=e||(e={}))[r.String=0]=\\\"String\\\",r[r.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",r[r.U8Buffer=2]=\\\"U8Buffer\\\",r[r.F32Buffer=3]=\\\"F32Buffer\\\",r[r.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\",self;class t extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class r extends e{constructor(...r){const n=r[0];if(\\\"object\\\"==typeof n&&n instanceof t){if(r.length<2&&(r[1]=n.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<n.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=n.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=n}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const s={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,r]of Object.entries(s))e in self&&(self[r]=n(self[e]));new WeakMap;const a={};new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete a[e],r&&r(e)})),new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)}));class o{constructor(e,r){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,r),this._u32=new Uint32Array(this._memory.buffer,r),this._f64=new Float64Array(this._memory.buffer,r),this._u64=new BigUint64Array(this._memory.buffer,r)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e=\\\"\\\";const r=this.parseU32();for(let t=0;t<r;t++){const r=this.parseU32();0!=r&&(e+=String.fromCharCode(r))}return e}parseU8Slice(){const e=this.parseU32(),r=e>>2,t=new Uint8Array(e),n=3&e;for(let e=0;e<r;e++){const r=e<<2,n=this.parseU32();t[r+0]=255&n,t[r+1]=n>>8&255,t[r+2]=n>>16&255,t[r+3]=n>>24&255}const s=r<<2;if(1==n){const e=this.parseU32();t[s+0]=255&e}else if(2==n){const e=this.parseU32();t[s+0]=255&e,t[s+1]=e>>8&255}else if(3==n){const e=this.parseU32();t[s+0]=255&e,t[s+1]=e>>8&255,t[s+2]=e>>16&255}return t}parseZapParams(){const r=this.parseU32(),t=[];for(let n=0;n<r;++n){const r=this.parseU32();if(r===e.String)t.push(this.parseString());else if(r===e.ReadOnlyU8Buffer||r===e.ReadOnlyF32Buffer){const e=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,arcPtr:s,readonly:!0})}else{if(r!==e.U8Buffer&&r!==e.F32Buffer)throw new Error(`Unknown ZapParam type: ${r}`);{const e=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,bufferCap:s,readonly:!1})}}}return t}}const i=\\\"$$RESPONSE\\\",f=\\\"$$ERROR\\\";class u{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===i)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:i,id:r},[]);const t=e[u.transferrables];delete e[u.transferrables];const n={topic:i,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:i,id:r,data:{[f]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,s={topic:e,id:n,data:r},a=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[f]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(s,t),a}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}u.transferrables=\\\"$$TRANSFERRABLES\\\";const l=(e,r)=>{for(;;){if(0==Atomics.compareExchange(e,r,0,1))return;Atomics.wait(e,r,1)}},c=(e,r)=>{if(1!=Atomics.compareExchange(e,r,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,r,1)};function h(e,r=\\\"Value\\\"){if(null==e)throw new Error(`Assertion failed: ${r} is null`);return e}var d,p,y,v;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\"}(d||(d={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(p||(p={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(y||(y={})),function(e){e.Init=\\\"MainWorkerChannelEvent.Init\\\",e.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",e.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",e.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\"}(v||(v={})),new u(self).receive(p.Init,(({taskWorkerSab:e,wasmMemory:r})=>{const t=new Int32Array(e);let n=0,s=1;const a={};function i(e,t){const n=new Int32Array(r.buffer,e,1);if(n[0]===t)throw new Error(\\\"Have to set the return value to something different than the initial value, otherwise Atomics.notify won't do anything\\\");n[0]=t,Atomics.notify(n,0)}function f(e){const r=a[e];n++,r.reader.read().then((t=>{n--,t.done?r.done=!0:(r.values.push(t.value),f(e)),u(e)})).catch((t=>{n--,console.error(\\\"fetch read error\\\",t),r.error=!0,u(e)}))}function u(e){const t=a[e];if(!t.currentTwMessage)return;if(t.error)return i(t.currentTwMessage.bytesReadReturnValPtr,-2),void(t.currentTwMessage=void 0);if(0===t.values.length)return void(t.done&&(i(t.currentTwMessage.bytesReadReturnValPtr,0),t.currentTwMessage=void 0));let n=0;for(;t.values.length>0&&n<t.currentTwMessage.bufLen;){const e=t.values[0],s=t.currentTwMessage.bufLen-n,a=Math.min(e.byteLength,s),o=new Uint8Array(e.buffer,e.byteOffset,a);new Uint8Array(r.buffer,t.currentTwMessage.bufPtr+n,a).set(o),a<e.byteLength?t.values[0]=new Uint8Array(e.buffer,e.byteOffset+a,e.byteLength-a):t.values.shift(),n+=a}i(t.currentTwMessage.bytesReadReturnValPtr,n),t.currentTwMessage=void 0}function d(e){const r=e.parseU32();if(1==r){const r=e.parseU32(),t=e.parseString(),o=e.parseString(),u=e.parseU8Slice(),l=e.parseU32(),c={};for(let r=0;r<l;r++)c[e.parseString()]=e.parseString();n++,fetch(t,{method:o,body:u,headers:c}).then((e=>{if(n--,e.ok){const t=s++;a[t]={reader:h(e.body).getReader(),values:[],done:!1,error:!1,currentTwMessage:void 0},f(t),i(r,t)}else i(r,-2)})).catch((e=>{n--,console.error(\\\"fetch create error\\\",e),i(r,-2)}))}else if(2==r){const r={bytesReadReturnValPtr:e.parseU32(),streamId:e.parseU32(),bufPtr:e.parseU32(),bufLen:e.parseU32()};if(a[r.streamId].currentTwMessage)return console.error(\\\"Got multiple http_stream_read messages in a row\\\"),void i(r.bytesReadReturnValPtr,-2);a[r.streamId].currentTwMessage=r,u(r.streamId)}}setTimeout((function s(){for(;;){if(Atomics.load(t,1)>0){l(t,0);const n=t[1];for(let t=0;t<n;t++){const n=new Uint32Array(e)[t+2];d(new o(r,n))}t[1]=0,c(t,0)}if(n>0){setTimeout(s,1);break}Atomics.wait(t,1,0)}}),0)}))})();\\n\", \"Worker\", undefined, undefined);\n}\n","export const makeRpcMouseEvent = (event) => {\n    return {\n        pageX: event.pageX,\n        pageY: event.pageY,\n        button: event.button,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\nexport const makeRpcTouchEvent = (event) => {\n    return {\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n        changedTouches: Array.from(event.changedTouches).map((touch) => ({\n            pageX: touch.pageX,\n            pageY: touch.pageY,\n            identifier: touch.identifier,\n        })),\n    };\n};\nexport const makeRpcWheelEvent = (event) => {\n    return {\n        pageX: event.pageX,\n        pageY: event.pageY,\n        button: event.button,\n        timeStamp: event.timeStamp,\n        deltaMode: event.deltaMode,\n        deltaX: event.deltaX,\n        deltaY: event.deltaY,\n        // @ts-ignore - the wheelDeltaY API is non-standard\n        wheelDeltaY: event.wheelDeltaY,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\nexport const makeRpcKeyboardEvent = (event) => {\n    return {\n        keyCode: event.keyCode,\n        repeat: event.repeat,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\n","export var WorkerEvent;\n(function (WorkerEvent) {\n    WorkerEvent[\"CallRust\"] = \"WorkerEvent.CallRust\";\n    WorkerEvent[\"CreateBuffer\"] = \"WorkerEvent.CreateBuffer\";\n    WorkerEvent[\"CreateReadOnlyBuffer\"] = \"WorkerEvent.CreateReadOnlyBuffer\";\n    WorkerEvent[\"BindMainWorkerPort\"] = \"WorkerEvent.BindMainWorkerPort\";\n    WorkerEvent[\"DecrementArc\"] = \"WorkerEvent.DecrementArc\";\n    WorkerEvent[\"DeallocVec\"] = \"WorkerEvent.DeallocVec\";\n    WorkerEvent[\"IncrementArc\"] = \"WorkerEvent.IncrementArc\";\n    WorkerEvent[\"DragEnter\"] = \"WorkerEvent.DragEnter\";\n    WorkerEvent[\"DragOver\"] = \"WorkerEvent.DragOver\";\n    WorkerEvent[\"DragLeave\"] = \"WorkerEvent.DragLeave\";\n    WorkerEvent[\"Drop\"] = \"WorkerEvent.Drop\";\n    WorkerEvent[\"WindowMouseUp\"] = \"WorkerEvent.WindowMouseUp\";\n    WorkerEvent[\"CanvasMouseDown\"] = \"WorkerEvent.CanvasMouseDown\";\n    WorkerEvent[\"WindowMouseMove\"] = \"WorkerEvent.WindowMouseMove\";\n    WorkerEvent[\"WindowMouseOut\"] = \"WorkerEvent.WindowMouseOut\";\n    WorkerEvent[\"WindowFocus\"] = \"WorkerEvent.WindowFocus\";\n    WorkerEvent[\"WindowBlur\"] = \"WorkerEvent.WindowBlur\";\n    WorkerEvent[\"ScreenResize\"] = \"WorkerEvent.ScreenResize\";\n    WorkerEvent[\"CanvasWheel\"] = \"WorkerEvent.CanvasWheel\";\n    WorkerEvent[\"ShowIncompatibleBrowserNotification\"] = \"WorkerEvent.ShowIncompatibleBrowserNotification\";\n    WorkerEvent[\"RemoveLoadingIndicators\"] = \"WorkerEvent.RemoveLoadingIndicators\";\n    WorkerEvent[\"SetDocumentTitle\"] = \"WorkerEvent.SetDocumentTitle\";\n    WorkerEvent[\"SetMouseCursor\"] = \"WorkerEvent.SetMouseCursor\";\n    WorkerEvent[\"Fullscreen\"] = \"WorkerEvent.Fullscreen\";\n    WorkerEvent[\"Normalscreen\"] = \"WorkerEvent.Normalscreen\";\n    WorkerEvent[\"TextCopyResponse\"] = \"WorkerEvent.TextCopyResponse\";\n    WorkerEvent[\"EnableGlobalFileDropTarget\"] = \"WorkerEvent.EnableGlobalFileDropTarget\";\n    WorkerEvent[\"CallJs\"] = \"WorkerEvent.CallJs\";\n    WorkerEvent[\"ShowTextIME\"] = \"WorkerEvent.ShowTextIME\";\n    WorkerEvent[\"TextInput\"] = \"WorkerEvent.TextInput\";\n    WorkerEvent[\"TextCopy\"] = \"WorkerEvent.TextCopy\";\n    WorkerEvent[\"KeyDown\"] = \"WorkerEvent.KeyDown\";\n    WorkerEvent[\"KeyUp\"] = \"WorkerEvent.KeyUp\";\n    WorkerEvent[\"Init\"] = \"WorkerEvent.Init\";\n    WorkerEvent[\"RunWebGL\"] = \"WorkerEvent.RunWebGL\";\n    WorkerEvent[\"ThreadSpawn\"] = \"WorkerEvent.ThreadSpawn\";\n    WorkerEvent[\"WindowTouchStart\"] = \"WorkerEvent.WindowTouchStart\";\n    WorkerEvent[\"WindowTouchMove\"] = \"WorkerEvent.WindowTouchMove\";\n    WorkerEvent[\"WindowTouchEndCancelLeave\"] = \"WorkerEvent.WindowTouchEndCancelLeave\";\n})(WorkerEvent || (WorkerEvent = {}));\nexport var TaskWorkerEvent;\n(function (TaskWorkerEvent) {\n    TaskWorkerEvent[\"Init\"] = \"TaskWorkerEvent.Init\";\n})(TaskWorkerEvent || (TaskWorkerEvent = {}));\nexport var AsyncWorkerEvent;\n(function (AsyncWorkerEvent) {\n    AsyncWorkerEvent[\"Run\"] = \"AsyncWorkerEvent.Run\";\n    AsyncWorkerEvent[\"ThreadSpawn\"] = \"AsyncWorkerEvent.ThreadSpawn\";\n})(AsyncWorkerEvent || (AsyncWorkerEvent = {}));\nexport var MainWorkerChannelEvent;\n(function (MainWorkerChannelEvent) {\n    MainWorkerChannelEvent[\"Init\"] = \"MainWorkerChannelEvent.Init\";\n    MainWorkerChannelEvent[\"BindMainWorkerPort\"] = \"MainWorkerChannelEvent.BindMainWorkerPort\";\n    MainWorkerChannelEvent[\"CallRust\"] = \"MainWorkerChannelEvent.CallRust\";\n    MainWorkerChannelEvent[\"SendEventFromAnyThread\"] = \"MainWorkerChannelEvent.SendEventFromAnyThread\";\n})(MainWorkerChannelEvent || (MainWorkerChannelEvent = {}));\n","import { makeRpcKeyboardEvent } from \"./make_rpc_event\";\nimport { WorkerEvent } from \"./rpc_types\";\n// Create a hidden textarea which is purely used for text input into Rust.\nexport function makeTextarea(callback) {\n    let ta;\n    // NOTE(JP): This looks a bit convoluted, but it's the most reliable method I could find to return the focus to the textarea!\n    function fixFocus() {\n        setTimeout(() => {\n            var _a;\n            if (ta &&\n                document.activeElement !== ta &&\n                !((_a = document\n                    .getElementById(\"zaplib_js_root\")) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement))) {\n                ta.focus();\n            }\n        });\n    }\n    document.addEventListener(\"mousedown\", fixFocus, true);\n    document.addEventListener(\"mouseup\", fixFocus, true);\n    document.addEventListener(\"focus\", fixFocus, true);\n    document.addEventListener(\"blur\", fixFocus, true);\n    let textAreaPos;\n    const updateTextAreaPos = () => {\n        if (!textAreaPos) {\n            ta.style.left = -100 + \"px\";\n            ta.style.top = -100 + \"px\";\n        }\n        else {\n            ta.style.left = Math.round(textAreaPos.x) - 4 + \"px\";\n            ta.style.top = Math.round(textAreaPos.y) + \"px\";\n        }\n    };\n    function showTextIME({ x, y }) {\n        textAreaPos = { x, y };\n        updateTextAreaPos();\n    }\n    let wasPaste = false;\n    let lastLen = 0;\n    let uglyIMEHack = false;\n    const recreateTextarea = function () {\n        if (ta)\n            document.body.removeChild(ta);\n        ta = document.createElement(\"textarea\");\n        ta.className = \"zaplib_textarea\";\n        ta.setAttribute(\"autocomplete\", \"off\");\n        ta.setAttribute(\"autocorrect\", \"off\");\n        ta.setAttribute(\"autocapitalize\", \"off\");\n        ta.setAttribute(\"spellcheck\", \"false\");\n        ta.style.left = -100 + \"px\";\n        ta.style.top = -100 + \"px\";\n        ta.style.height = 1 + \"px\";\n        ta.style.width = 1 + \"px\";\n        ta.addEventListener(\"contextmenu\", (event) => {\n            event.preventDefault();\n            return false;\n        });\n        document.body.appendChild(ta);\n        ta.focus();\n        updateTextAreaPos();\n        ta.addEventListener(\"cut\", () => {\n            setTimeout(() => {\n                ta.value = \"\";\n                lastLen = 0;\n            });\n        });\n        ta.addEventListener(\"copy\", () => {\n            setTimeout(() => {\n                ta.value = \"\";\n                lastLen = 0;\n            });\n        });\n        ta.addEventListener(\"paste\", () => {\n            wasPaste = true;\n        });\n        ta.addEventListener(\"input\", () => {\n            if (ta.value.length > 0) {\n                if (wasPaste) {\n                    wasPaste = false;\n                    const input = ta.value.substring(lastLen);\n                    ta.value = \"\";\n                    callback({\n                        type: WorkerEvent.TextInput,\n                        wasPaste: true,\n                        input,\n                        replaceLast: false,\n                    });\n                }\n                else {\n                    let replaceLast = false;\n                    let textValue = ta.value;\n                    if (ta.value.length >= 2) {\n                        // we want the second char\n                        textValue = ta.value.substring(1, 2);\n                        ta.value = textValue;\n                    }\n                    else if (ta.value.length == 1 && lastLen == ta.value.length) {\n                        // its an IME replace\n                        replaceLast = true;\n                    }\n                    // we should send a replace last\n                    if (replaceLast || textValue != \"\\n\") {\n                        callback({\n                            type: WorkerEvent.TextInput,\n                            wasPaste: false,\n                            input: textValue,\n                            replaceLast: replaceLast,\n                        });\n                    }\n                }\n            }\n            lastLen = ta.value.length;\n        });\n        ta.addEventListener(\"keydown\", (event) => {\n            const code = event.keyCode;\n            if (code == 18 || code == 17 || code == 16)\n                event.preventDefault(); // alt\n            if (code === 8 || code === 9)\n                event.preventDefault(); // backspace/tab\n            if (code === 89 && (event.metaKey || event.ctrlKey))\n                event.preventDefault(); // all (select all)\n            if (code === 83 && (event.metaKey || event.ctrlKey))\n                event.preventDefault(); // ctrl s\n            if (code >= 33 && code <= 40) {\n                // if we are using arrow keys, home or end\n                ta.value = \"\";\n                lastLen = ta.value.length;\n            }\n            if ((code === 88 || code == 67) && (event.metaKey || event.ctrlKey)) {\n                // copy or cut\n                // we need to request the clipboard\n                callback({ type: WorkerEvent.TextCopy });\n                event.preventDefault();\n            }\n            if (code === 90 && (event.metaKey || event.ctrlKey)) {\n                // ctrl/cmd + z\n                updateTextAreaPos();\n                ta.value = \"\";\n                uglyIMEHack = true;\n                ta.readOnly = true;\n                event.preventDefault();\n            }\n            callback({\n                type: WorkerEvent.KeyDown,\n                event: makeRpcKeyboardEvent(event),\n            });\n        });\n        ta.addEventListener(\"keyup\", (event) => {\n            const code = event.keyCode;\n            if (code == 18 || code == 17 || code == 16)\n                event.preventDefault(); // alt\n            if (code == 91)\n                event.preventDefault(); // left window key\n            if (uglyIMEHack) {\n                uglyIMEHack = false;\n                recreateTextarea();\n            }\n            callback({\n                type: WorkerEvent.KeyUp,\n                event: makeRpcKeyboardEvent(event),\n            });\n        });\n    };\n    recreateTextarea();\n    function textareaHasFocus() {\n        return document.activeElement == ta;\n    }\n    return { showTextIME, textareaHasFocus };\n}\n","import { assertNotNull } from \"./common\";\nimport { ZerdeParser } from \"./zerde\";\nexport class WebGLRenderer {\n    constructor(canvas, memory, sizingData, incompatibleBrowserCallback) {\n        this.uniformFnTable = {\n            float: function setFloat(self, loc, off) {\n                const slot = off >> 2;\n                self.gl.uniform1f(loc, self.basef32[slot]);\n            },\n            vec2: function setVec2(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform2f(loc, basef32[slot], basef32[slot + 1]);\n            },\n            vec3: function setVec3(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform3f(loc, basef32[slot], basef32[slot + 1], basef32[slot + 2]);\n            },\n            vec4: function setVec4(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform4f(loc, basef32[slot], basef32[slot + 1], basef32[slot + 2], basef32[slot + 3]);\n            },\n            mat2: function setMat2(self, loc, off) {\n                self.gl.uniformMatrix2fv(loc, false, new Float32Array(self.memory.buffer, off, 4));\n            },\n            mat3: function setMat3(self, loc, off) {\n                self.gl.uniformMatrix3fv(loc, false, new Float32Array(self.memory.buffer, off, 9));\n            },\n            mat4: function setMat4(self, loc, off) {\n                const mat4 = new Float32Array(self.memory.buffer, off, 16);\n                self.gl.uniformMatrix4fv(loc, false, mat4);\n            },\n        };\n        // Array of function id's wasm can call on us; `self` is pointer to WebGLRenderer.\n        // Function names are suffixed with the index in the array, and annotated with\n        // their name in cx_webgl.rs, for easier matching.\n        this.sendFnTable = [\n            // end\n            function end0(_self) {\n                return true;\n            },\n            // compile_webgl_shader\n            function compileWebGLShader1(self) {\n                function parseShvarvec() {\n                    const len = self.zerdeParser.parseU32();\n                    const vars = [];\n                    for (let i = 0; i < len; i++) {\n                        vars.push({\n                            ty: self.zerdeParser.parseString(),\n                            name: self.zerdeParser.parseString(),\n                        });\n                    }\n                    return vars;\n                }\n                const ash = {\n                    shaderId: self.zerdeParser.parseU32(),\n                    fragment: self.zerdeParser.parseString(),\n                    vertex: self.zerdeParser.parseString(),\n                    geometrySlots: self.zerdeParser.parseU32(),\n                    instanceSlots: self.zerdeParser.parseU32(),\n                    passUniforms: parseShvarvec(),\n                    viewUniforms: parseShvarvec(),\n                    drawUniforms: parseShvarvec(),\n                    userUniforms: parseShvarvec(),\n                    textureSlots: parseShvarvec(),\n                };\n                self.compileWebGLShader(ash);\n            },\n            // alloc_array_buffer\n            function allocArrayBuffer2(self) {\n                const arrayBufferId = self.zerdeParser.parseU32();\n                const len = self.zerdeParser.parseU32();\n                const pointer = self.zerdeParser.parseU32();\n                const array = new Float32Array(self.memory.buffer, pointer, len);\n                self.allocArrayBuffer(arrayBufferId, array);\n            },\n            // alloc_index_buffer\n            function allocIndexBuffer3(self) {\n                const indexBufferId = self.zerdeParser.parseU32();\n                const len = self.zerdeParser.parseU32();\n                const pointer = self.zerdeParser.parseU32();\n                const array = new Uint32Array(self.memory.buffer, pointer, len);\n                self.allocIndexBuffer(indexBufferId, array);\n            },\n            // alloc_vao\n            function allocVao4(self) {\n                const vaoId = self.zerdeParser.parseU32();\n                const shaderId = self.zerdeParser.parseU32();\n                const geomIbId = self.zerdeParser.parseU32();\n                const geomVbId = self.zerdeParser.parseU32();\n                const instVbId = self.zerdeParser.parseU32();\n                self.allocVao(vaoId, shaderId, geomIbId, geomVbId, instVbId);\n            },\n            // draw_call\n            function drawCall5(self) {\n                const shaderId = self.zerdeParser.parseU32();\n                const vaoId = self.zerdeParser.parseU32();\n                const uniformsPassPtr = self.zerdeParser.parseU32();\n                const uniformsViewPtr = self.zerdeParser.parseU32();\n                const uniformsDrawPtr = self.zerdeParser.parseU32();\n                const uniformsUserPtr = self.zerdeParser.parseU32();\n                const textures = self.zerdeParser.parseU32();\n                self.drawCall(shaderId, vaoId, uniformsPassPtr, uniformsViewPtr, uniformsDrawPtr, uniformsUserPtr, textures);\n            },\n            // update_texture_image2d\n            function allocTexture6(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const width = self.zerdeParser.parseU32();\n                const height = self.zerdeParser.parseU32();\n                const dataPtr = self.zerdeParser.parseU32();\n                self.allocTexture(textureId, width, height, dataPtr);\n            },\n            // begin_render_targets\n            function beginRenderTargets7(self) {\n                const passId = self.zerdeParser.parseU32();\n                const width = self.zerdeParser.parseU32();\n                const height = self.zerdeParser.parseU32();\n                self.beginRenderTargets(passId, width, height);\n            },\n            // add_color_target\n            function addColorTarget8(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const initOnly = self.zerdeParser.parseU32();\n                const r = self.zerdeParser.parseF32();\n                const g = self.zerdeParser.parseF32();\n                const b = self.zerdeParser.parseF32();\n                const a = self.zerdeParser.parseF32();\n                self.addColorTarget(textureId, initOnly, r, g, b, a);\n            },\n            // set_depth_target\n            function setDepthTarget9(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const initOnly = self.zerdeParser.parseU32();\n                const depth = self.zerdeParser.parseF32();\n                self.setDepthTarget(textureId, initOnly, depth);\n            },\n            // end_render_targets\n            function endRenderTargets10(self) {\n                self.endRenderTargets();\n            },\n            // set_default_depth_and_blend_mode\n            function setDefaultDepthAndBlendMode11(self) {\n                self.setDefaultDepthAndBlendMode();\n            },\n            // begin_main_canvas\n            function beginMainCanvas12(self) {\n                const r = self.zerdeParser.parseF32();\n                const g = self.zerdeParser.parseF32();\n                const b = self.zerdeParser.parseF32();\n                const a = self.zerdeParser.parseF32();\n                const depth = self.zerdeParser.parseF32();\n                self.beginMainCanvas(r, g, b, a, depth);\n            },\n        ];\n        this.canvas = canvas;\n        this.memory = memory;\n        this.sizingData = sizingData;\n        this.shaders = [];\n        this.indexBuffers = [];\n        this.arrayBuffers = [];\n        this.vaos = [];\n        this.textures = [];\n        this.framebuffers = [];\n        this.targetWidth = 0;\n        this.targetHeight = 0;\n        this.clearFlags = 0;\n        this.clearR = 0;\n        this.clearG = 0;\n        this.clearB = 0;\n        this.clearA = 0;\n        this.clearDepth = 0;\n        // this.isMainCanvas = false;\n        const options = {\n            preferLowPowerToHighPerformance: true,\n            // xrCompatible: true // TODO(JP): Bring back some day?\n        };\n        // @ts-ignore - TODO(Paras): Get proper support for OffscreenCanvas\n        this.gl =\n            // @ts-ignore\n            canvas.getContext(\"webgl\", options) ||\n                // @ts-ignore\n                canvas.getContext(\"webgl-experimental\", options) ||\n                // @ts-ignore\n                canvas.getContext(\"experimental-webgl\", options);\n        if (!this.gl) {\n            incompatibleBrowserCallback();\n            return;\n        }\n        this.OESVertexArrayObject = assertNotNull(this.gl.getExtension(\"OES_vertex_array_object\"));\n        this.ANGLEInstancedArrays = assertNotNull(this.gl.getExtension(\"ANGLE_instanced_arrays\"));\n        this.gl.getExtension(\"OES_standard_derivatives\");\n        this.gl.getExtension(\"OES_element_index_uint\");\n        this.resize(sizingData);\n    }\n    processMessages(zerdeParserPtr) {\n        this.zerdeParser = new ZerdeParser(this.memory, zerdeParserPtr);\n        this.basef32 = new Float32Array(this.memory.buffer);\n        this.baseu32 = new Uint32Array(this.memory.buffer);\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const msgType = this.zerdeParser.parseU32();\n            if (this.sendFnTable[msgType](this)) {\n                break;\n            }\n        }\n    }\n    resize(sizingData) {\n        this.sizingData = sizingData;\n        this.canvas.width = sizingData.width * sizingData.dpiFactor;\n        this.canvas.height = sizingData.height * sizingData.dpiFactor;\n    }\n    getAttribLocations(program, base, slots) {\n        const gl = this.gl;\n        const attribLocs = [];\n        let attribs = slots >> 2;\n        if ((slots & 3) != 0)\n            attribs++;\n        for (let i = 0; i < attribs; i++) {\n            let size = slots - i * 4;\n            if (size > 4)\n                size = 4;\n            attribLocs.push({\n                loc: gl.getAttribLocation(program, base + i),\n                offset: i * 16,\n                size: size,\n                stride: slots * 4,\n            });\n        }\n        return attribLocs;\n    }\n    getUniformLocations(program, uniforms) {\n        const gl = this.gl;\n        const uniformLocs = [];\n        let offset = 0;\n        for (let i = 0; i < uniforms.length; i++) {\n            const uniform = uniforms[i];\n            // lets align the uniform\n            const slots = uniformSizeTable[uniform.ty];\n            if ((offset & 3) != 0 && (offset & 3) + slots > 4) {\n                // goes over the boundary\n                offset += 4 - (offset & 3); // make jump to new slot\n            }\n            uniformLocs.push({\n                name: uniform.name,\n                offset: offset << 2,\n                ty: uniform.ty,\n                loc: gl.getUniformLocation(program, uniform.name),\n                fn: this.uniformFnTable[uniform.ty],\n            });\n            offset += slots;\n        }\n        return uniformLocs;\n    }\n    compileWebGLShader(ash) {\n        const gl = this.gl;\n        const vsh = assertNotNull(gl.createShader(gl.VERTEX_SHADER));\n        gl.shaderSource(vsh, ash.vertex);\n        gl.compileShader(vsh);\n        if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {\n            console.log(gl.getShaderInfoLog(vsh), addLineNumbersToString(ash.vertex));\n        }\n        // compile pixelshader\n        const fsh = assertNotNull(gl.createShader(gl.FRAGMENT_SHADER));\n        gl.shaderSource(fsh, ash.fragment);\n        gl.compileShader(fsh);\n        if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {\n            console.log(gl.getShaderInfoLog(fsh), addLineNumbersToString(ash.fragment));\n        }\n        const program = assertNotNull(gl.createProgram());\n        gl.attachShader(program, vsh);\n        gl.attachShader(program, fsh);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            console.log(gl.getProgramInfoLog(program), addLineNumbersToString(ash.vertex), addLineNumbersToString(ash.fragment));\n        }\n        // fetch all attribs and uniforms\n        this.shaders[ash.shaderId] = {\n            geomAttribs: this.getAttribLocations(program, \"mpsc_packed_geometry_\", ash.geometrySlots),\n            instAttribs: this.getAttribLocations(program, \"mpsc_packed_instance_\", ash.instanceSlots),\n            passUniforms: this.getUniformLocations(program, ash.passUniforms),\n            viewUniforms: this.getUniformLocations(program, ash.viewUniforms),\n            drawUniforms: this.getUniformLocations(program, ash.drawUniforms),\n            userUniforms: this.getUniformLocations(program, ash.userUniforms),\n            textureSlots: this.getUniformLocations(program, ash.textureSlots),\n            instanceSlots: ash.instanceSlots,\n            program: program,\n            ash: ash,\n        };\n    }\n    allocArrayBuffer(arrayBufferId, array) {\n        const gl = this.gl;\n        let buf = this.arrayBuffers[arrayBufferId];\n        if (buf === undefined) {\n            buf = this.arrayBuffers[arrayBufferId] = {\n                glBuf: assertNotNull(gl.createBuffer()),\n                length: array.length,\n            };\n        }\n        else {\n            buf.length = array.length;\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, buf.glBuf);\n        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n    allocIndexBuffer(indexBufferId, array) {\n        const gl = this.gl;\n        let buf = this.indexBuffers[indexBufferId];\n        if (buf === undefined) {\n            buf = this.indexBuffers[indexBufferId] = {\n                glBuf: assertNotNull(gl.createBuffer()),\n                length: array.length,\n            };\n        }\n        else {\n            buf.length = array.length;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.glBuf);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    allocVao(vaoId, shaderId, geomIbId, geomVbId, instVbId) {\n        const gl = this.gl;\n        const oldVao = this.vaos[vaoId];\n        if (oldVao) {\n            this.OESVertexArrayObject.deleteVertexArrayOES(oldVao.glVao);\n        }\n        const glVao = assertNotNull(this.OESVertexArrayObject.createVertexArrayOES());\n        const vao = (this.vaos[vaoId] = { glVao, geomIbId, geomVbId, instVbId });\n        this.OESVertexArrayObject.bindVertexArrayOES(vao.glVao);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffers[geomVbId].glBuf);\n        const shader = this.shaders[shaderId];\n        for (let i = 0; i < shader.geomAttribs.length; i++) {\n            const attr = shader.geomAttribs[i];\n            if (attr.loc < 0) {\n                continue;\n            }\n            gl.vertexAttribPointer(attr.loc, attr.size, gl.FLOAT, false, attr.stride, attr.offset);\n            gl.enableVertexAttribArray(attr.loc);\n            this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(attr.loc, 0);\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffers[instVbId].glBuf);\n        for (let i = 0; i < shader.instAttribs.length; i++) {\n            const attr = shader.instAttribs[i];\n            if (attr.loc < 0) {\n                continue;\n            }\n            gl.vertexAttribPointer(attr.loc, attr.size, gl.FLOAT, false, attr.stride, attr.offset);\n            gl.enableVertexAttribArray(attr.loc);\n            this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(attr.loc, 1);\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffers[geomIbId].glBuf);\n        this.OESVertexArrayObject.bindVertexArrayOES(null);\n    }\n    drawCall(shaderId, vaoId, passUniformsPtr, viewUniformsPtr, drawUniformsPtr, userUniformsPtr, texturesPtr) {\n        const gl = this.gl;\n        const shader = this.shaders[shaderId];\n        gl.useProgram(shader.program);\n        const vao = this.vaos[vaoId];\n        this.OESVertexArrayObject.bindVertexArrayOES(vao.glVao);\n        const indexBuffer = this.indexBuffers[vao.geomIbId];\n        const instanceBuffer = this.arrayBuffers[vao.instVbId];\n        // set up uniforms TODO do this a bit more incremental based on uniform layer\n        // also possibly use webGL2 uniform buffers. For now this will suffice for webGL 1 compat\n        const passUniforms = shader.passUniforms;\n        // if vr_presenting\n        const viewUniforms = shader.viewUniforms;\n        for (let i = 0; i < viewUniforms.length; i++) {\n            const uni = viewUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + viewUniformsPtr);\n        }\n        const drawUniforms = shader.drawUniforms;\n        for (let i = 0; i < drawUniforms.length; i++) {\n            const uni = drawUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + drawUniformsPtr);\n        }\n        const userUniforms = shader.userUniforms;\n        for (let i = 0; i < userUniforms.length; i++) {\n            const uni = userUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + userUniformsPtr);\n        }\n        const textureSlots = shader.textureSlots;\n        for (let i = 0; i < textureSlots.length; i++) {\n            const texSlot = textureSlots[i];\n            const texId = this.baseu32[(texturesPtr >> 2) + i];\n            const texObj = this.textures[texId];\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, texObj);\n            gl.uniform1i(texSlot.loc, i);\n        }\n        const indices = indexBuffer.length;\n        const instances = instanceBuffer.length / shader.instanceSlots;\n        // if (this.isMainCanvas && xrIsPresenting) {\n        // for (let i = 3; i < pass_uniforms.length; i ++) {\n        //     let uni = pass_uniforms[i];\n        //     uni.fn(this, uni.loc, uni.offset + pass_uniforms_ptr);\n        // }\n        // // the first 2 matrices are project and view\n        // let left_viewport = this.xr_left_viewport;\n        // gl.viewport(left_viewport.x, left_viewport.y, left_viewport.width, left_viewport.height);\n        // gl.uniformMatrix4fv(pass_uniforms[0].loc, false, this.xr_left_projection_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[1].loc, false, this.xr_left_transform_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[2].loc, false, this.xr_left_invtransform_matrix);\n        // this.ANGLE_instanced_arrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // let right_viewport = this.xr_right_viewport;\n        // gl.viewport(right_viewport.x, right_viewport.y, right_viewport.width, right_viewport.height);\n        // gl.uniformMatrix4fv(pass_uniforms[0].loc, false, this.xr_right_projection_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[1].loc, false, this.xr_right_transform_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[2].loc, false, this.xr_right_invtransform_matrix);\n        // this.ANGLE_instanced_arrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // } else {\n        for (let i = 0; i < passUniforms.length; i++) {\n            const uni = passUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + passUniformsPtr);\n        }\n        this.ANGLEInstancedArrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // }\n        this.OESVertexArrayObject.bindVertexArrayOES(null);\n    }\n    allocTexture(textureId, width, height, dataPtr) {\n        const gl = this.gl;\n        const glTex = this.textures[textureId] || gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, glTex);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        const data = new Uint8Array(this.memory.buffer, dataPtr, width * height * 4);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        this.textures[textureId] = glTex;\n    }\n    beginRenderTargets(passId, width, height) {\n        const gl = this.gl;\n        this.targetWidth = width;\n        this.targetHeight = height;\n        this.clearFlags = 0;\n        // this.isMainCanvas = false;\n        const glFramebuffer = this.framebuffers[passId] ||\n            (this.framebuffers[passId] = assertNotNull(gl.createFramebuffer()));\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glFramebuffer);\n    }\n    addColorTarget(textureId, initOnly, r, g, b, a) {\n        // if use_default\n        this.clearR = r;\n        this.clearG = g;\n        this.clearB = b;\n        this.clearA = a;\n        const gl = this.gl;\n        const glTex = this.textures[textureId] ||\n            (this.textures[textureId] = gl.createTexture());\n        // resize or create texture\n        if (glTex.mpWidth != this.targetWidth ||\n            glTex.mpHeight != this.targetHeight) {\n            gl.bindTexture(gl.TEXTURE_2D, glTex);\n            this.clearFlags |= gl.COLOR_BUFFER_BIT;\n            glTex.mpWidth = this.targetWidth;\n            glTex.mpHeight = this.targetHeight;\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, glTex.mpWidth, glTex.mpHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n        else if (!initOnly) {\n            this.clearFlags |= gl.COLOR_BUFFER_BIT;\n        }\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTex, 0);\n    }\n    setDepthTarget(textureId, initOnly, depth) {\n        const gl = this.gl;\n        this.clearDepth = depth;\n        const glRenderBuffer = this.textures[textureId] ||\n            (this.textures[textureId] = gl.createRenderbuffer());\n        if (glRenderBuffer.mpWidth != this.targetWidth ||\n            glRenderBuffer.mpHeight != this.targetHeight) {\n            // Borrowed concept from https://webglfundamentals.org/webgl/lessons/webgl-render-to-texture.html\n            gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderBuffer);\n            this.clearFlags |= gl.DEPTH_BUFFER_BIT;\n            glRenderBuffer.mpWidth = this.targetWidth;\n            glRenderBuffer.mpHeight = this.targetHeight;\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.targetWidth, this.targetHeight);\n        }\n        else if (!initOnly) {\n            this.clearFlags |= gl.DEPTH_BUFFER_BIT;\n        }\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, glRenderBuffer);\n    }\n    endRenderTargets() {\n        const gl = this.gl;\n        // process the actual 'clear'\n        gl.viewport(0, 0, this.targetWidth, this.targetHeight);\n        // check if we need to clear color, and depth\n        // clear it\n        if (this.clearFlags) {\n            gl.clearColor(this.clearR, this.clearG, this.clearB, this.clearA);\n            gl.clearDepth(this.clearDepth);\n            gl.clear(this.clearFlags);\n        }\n    }\n    setDefaultDepthAndBlendMode() {\n        const gl = this.gl;\n        gl.enable(gl.DEPTH_TEST);\n        gl.depthFunc(gl.LEQUAL);\n        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n    }\n    beginMainCanvas(r, g, b, a, depth) {\n        const gl = this.gl;\n        // this.isMainCanvas = true;\n        // if (this.xrIsPresenting) {\n        // let xr_webgllayer = this.xr_session.renderState.baseLayer;\n        // this.gl.bindFramebuffer(gl.FRAMEBUFFER, xr_webgllayer.framebuffer);\n        // gl.viewport(0, 0, xr_webgllayer.framebufferWidth, xr_webgllayer.framebufferHeight);\n        // // quest 1 is 3648\n        // // quest 2 is 4096\n        // let left_view = this.xr_pose.views[0];\n        // let right_view = this.xr_pose.views[1];\n        // this.xr_left_viewport = xr_webgllayer.getViewport(left_view);\n        // this.xr_right_viewport = xr_webgllayer.getViewport(right_view);\n        // this.xr_left_projection_matrix = left_view.projectionMatrix;\n        // this.xr_left_transform_matrix = left_view.transform.inverse.matrix;\n        // this.xr_left_invtransform_matrix = left_view.transform.matrix;\n        // this.xr_right_projection_matrix = right_view.projectionMatrix;\n        // this.xr_right_transform_matrix = right_view.transform.inverse.matrix;\n        // this.xr_right_camera_pos = right_view.transform.inverse.position;\n        // this.xr_right_invtransform_matrix = right_view.transform.matrix;\n        // } else {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, this.sizingData.width * this.sizingData.dpiFactor, this.sizingData.height * this.sizingData.dpiFactor);\n        // }\n        gl.clearColor(r, g, b, a);\n        gl.clearDepth(depth);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    }\n}\nconst uniformSizeTable = {\n    float: 1,\n    vec2: 2,\n    vec3: 3,\n    vec4: 4,\n    mat2: 4,\n    mat3: 9,\n    mat4: 16,\n};\nfunction addLineNumbersToString(code) {\n    const lines = code.split(\"\\n\");\n    let out = \"\";\n    for (let i = 0; i < lines.length; i++) {\n        out += i + 1 + \": \" + lines[i] + \"\\n\";\n    }\n    return out;\n}\n","export function addDefaultStyles() {\n    const style = document.createElement(\"style\");\n    style.innerHTML = `\n  * {\n    user-select: none;\n  }\n  html, body {\n    overflow: hidden;\n    background-color: #333;\n  }\n  body {\n    margin: 0;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n  }\n\n  #zaplib_js_root {\n    position: absolute; /* For z-index */\n    z-index: 0; /* New stacking context */\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    pointer-events: none;\n  }`;\n    document.body.appendChild(style);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// Import workers inline, so you can just include a single file \"wasm_runtime.js\"\n// without having to worry about having to serve multiple chunks.\n// @ts-ignore\nimport MainWorker from \"worker-loader?inline=no-fallback!./main_worker\";\n// @ts-ignore\nimport AsyncWorker from \"worker-loader?inline=no-fallback!./async_worker\";\n// @ts-ignore\nimport TaskWorker from \"worker-loader?inline=no-fallback!./task_worker\";\nimport { getZapBufferWasm, isZapBuffer, overwriteTypedArraysWithZapArrays, unregisterMutableBuffer, checkValidZapArray, } from \"./zap_buffer\";\nimport { assertNotNull, getZapParamType, initTaskWorkerSab, Rpc, transformParamsFromRustImpl, } from \"./common\";\nimport { makeTextarea } from \"./make_textarea\";\nimport { WebGLRenderer } from \"./webgl_renderer\";\nimport { makeRpcMouseEvent, makeRpcTouchEvent, makeRpcWheelEvent, } from \"./make_rpc_event\";\nimport { WorkerEvent, TaskWorkerEvent, AsyncWorkerEvent, } from \"./rpc_types\";\nimport { addLoadingIndicator, removeLoadingIndicator, } from \"./loading_indicator\";\nimport { addDefaultStyles } from \"./default_styles\";\nimport { inWorker } from \"./type_of_runtime\";\nconst jsFunctions = {};\n/// Users must call this function to register functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const registerCallJsCallbacks = (fns) => {\n    // Check that all new functions are unique\n    for (const key of Object.keys(fns)) {\n        if (key in jsFunctions) {\n            throw new Error(`Error: overwriting existing function \"${key}\" in window.jsFunctions`);\n        }\n    }\n    Object.assign(jsFunctions, fns);\n};\n/// Users must call this function to unregister functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const unregisterCallJsCallbacks = (fnNames) => {\n    for (const name of fnNames) {\n        // Check that functions are registered\n        if (!(name in jsFunctions)) {\n            throw new Error(`Error: unregistering non-existent function \"${name}\".`);\n        }\n        delete jsFunctions[name];\n    }\n};\nlet rpc;\nexport const newWorkerPort = () => {\n    const channel = new MessageChannel();\n    rpc.send(WorkerEvent.BindMainWorkerPort, channel.port1, [channel.port1]);\n    return channel.port2;\n};\nlet wasmMemory;\nconst destructor = (arcPtr) => {\n    rpc.send(WorkerEvent.DecrementArc, arcPtr);\n};\nconst mutableDestructor = (bufferData) => {\n    rpc.send(WorkerEvent.DeallocVec, bufferData);\n};\nconst transformParamsFromRust = (params) => transformParamsFromRustImpl(wasmMemory, destructor, mutableDestructor, params);\n// TODO(JP): Somewhat duplicated with the other implementation.\nconst temporarilyHeldBuffersForPostMessage = new Set();\nexport const serializeZapArrayForPostMessage = (zapArray) => {\n    if (!(typeof zapArray === \"object\" && isZapBuffer(zapArray.buffer))) {\n        throw new Error(\"Only pass Zap arrays to serializeZapArrayForPostMessage\");\n    }\n    const zapBuffer = zapArray.buffer;\n    if (zapBuffer.__zaplibBufferData.readonly) {\n        // Store the buffer temporarily until we've received confirmation that the Arc has been incremented.\n        // Otherwise it might get garbage collected and deallocated (if the Arc's count was 1) before it gets\n        // incremented.\n        temporarilyHeldBuffersForPostMessage.add(zapBuffer);\n        rpc\n            .send(WorkerEvent.IncrementArc, zapBuffer.__zaplibBufferData.arcPtr)\n            .then(() => {\n            temporarilyHeldBuffersForPostMessage.delete(zapBuffer);\n        });\n    }\n    else {\n        unregisterMutableBuffer(zapBuffer);\n    }\n    return {\n        bufferData: zapBuffer.__zaplibBufferData,\n        byteOffset: zapArray.byteOffset,\n        byteLength: zapArray.byteLength,\n    };\n};\nexport const callRust = (name, params = []) => __awaiter(void 0, void 0, void 0, function* () {\n    const transformedParams = params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else if (isZapBuffer(param.buffer)) {\n            checkValidZapArray(param);\n            return serializeZapArrayForPostMessage(param);\n        }\n        else {\n            if (!(param.buffer instanceof SharedArrayBuffer)) {\n                console.warn(\"Consider passing Uint8Arrays backed by ZapBuffer or SharedArrayBuffer into `callRust` to prevent copying data\");\n            }\n            return param;\n        }\n    });\n    return transformParamsFromRust(yield rpc.send(WorkerEvent.CallRust, { name, params: transformedParams }));\n});\nexport const createMutableBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const bufferLen = data.byteLength;\n    const bufferPtr = yield rpc.send(WorkerEvent.CreateBuffer, data, [\n        data.buffer,\n    ]);\n    return transformParamsFromRust([\n        {\n            paramType: getZapParamType(data, false),\n            bufferPtr,\n            bufferLen,\n            bufferCap: bufferLen,\n            readonly: false,\n        },\n    ])[0];\n});\nexport const createReadOnlyBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const bufferLen = data.byteLength;\n    const { bufferPtr, arcPtr } = yield rpc.send(WorkerEvent.CreateReadOnlyBuffer, data, [data.buffer]);\n    return transformParamsFromRust([\n        {\n            paramType: getZapParamType(data, true),\n            bufferPtr,\n            bufferLen,\n            arcPtr,\n            readonly: true,\n        },\n    ])[0];\n});\nexport const deserializeZapArrayFromPostMessage = (postMessageData) => {\n    const zapBuffer = getZapBufferWasm(wasmMemory, postMessageData.bufferData, destructor, mutableDestructor);\n    return new Uint8Array(zapBuffer, postMessageData.byteOffset, postMessageData.byteLength);\n};\nexport const callRustInSameThreadSync = (name, _params = []) => {\n    throw new Error(\"`callRustInSameThreadSync` is currently not supported on the main thread in WASM\");\n};\nlet alreadyCalledInitialize = false;\nexport const initialize = (initParams) => {\n    if (alreadyCalledInitialize) {\n        throw new Error(\"Only call zaplib.initialize() once\");\n    }\n    alreadyCalledInitialize = true;\n    if (inWorker) {\n        throw new Error(\"zaplib.initialize() can only be called on the browser's main thread\");\n    }\n    overwriteTypedArraysWithZapArrays();\n    return new Promise((resolve) => {\n        var _a;\n        rpc = new Rpc(new MainWorker());\n        const baseUri = (_a = initParams.baseUri) !== null && _a !== void 0 ? _a : window.location.protocol + \"//\" + window.location.host + \"/\";\n        const wasmPath = new URL(initParams.filename, baseUri).href;\n        // Safari (as of version 15.2) needs the WebAssembly Module to be compiled on the browser's\n        // main thread. This also allows us to start compiling while still waiting for the DOM to load.\n        const wasmModulePromise = WebAssembly.compileStreaming(fetch(wasmPath));\n        // TODO(JP): These file handles are only sent to a worker when it starts running;\n        // it currently can't receive any file handles added after that.\n        const fileHandles = [];\n        const loader = () => {\n            const isMobileSafari = self.navigator.platform.match(/iPhone|iPad/i);\n            const isAndroid = self.navigator.userAgent.match(/Android/i);\n            if (initParams.defaultStyles) {\n                addDefaultStyles();\n                addLoadingIndicator();\n            }\n            let rpcInitialized = false;\n            rpc.receive(WorkerEvent.ShowIncompatibleBrowserNotification, () => {\n                const span = document.createElement(\"span\");\n                span.style.color = \"white\";\n                assertNotNull(canvas.parentNode).replaceChild(span, canvas);\n                span.innerHTML =\n                    \"Sorry, we need browser support for WebGL to run<br/>Please update your browser to a more modern one<br/>Update to at least iOS 10, Safari 10, latest Chrome, Edge or Firefox<br/>Go and update and come back, your browser will be better, faster and more secure!<br/>If you are using chrome on OSX on a 2011/2012 mac please enable your GPU at: Override software rendering list:Enable (the top item) in: <a href='about://flags'>about://flags</a>. Or switch to Firefox or Safari.\";\n            });\n            // TODO(JP): See if we can instead do this when we resolve the `initialize` Promise.\n            rpc.receive(WorkerEvent.RemoveLoadingIndicators, () => {\n                if (initParams.defaultStyles) {\n                    removeLoadingIndicator();\n                }\n            });\n            rpc.receive(WorkerEvent.SetDocumentTitle, (title) => {\n                document.title = title;\n            });\n            rpc.receive(WorkerEvent.SetMouseCursor, (style) => {\n                document.body.style.cursor = style;\n            });\n            rpc.receive(WorkerEvent.Fullscreen, () => {\n                if (document.body.requestFullscreen) {\n                    document.body.requestFullscreen();\n                }\n                else if (document.body.webkitRequestFullscreen) {\n                    document.body.webkitRequestFullscreen();\n                }\n                else if (document.body.mozRequestFullscreen) {\n                    document.body.mozRequestFullscreen();\n                }\n            });\n            rpc.receive(WorkerEvent.Normalscreen, () => {\n                if (document.exitFullscreen) {\n                    document.exitFullscreen();\n                }\n                else if (document.webkitExitFullscreen) {\n                    document.webkitExitFullscreen();\n                }\n                else if (document.mozExitFullscreen) {\n                    document.mozExitFullscreen();\n                }\n            });\n            rpc.receive(WorkerEvent.TextCopyResponse, (textCopyResponse) => {\n                window.navigator.clipboard.writeText(textCopyResponse);\n            });\n            rpc.receive(WorkerEvent.EnableGlobalFileDropTarget, () => {\n                document.addEventListener(\"dragenter\", (ev) => {\n                    const dataTransfer = ev.dataTransfer;\n                    // dataTransfer isn't guaranteed to exist by spec, so it must be checked\n                    if (dataTransfer &&\n                        dataTransfer.types.length === 1 &&\n                        dataTransfer.types[0] === \"Files\") {\n                        ev.stopPropagation();\n                        ev.preventDefault();\n                        dataTransfer.dropEffect = \"copy\";\n                        if (rpcInitialized)\n                            rpc.send(WorkerEvent.DragEnter);\n                    }\n                });\n                document.addEventListener(\"dragover\", (ev) => {\n                    ev.stopPropagation();\n                    ev.preventDefault();\n                    if (rpcInitialized)\n                        rpc.send(WorkerEvent.DragOver, { x: ev.clientX, y: ev.clientY });\n                });\n                document.addEventListener(\"dragleave\", (ev) => {\n                    ev.stopPropagation();\n                    ev.preventDefault();\n                    if (rpcInitialized)\n                        rpc.send(WorkerEvent.DragLeave);\n                });\n                document.addEventListener(\"drop\", (ev) => {\n                    if (!ev.dataTransfer) {\n                        return;\n                    }\n                    const files = Array.from(ev.dataTransfer.files);\n                    if (!files.length) {\n                        return;\n                    }\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                    const fileHandlesToSend = [];\n                    for (const file of files) {\n                        const fileHandle = {\n                            id: fileHandles.length,\n                            basename: file.name,\n                            file,\n                            lastReadStart: -1,\n                            lastReadEnd: -1,\n                        };\n                        fileHandlesToSend.push(fileHandle);\n                        fileHandles.push(fileHandle);\n                    }\n                    if (rpcInitialized) {\n                        rpc.send(WorkerEvent.Drop, { fileHandles, fileHandlesToSend });\n                    }\n                });\n            });\n            rpc.receive(WorkerEvent.CallJs, ({ fnName, params }) => {\n                const fn = jsFunctions[fnName];\n                if (!fn) {\n                    console.error(`call_js with ${fnName} is not available. Have you registered it using \\`registerCallJsCallbacks\\`?`);\n                    return;\n                }\n                fn(transformParamsFromRust(params));\n            });\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"zaplib_canvas\";\n            document.body.appendChild(canvas);\n            document.addEventListener(\"contextmenu\", (event) => {\n                var _a;\n                if (event.target instanceof Element &&\n                    !((_a = document.getElementById(\"zaplib_js_root\")) === null || _a === void 0 ? void 0 : _a.contains(event.target))) {\n                    event.preventDefault();\n                }\n            });\n            document.addEventListener(\"mousedown\", (event) => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.CanvasMouseDown, makeRpcMouseEvent(event));\n            });\n            window.addEventListener(\"mouseup\", (event) => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowMouseUp, makeRpcMouseEvent(event));\n            });\n            window.addEventListener(\"mousemove\", (event) => {\n                document.body.scrollTop = 0;\n                document.body.scrollLeft = 0;\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowMouseMove, makeRpcMouseEvent(event));\n            });\n            window.addEventListener(\"mouseout\", (event) => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowMouseOut, makeRpcMouseEvent(event));\n            });\n            document.addEventListener(\"touchstart\", (event) => {\n                event.preventDefault();\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowTouchStart, makeRpcTouchEvent(event));\n            }, { passive: false });\n            window.addEventListener(\"touchmove\", (event) => {\n                event.preventDefault();\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowTouchMove, makeRpcTouchEvent(event));\n            }, { passive: false });\n            const touchEndCancelLeave = (event) => {\n                event.preventDefault();\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowTouchEndCancelLeave, makeRpcTouchEvent(event));\n            };\n            window.addEventListener(\"touchend\", touchEndCancelLeave);\n            window.addEventListener(\"touchcancel\", touchEndCancelLeave);\n            document.addEventListener(\"wheel\", (event) => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.CanvasWheel, makeRpcWheelEvent(event));\n            });\n            window.addEventListener(\"focus\", () => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowFocus);\n            });\n            window.addEventListener(\"blur\", () => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowBlur);\n            });\n            if (!isMobileSafari && !isAndroid) {\n                // mobile keyboards are unusable on a UI like this\n                const { showTextIME } = makeTextarea((taEvent) => {\n                    if (rpcInitialized)\n                        rpc.send(taEvent.type, taEvent);\n                });\n                rpc.receive(WorkerEvent.ShowTextIME, showTextIME);\n            }\n            // One of these variables should get set, depending on if\n            // the browser supports OffscreenCanvas or not.\n            let offscreenCanvas;\n            let webglRenderer;\n            function getSizingData() {\n                const canFullscreen = !!(document.fullscreenEnabled ||\n                    document.webkitFullscreenEnabled ||\n                    document.mozFullscreenEnabled);\n                const isFullscreen = !!(document.fullscreenElement ||\n                    document.webkitFullscreenElement ||\n                    document.mozFullscreenElement);\n                return {\n                    width: canvas.offsetWidth,\n                    height: canvas.offsetHeight,\n                    dpiFactor: window.devicePixelRatio,\n                    canFullscreen,\n                    isFullscreen,\n                };\n            }\n            function onScreenResize() {\n                // TODO(JP): Some day bring this back?\n                // if (is_add_to_homescreen_safari) { // extremely ugly. but whatever.\n                //     if (window.orientation == 90 || window.orientation == -90) {\n                //         h = screen.width;\n                //         w = screen.height - 90;\n                //     }\n                //     else {\n                //         w = screen.width;\n                //         h = screen.height - 80;\n                //     }\n                // }\n                const sizingData = getSizingData();\n                if (webglRenderer) {\n                    webglRenderer.resize(sizingData);\n                }\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.ScreenResize, sizingData);\n            }\n            window.addEventListener(\"resize\", () => onScreenResize());\n            window.addEventListener(\"orientationchange\", () => onScreenResize());\n            let dpiFactor = window.devicePixelRatio;\n            const mqString = \"(resolution: \" + window.devicePixelRatio + \"dppx)\";\n            const mq = matchMedia(mqString);\n            if (mq && mq.addEventListener) {\n                mq.addEventListener(\"change\", () => onScreenResize());\n            }\n            else {\n                // poll for it. yes. its terrible\n                self.setInterval(() => {\n                    if (window.devicePixelRatio != dpiFactor) {\n                        dpiFactor = window.devicePixelRatio;\n                        onScreenResize();\n                    }\n                }, 1000);\n            }\n            // Some browsers (e.g. Safari 15.2) require SharedArrayBuffers to be initialized\n            // on the browser's main thread; so that's why this has to happen here.\n            //\n            // We also do this before initializing `WebAssembly.Memory`, to make sure we have\n            // enough memory for both.. (This is mostly relevant on mobile; see note below.)\n            const taskWorkerSab = initTaskWorkerSab();\n            const taskWorkerRpc = new Rpc(new TaskWorker());\n            taskWorkerRpc.send(TaskWorkerEvent.Init, {\n                taskWorkerSab,\n                wasmMemory,\n            });\n            // Initial has to be equal to or higher than required by the app (which at the time of writing\n            // is around 20 pages).\n            // Maximum has to be equal to or lower than that of the app, which we've currently set to\n            // the maximum for wasm32 (4GB). Browsers should use virtual memory, as to not actually take up\n            // all this space until requested by the app. TODO(JP): We might need to check this behavior in\n            // different browsers at some point (in Chrome it seems to work fine).\n            //\n            // In Safari on my phone (JP), using maximum:65535 causes an out-of-memory error, so we instead\n            // try a hardcoded value of ~400MB.. Note that especially on mobile, all of\n            // this is quite tricky; see e.g. https://github.com/WebAssembly/design/issues/1397\n            //\n            // TODO(JP): It looks like when using shared memory, the maximum might get fully allocated on\n            // some devices (mobile?), which means that there is little room left for JS objects, and it\n            // means that the web page is at higher risk of getting evicted when switching tabs. There are a\n            // few options here:\n            // 1. Allow the user to specify a maximum by hand for mobile in general; or for specific\n            //    devices (cumbersome!).\n            // 2. Allow single-threaded operation, where we don't specify a maximum (but run the risk of\n            //    getting much less memory to use and therefore the app crashing; see again\n            //    https://github.com/WebAssembly/design/issues/1397 for more details).\n            try {\n                wasmMemory = new WebAssembly.Memory({\n                    initial: 40,\n                    maximum: 65535,\n                    shared: true,\n                });\n            }\n            catch (_) {\n                console.log(\"Can't allocate full WebAssembly memory; trying ~400MB\");\n                try {\n                    wasmMemory = new WebAssembly.Memory({\n                        initial: 40,\n                        maximum: 6000,\n                        shared: true,\n                    });\n                }\n                catch (_) {\n                    throw new Error(\"Can't initilialize WebAssembly memory..\");\n                }\n            }\n            // If the browser supports OffscreenCanvas, then we'll use that. Otherwise, we render on\n            // the browser's main thread using WebGLRenderer.\n            try {\n                offscreenCanvas = canvas.transferControlToOffscreen();\n            }\n            catch (_) {\n                webglRenderer = new WebGLRenderer(canvas, wasmMemory, getSizingData(), () => {\n                    rpc.send(WorkerEvent.ShowIncompatibleBrowserNotification);\n                });\n                rpc.receive(WorkerEvent.RunWebGL, (zerdeParserPtr) => {\n                    webglRenderer.processMessages(zerdeParserPtr);\n                    return new Promise((resolve) => {\n                        requestAnimationFrame(() => {\n                            resolve(undefined);\n                        });\n                    });\n                });\n            }\n            wasmModulePromise.then((wasmModule) => {\n                // Threads need to be spawned on the browser's main thread, otherwise Safari (as of version 15.2)\n                // throws errors.\n                const asyncWorkers = new Set();\n                const threadSpawn = ({ ctxPtr, tlsAndStackData, }) => {\n                    const worker = new AsyncWorker();\n                    const workerErrorHandler = (event) => {\n                        console.log(\"Async worker error event: \", event);\n                    };\n                    worker.onerror = workerErrorHandler;\n                    worker.onmessageerror = workerErrorHandler;\n                    const workerRpc = new Rpc(worker);\n                    // Add the worker to an array of workers, to prevent them getting killed when\n                    // during garbage collection in Firefox; see https://bugzilla.mozilla.org/show_bug.cgi?id=1592227\n                    asyncWorkers.add(worker);\n                    const channel = new MessageChannel();\n                    rpc.send(WorkerEvent.BindMainWorkerPort, channel.port1, [\n                        channel.port1,\n                    ]);\n                    workerRpc.receive(AsyncWorkerEvent.ThreadSpawn, threadSpawn);\n                    workerRpc\n                        .send(AsyncWorkerEvent.Run, {\n                        wasmModule,\n                        memory: wasmMemory,\n                        taskWorkerSab,\n                        ctxPtr,\n                        fileHandles,\n                        baseUri,\n                        tlsAndStackData,\n                        mainWorkerPort: channel.port2,\n                    }, [channel.port2])\n                        .catch((e) => {\n                        console.error(\"async worker failed\", e);\n                    })\n                        .finally(() => {\n                        worker.terminate();\n                        asyncWorkers.delete(worker);\n                    });\n                };\n                rpc.receive(WorkerEvent.ThreadSpawn, threadSpawn);\n                rpc\n                    .send(WorkerEvent.Init, {\n                    wasmModule,\n                    offscreenCanvas,\n                    sizingData: getSizingData(),\n                    baseUri,\n                    memory: wasmMemory,\n                    taskWorkerSab,\n                }, offscreenCanvas ? [offscreenCanvas] : [])\n                    .then(() => {\n                    rpcInitialized = true;\n                    onScreenResize();\n                    resolve();\n                });\n            });\n        };\n        if (document.readyState !== \"loading\") {\n            loader();\n        }\n        else {\n            document.addEventListener(\"DOMContentLoaded\", loader);\n        }\n    });\n};\n","import { assertNotNull } from \"./common\";\nexport function addLoadingIndicator() {\n    const style = document.createElement(\"style\");\n    style.innerHTML = `\n    .zaplib_loading_indicator {\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        color: #666;\n        font-size: 40px;\n    }\n    .zaplib_loading_indicator > span {\n        display: inline-block;\n        animation-name: wiggle;\n        animation-duration: 1000ms;\n        animation-iteration-count: infinite;\n        animation-timing-function: ease-in-out;\n    }\n    @keyframes wiggle {\n        0% {transform: rotate(0deg);}\n        10% {transform: rotate(10deg);}\n        30% {transform: rotate(-10deg);}\n        50% {transform: rotate(20deg);}\n        70% {transform: rotate(-5deg);}\n        90% {transform: rotate(2deg);}\n        95% {transform: rotate(0deg);}\n    }\n\n    .zaplib_loading_indicator > div {\n        position: absolute;\n        width: max-content;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, 40px);\n        font-family: Verdana, Arial Black;\n        font-weight: bold;\n        font-size: 28px;\n\n        background: #222 -webkit-gradient(linear, left top, right top, from(#222), to(#222), color-stop(0.5, #fff)) 0 0 no-repeat;\n        background-image: -webkit-linear-gradient(-40deg, transparent 0%, transparent 40%, #fff 50%, transparent 60%, transparent 100%);\n        background-size: 200px;\n        -webkit-background-clip: text;\n        background-clip: text;\n        animation-name: shine;\n        animation-duration: 1s;\n        animation-iteration-count: infinite;\n        text-shadow: 0 0px 0px rgba(255, 255, 255, 0.5);\n    }\n    @keyframes shine {\n        0% {\n            background-position: -200px 0;\n        }\n        100% {\n            background-position: 250px 0;\n        }\n    }`;\n    document.body.appendChild(style);\n    const loadingIndicator = document.createElement(\"div\");\n    loadingIndicator.className = \"zaplib_loading_indicator\";\n    loadingIndicator.innerHTML =\n        '<span>⚡</span><div style=\"color: rgba(255, 202, 0, 0.5);\">Loading…</div>';\n    document.body.appendChild(loadingIndicator);\n}\nexport function removeLoadingIndicator() {\n    const loaders = document.getElementsByClassName(\"zaplib_loading_indicator\");\n    for (let i = 0; i < loaders.length; i++) {\n        assertNotNull(loaders[i].parentNode).removeChild(loaders[i]);\n    }\n}\n","// Be sure to keep this in sync with cursor.rs!\nexport const cursorMap = [\n    \"none\",\n    \"default\",\n    \"crosshair\",\n    \"pointer\",\n    \"default\",\n    \"move\",\n    \"text\",\n    \"wait\",\n    \"help\",\n    \"not-allowed\",\n    \"n-resize\",\n    \"ne-resize\",\n    \"e-resize\",\n    \"se-resize\",\n    \"s-resize\",\n    \"sw-resize\",\n    \"w-resize\",\n    \"nw-resize\",\n    \"ns-resize\",\n    \"nesw-resize\",\n    \"ew-resize\",\n    \"nwse-resize\",\n    \"col-resize\",\n    \"row-resize\", // RowResize=>23,\n];\n","export function packKeyModifier(e) {\n    return ((e.shiftKey ? 1 : 0) |\n        (e.ctrlKey ? 2 : 0) |\n        (e.altKey ? 4 : 0) |\n        (e.metaKey ? 8 : 0));\n}\nexport const zerdeKeyboardHandlers = {\n    keyDown(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(12);\n        zerdeBuilder.sendU32(data.event.keyCode);\n        zerdeBuilder.sendU32(data.event.repeat ? 1 : 0);\n        zerdeBuilder.sendU32(packKeyModifier(data.event));\n        zerdeBuilder.sendF64(performance.now() / 1000.0);\n    },\n    keyUp(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(13);\n        zerdeBuilder.sendU32(data.event.keyCode);\n        zerdeBuilder.sendU32(data.event.repeat ? 1 : 0);\n        zerdeBuilder.sendU32(packKeyModifier(data.event));\n        zerdeBuilder.sendF64(performance.now() / 1000.0);\n    },\n    textInput(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(14);\n        zerdeBuilder.sendU32(data.wasPaste ? 1 : 0),\n            zerdeBuilder.sendU32(data.replaceLast ? 1 : 0),\n            zerdeBuilder.sendString(data.input);\n    },\n    textCopy(zerdeBuilder) {\n        zerdeBuilder.sendU32(17);\n    },\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { cursorMap } from \"./cursor_map\";\nimport { copyArrayToRustBuffer, getZapParamType } from \"./common\";\nimport { makeTextarea } from \"./make_textarea\";\nimport { ZapParamType, } from \"./types\";\nimport { getCachedZapBuffer, overwriteTypedArraysWithZapArrays, isZapBuffer, checkValidZapArray, getZapBufferCef, } from \"./zap_buffer\";\nimport { ZerdeBuilder } from \"./zerde\";\nimport { zerdeKeyboardHandlers } from \"./zerde_keyboard_handlers\";\nimport { WorkerEvent } from \"./rpc_types\";\nimport { addDefaultStyles } from \"./default_styles\";\nlet newCallbackId = 0;\n// keeping track of pending callbacks from rust side\nconst pendingCallbacks = {};\nconst transformParamsForRust = (params) => params.map((param) => {\n    if (typeof param === \"string\") {\n        return param;\n    }\n    else {\n        if (isZapBuffer(param.buffer)) {\n            checkValidZapArray(param);\n            const zapBuffer = param.buffer;\n            return [\n                zapBuffer.__zaplibWasmBuffer,\n                getZapParamType(param, zapBuffer.readonly),\n            ];\n        }\n        const paramType = getZapParamType(param, false);\n        const [cefBuffer] = window.cefCreateArrayBuffer(param.length, paramType);\n        // TODO(Dmitry): implement optimization to avoid copying when possible\n        copyArrayToRustBuffer(param, cefBuffer, 0);\n        return [cefBuffer, paramType];\n    }\n});\nexport const callRust = (name, params = []) => {\n    const callbackId = newCallbackId++;\n    const promise = new Promise((resolve, _reject) => {\n        pendingCallbacks[callbackId] = (data) => {\n            // TODO(Dmitry): implement retrun_error on rust side and use reject(...) to communicate the error\n            resolve(data);\n        };\n    });\n    window.cefCallRust(name, transformParamsForRust(params), callbackId);\n    return promise;\n};\nfunction _zaplibReturnParams(params) {\n    const callbackId = JSON.parse(params[0]);\n    pendingCallbacks[callbackId](params.slice(1));\n    delete pendingCallbacks[callbackId];\n}\n// Initial set of framework-specific functions\nconst fromCefJsFunctions = {\n    _zaplibReturnParams,\n};\n/// Users must call this function to register functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const registerCallJsCallbacks = (fns) => {\n    // Check that all new functions are unique\n    for (const key of Object.keys(fns)) {\n        if (key in fromCefJsFunctions) {\n            throw new Error(`Error: overwriting existing function \"${key}\"`);\n        }\n    }\n    Object.assign(fromCefJsFunctions, fns);\n    window.cefReadyForMessages();\n};\n/// Users must call this function to unregister functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const unregisterCallJsCallbacks = (fnNames) => {\n    fnNames.forEach((name) => {\n        // Check that functions are registered\n        if (!(name in fromCefJsFunctions)) {\n            throw new Error(`Error: unregistering non-existent function \"${name}\"`);\n        }\n        delete fromCefJsFunctions[name];\n    });\n};\nconst transformReturnParams = (returnParams) => returnParams.map((param) => {\n    if (typeof param === \"string\") {\n        return param;\n    }\n    else {\n        const [buffer, arcPtr, paramType] = param;\n        const zapBuffer = getZapBufferCef(buffer, arcPtr, paramType);\n        if (paramType === ZapParamType.String) {\n            throw new Error(\"ZapParam buffer type called with string paramType\");\n        }\n        // These are actually ZapArray types, since we overwrite TypedArrays in overwriteTypedArraysWithZapArrays()\n        const ParamTypeToArrayConstructor = {\n            [ZapParamType.U8Buffer]: Uint8Array,\n            [ZapParamType.ReadOnlyU8Buffer]: Uint8Array,\n            [ZapParamType.F32Buffer]: Float32Array,\n            [ZapParamType.ReadOnlyF32Buffer]: Float32Array,\n        };\n        // Creating array with stable identity as that's what underlying underlying API expects\n        return getCachedZapBuffer(zapBuffer, new ParamTypeToArrayConstructor[paramType](zapBuffer));\n    }\n});\n// TODO(JP): Some of this code is duplicated with callRust/call_js; see if we can reuse some.\nexport const callRustInSameThreadSync = (name, params = []) => transformReturnParams(window.cefCallRustInSameThreadSync(name, transformParamsForRust(params)));\nexport const newWorkerPort = () => {\n    throw new Error(\"`newWorkerPort` is currently not supported on CEF\");\n};\nexport const serializeZapArrayForPostMessage = (_postMessageData) => {\n    throw new Error(\"`serializeZapArrayForPostMessage` is currently not supported on CEF\");\n};\nexport const deserializeZapArrayFromPostMessage = (_postMessageData) => {\n    throw new Error(\"`deserializeZapArrayFromPostMessage` is currently not supported on CEF\");\n};\nexport const initialize = (initParams) => new Promise((resolve) => {\n    overwriteTypedArraysWithZapArrays();\n    window.fromCefSetMouseCursor = (cursorId) => {\n        if (document.body) {\n            document.body.style.cursor = cursorMap[cursorId] || \"default\";\n        }\n    };\n    window.fromCefCallJsFunction = (name, params) => {\n        fromCefJsFunctions[name](transformReturnParams(params));\n    };\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        if (initParams.defaultStyles) {\n            addDefaultStyles();\n        }\n        const { showTextIME, textareaHasFocus } = makeTextarea((taEvent) => {\n            const slots = 20;\n            const [buffer] = window.cefCreateArrayBuffer(slots * 4, ZapParamType.U8Buffer);\n            const zerdeBuilder = new ZerdeBuilder({\n                buffer,\n                byteOffset: 0,\n                slots,\n                growCallback: () => {\n                    throw new Error(\"Growing of this buffer is not supported\");\n                },\n            });\n            if (taEvent.type === WorkerEvent.KeyDown) {\n                zerdeKeyboardHandlers.keyDown(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === WorkerEvent.KeyUp) {\n                zerdeKeyboardHandlers.keyUp(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === WorkerEvent.TextInput) {\n                zerdeKeyboardHandlers.textInput(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === WorkerEvent.TextCopy) {\n                zerdeKeyboardHandlers.textCopy(zerdeBuilder);\n            }\n            window.cefHandleKeyboardEvent(buffer);\n        });\n        window.fromCefSetIMEPosition = (x, y) => {\n            showTextIME({ x, y });\n        };\n        document.addEventListener(\"keydown\", (event) => {\n            const code = event.keyCode;\n            if (event.metaKey || event.ctrlKey) {\n                if (!textareaHasFocus()) {\n                    // TODO(JP): Maybe at some point we should use some library for these keycodes,\n                    // e.g. see https://stackoverflow.com/questions/1465374/event-keycode-constants\n                    if (code == 67 /* c */) {\n                        window.cefTriggerCopy();\n                    }\n                    else if (code == 88 /* x */) {\n                        window.cefTriggerCut();\n                    }\n                    else if (code == 65 /* a */) {\n                        window.cefTriggerSelectAll();\n                    }\n                }\n                // We want pastes to also be triggered when the textarea has focus, so we can\n                // handle the paste event in JS.\n                if (code == 86 /* v */) {\n                    window.cefTriggerPaste();\n                }\n            }\n        });\n        resolve();\n    });\n});\n// TODO(JP): See comment at CreateBuffer type.\nexport const createMutableBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const paramType = getZapParamType(data, false);\n    const [cefBuffer] = window.cefCreateArrayBuffer(data.length, paramType);\n    copyArrayToRustBuffer(data, cefBuffer, 0);\n    return transformReturnParams([\n        [cefBuffer, undefined, paramType],\n    ])[0];\n});\n// TODO(JP): See comment at CreateBuffer type.\nexport const createReadOnlyBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const paramType = getZapParamType(data, true);\n    const [cefBuffer, arcPtr] = window.cefCreateArrayBuffer(data.length, paramType);\n    copyArrayToRustBuffer(data, cefBuffer, 0);\n    return transformReturnParams([\n        [cefBuffer, arcPtr, paramType],\n    ])[0];\n});\n","\n      import API from \"!./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!./node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!./node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!./node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!./node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!./node_modules/css-loader/dist/cjs.js!./zaplib.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!./node_modules/css-loader/dist/cjs.js!./zaplib.css\";\n       export default content && content.locals ? content.locals : undefined;\n","// This is the universal Zaplib Runtime which will work on both CEF and WebAssembly environments,\n// doing runtime detection of which modules to load. No other file besides this one should conditionally\n// branch based on environments, such that cef/wasm runtimes can work without including unnecessary code.\nimport * as wasm from \"./wasm_runtime\";\nimport * as cef from \"./cef_runtime\";\nimport { jsRuntime } from \"./type_of_runtime\";\nimport \"./zaplib.css\";\nconst { initialize, newWorkerPort, registerCallJsCallbacks, unregisterCallJsCallbacks, callRust, serializeZapArrayForPostMessage, deserializeZapArrayFromPostMessage, callRustInSameThreadSync, createMutableBuffer, createReadOnlyBuffer, } = jsRuntime === \"cef\" ? cef : wasm;\nexport { initialize, newWorkerPort, registerCallJsCallbacks, unregisterCallJsCallbacks, callRust, serializeZapArrayForPostMessage, deserializeZapArrayFromPostMessage, callRustInSameThreadSync, jsRuntime, createMutableBuffer, createReadOnlyBuffer, };\n","// Zerde is our lightweight manual serialization/deserialization system.\n//\n// Keep in sync with zerde.rs, and see there for more information.\nimport { ZapParamType } from \"./types\";\n// Construct a buffer that can be read in Rust, using the corresponding `ZerderParser` struct in Rust.\nexport class ZerdeBuilder {\n    constructor({ buffer, byteOffset, slots, growCallback, }) {\n        this._buffer = buffer;\n        this._byteOffset = byteOffset;\n        this._slots = slots;\n        this._growCallback = growCallback;\n        this._used = 2; // Skip 8 byte header which contains the size.\n        this._updateRefs();\n    }\n    _updateRefs() {\n        this._f32 = new Float32Array(this._buffer, this._byteOffset, this._slots);\n        this._u32 = new Uint32Array(this._buffer, this._byteOffset, this._slots);\n        this._f64 = new Float64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64 = new BigUint64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64[0] = BigInt(this._slots) * BigInt(4); // Write size to header.\n    }\n    _fit(slots) {\n        if (this._used + slots > this._slots) {\n            let newSlots = Math.max(this._used + slots, this._slots * 2); // Exponential growth\n            if (newSlots & 1)\n                newSlots++; // 64-bit align it\n            const newBytes = newSlots * 4;\n            const { buffer, byteOffset } = this._growCallback(this._buffer, this._byteOffset, newBytes);\n            this._buffer = buffer;\n            this._byteOffset = byteOffset;\n            this._slots = newSlots;\n            this._updateRefs();\n        }\n        const pos = this._used;\n        this._used += slots;\n        return pos;\n    }\n    sendF32(value) {\n        const pos = this._fit(1);\n        this._f32[pos] = value;\n    }\n    sendU32(value) {\n        const pos = this._fit(1);\n        this._u32[pos] = value;\n    }\n    sendF64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._f64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._f64[pos >> 1] = value;\n        }\n    }\n    sendU64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._u64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._u64[pos >> 1] = value;\n        }\n    }\n    sendString(str) {\n        let pos = this._fit(str.length + 1);\n        this._u32[pos++] = str.length;\n        for (let i = 0; i < str.length; i++) {\n            this._u32[pos++] = str.charCodeAt(i);\n        }\n    }\n    getData() {\n        return { buffer: this._buffer, byteOffset: this._byteOffset };\n    }\n}\nexport class ZerdeParser {\n    constructor(memory, zerdePtr) {\n        this._memory = memory;\n        // set up local shortcuts to the zerde memory chunk for faster parsing\n        this._usedSlots = 2; // skip the 8 byte header\n        this._f32 = new Float32Array(this._memory.buffer, zerdePtr);\n        this._u32 = new Uint32Array(this._memory.buffer, zerdePtr);\n        this._f64 = new Float64Array(this._memory.buffer, zerdePtr);\n        this._u64 = new BigUint64Array(this._memory.buffer, zerdePtr);\n    }\n    parseU32() {\n        return this._u32[this._usedSlots++];\n    }\n    parseF32() {\n        return this._f32[this._usedSlots++];\n    }\n    parseF64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._f64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseU64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._u64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseString() {\n        let str = \"\";\n        const len = this.parseU32();\n        for (let i = 0; i < len; i++) {\n            const c = this.parseU32();\n            if (c != 0)\n                str += String.fromCharCode(c);\n        }\n        return str;\n    }\n    parseU8Slice() {\n        const u8Len = this.parseU32();\n        const len = u8Len >> 2;\n        const data = new Uint8Array(u8Len);\n        const spare = u8Len & 3;\n        for (let i = 0; i < len; i++) {\n            const u8Pos = i << 2;\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n            data[u8Pos + 3] = (u32 >> 24) & 0xff;\n        }\n        const u8Pos = len << 2;\n        if (spare == 1) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n        }\n        else if (spare == 2) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n        }\n        else if (spare == 3) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n        }\n        return data;\n    }\n    parseZapParams() {\n        const len = this.parseU32();\n        const params = [];\n        for (let i = 0; i < len; ++i) {\n            const paramType = this.parseU32();\n            if (paramType === ZapParamType.String) {\n                params.push(this.parseString());\n            }\n            else if (paramType === ZapParamType.ReadOnlyU8Buffer ||\n                paramType === ZapParamType.ReadOnlyF32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const arcPtr = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    arcPtr,\n                    readonly: true,\n                });\n            }\n            else if (paramType === ZapParamType.U8Buffer ||\n                paramType === ZapParamType.F32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const bufferCap = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    bufferCap,\n                    readonly: false,\n                });\n            }\n            else {\n                throw new Error(`Unknown ZapParam type: ${paramType}`);\n            }\n        }\n        return params;\n    }\n}\n","\"use strict\";\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { ZapParamType } from \"./types\";\nimport { ZapBuffer, classesToExtend, containsZapBuffer } from \"./zap_buffer\";\nimport { expect, expectThrow } from \"./test_helpers\";\nconst { ZapUint8Array, ZapUint16Array } = window;\n// Test that ZapArray is created like a DataView\nfunction testBuffer() {\n    const wasmMemory = new SharedArrayBuffer(1024);\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 10,\n        bufferLen: 4,\n        bufferCap: 4,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const a = new ZapUint8Array(buffer, 10, 4);\n    expect(a.byteOffset, 10);\n    expect(a.length, 4);\n}\n// Test that new ZapArray shares the same ZapBuffer\nfunction testShare() {\n    const wasmMemory = new SharedArrayBuffer(1024);\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 0,\n        bufferLen: 1024,\n        bufferCap: 1024,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const a = new ZapUint8Array(buffer);\n    const b = new ZapUint16Array(a.buffer);\n    expect(a.buffer, buffer);\n    expect(a.buffer, b.buffer);\n}\n// Test ZapArray out-of-bounds behavior\nfunction testOutOfBounds() {\n    const wasmMemory = new SharedArrayBuffer(1024);\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 1,\n        bufferLen: 16,\n        bufferCap: 16,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    // start is outside of the view - should throw\n    expectThrow(() => {\n        new ZapUint8Array(buffer, 0);\n    }, \"Byte_offset 0 is out of bounds\");\n    // these doesn't throw but overwrites the end of the data\n    const a = new ZapUint8Array(buffer, 1);\n    expect(a.length, 16);\n    const b = new ZapUint8Array(buffer, 2);\n    expect(b.length, 15);\n    // end is outside of the view - should throw\n    expectThrow(() => {\n        new ZapUint8Array(buffer, 15, 3);\n    }, \"Byte_offset 15 + length 3 is out of bounds\");\n}\n// Test that ZapBuffer and ZapArray could be created from ArrayBuffer\nfunction testArrayBuffer() {\n    const array = new ArrayBuffer(16);\n    const buffer = new ZapBuffer(array, {\n        bufferPtr: 0,\n        bufferLen: array.byteLength,\n        bufferCap: array.byteLength,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const a = new ZapUint8Array(buffer);\n    expect(a.byteOffset, 0);\n    expect(a.byteLength, 16);\n}\n// Check that all names follow the convetion of having Zap as prefix\n// e.g. ZapUint8Array overrides Uint8Array\nfunction testZapNameMatches() {\n    for (const [cls, zapCls] of Object.entries(classesToExtend)) {\n        const expectedName = \"Zap\" + cls;\n        expect(expectedName, zapCls);\n    }\n}\nfunction testSubarray() {\n    const wasmMemory = new SharedArrayBuffer(5);\n    const regularArray = new Uint8Array(wasmMemory);\n    regularArray.set(Uint8Array.from([0, 1, 2, 3, 4]));\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 0,\n        bufferLen: 5,\n        bufferCap: 5,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const zapArray = new ZapUint8Array(buffer);\n    expect(zapArray.subarray().buffer, buffer);\n    expect(zapArray.subarray().toString(), regularArray.subarray().toString());\n    expect(zapArray.subarray(1, 3).toString(), regularArray.subarray(1, 3).toString());\n    expect(zapArray.subarray(-2, 0).toString(), regularArray.subarray(-2, 0).toString());\n    expect(zapArray.subarray(-3, -1).toString(), regularArray.subarray(-3, -1).toString());\n    expect(zapArray.subarray(1, -1).toString(), regularArray.subarray(1, -1).toString());\n}\nfunction testContainsZapBuffer() {\n    const wasmMemory = new SharedArrayBuffer(16);\n    const buffer = new ZapBuffer(wasmMemory, {\n        bufferPtr: 0,\n        bufferLen: 16,\n        bufferCap: 16,\n        paramType: ZapParamType.U8Buffer,\n        readonly: false,\n    });\n    const a = new ZapUint8Array(buffer);\n    expect(containsZapBuffer(a), true);\n    expect(containsZapBuffer([a]), true);\n    expect(containsZapBuffer({ key: a }), true);\n    expect(containsZapBuffer(new Set([a])), true);\n    const map = new Map();\n    map.set(\"key\", a);\n    expect(containsZapBuffer(map), true);\n    // calling slice removes the error\n    expect(containsZapBuffer(a.slice()), false);\n    // edge cases\n    expect(containsZapBuffer(undefined), false);\n    expect(containsZapBuffer(null), false);\n}\nexport const zapBufferTests = {\n    testBuffer,\n    testShare,\n    testOutOfBounds,\n    testZapNameMatches,\n    testArrayBuffer,\n    testSubarray,\n    testContainsZapBuffer,\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// @ts-ignore\nimport TestSuiteWorker from \"worker-loader?inline=no-fallback!./test_suite_worker\";\nimport { assertNotNull, Rpc } from \"./common\";\nimport { zapBufferTests } from \"./zap_buffer.test\";\nimport * as zaplib from \"./zaplib_runtime\";\nimport { expect, expectDeallocationOrUnregister as _expectDeallocationOrUnregister, expectThrowAsync, setInTest, } from \"./test_helpers\";\nimport { inWorker } from \"./type_of_runtime\";\nconst expectDeallocationOrUnregister = (buffer) => _expectDeallocationOrUnregister(zaplib.callRust, buffer);\nconst rpc = new Rpc(new TestSuiteWorker());\nconst runWorkerTest = (testName) => () => rpc.send(\"runTest\", testName);\nconst env = new URL(window.document.location.toString()).searchParams.has(\"release\")\n    ? \"release\"\n    : \"debug\";\nzaplib\n    .initialize({\n    filename: `target/wasm32-unknown-unknown/${env}/test_suite.wasm`,\n    defaultStyles: true,\n})\n    .then(() => {\n    // Initialize the worker by sending a \"zap worker port\" to it in the first message.\n    if (zaplib.jsRuntime === \"wasm\") {\n        const zapWorkerPort = zaplib.newWorkerPort();\n        rpc.send(\"initWasm\", zapWorkerPort, [zapWorkerPort]);\n    }\n    zaplib.registerCallJsCallbacks({\n        log(params) {\n            console.log(\"log fn called\", params[0]);\n            const div = document.createElement(\"div\");\n            div.innerText = \"log fn called: \" + params[0];\n            assertNotNull(document.getElementById(\"root\")).append(div);\n        },\n        sendWorker(params) {\n            const toSend = params[0];\n            console.log(\"sending data\", toSend);\n            // Note: uncomment to see the error about sending typed arrays\n            // worker.postMessage(buffers[0]);\n            rpc.send(\"sendWorker\", zaplib.serializeZapArrayForPostMessage(toSend));\n        },\n    });\n    const runtimeSpecificTests = zaplib.jsRuntime === \"wasm\"\n        ? {\n            \"Call rust from worker\": runWorkerTest(\"testCallRustFromWorker\"),\n            \"Call rust (no return) from worker\": runWorkerTest(\"testCallRustNoReturnFromWorker\"),\n            \"Call rust with Float32Array from worker\": runWorkerTest(\"testCallRustFloat32ArrayFromWorker\"),\n            \"Call rust in same thread sync with Float32Array from worker\": runWorkerTest(\"testCallRustInSameThreadSyncFloat32ArrayFromWorker\"),\n            \"Test that for a worker 'inWorker' returns true\": runWorkerTest(\"testInWorker\"),\n            \"Send zap array to main thread\": () => __awaiter(void 0, void 0, void 0, function* () {\n                const result = yield rpc.send(\"testSendZapArrayToMainThread\");\n                const array = zaplib.deserializeZapArrayFromPostMessage(result.array);\n                const subarray = zaplib.deserializeZapArrayFromPostMessage(result.subarray);\n                expect(array.length, 4);\n                expect(array[0], 30);\n                expect(array[1], 40);\n                expect(array[2], 50);\n                expect(array[3], 60);\n                expect(subarray.length, 2);\n                expect(subarray[0], 40);\n                expect(subarray[1], 50);\n            }),\n            \"Call Rust in same thread with zapbuffer\": () => __awaiter(void 0, void 0, void 0, function* () {\n                const result = yield rpc.send(\"testCallRustInSameThreadSyncWithZapbuffer\");\n                const array = zaplib.deserializeZapArrayFromPostMessage(result);\n                expect(array.length, 8);\n                expect(array[0], 10);\n                expect(array[1], 20);\n                expect(array[2], 30);\n                expect(array[3], 40);\n                expect(array[4], 50);\n                expect(array[5], 60);\n                expect(array[6], 70);\n                expect(array[7], 80);\n            }),\n            \"Send signal from worker\": runWorkerTest(\"testCallRustInSameThreadSyncWithSignal\"),\n        }\n        : {\n            \"Call Rust (in same thread)\": () => {\n                const buffer = new SharedArrayBuffer(8);\n                new Uint8Array(buffer).set([1, 2, 3, 4, 5, 6, 7, 8]);\n                const uint8Part = new Uint8Array(buffer, 2, 4);\n                const [result] = zaplib.callRustInSameThreadSync(\"array_multiply_u8\", [JSON.stringify(10), uint8Part]);\n                expect(result.length, 4);\n                expect(result[0], 30);\n                expect(result[1], 40);\n                expect(result[2], 50);\n                expect(result[3], 60);\n            },\n            \"Call Rust with Float32Array (in same thread)\": () => __awaiter(void 0, void 0, void 0, function* () {\n                // Using a normal array\n                const input = new Float32Array([0.1, 0.9, 0.3]);\n                const result = zaplib.callRustInSameThreadSync(\"array_multiply_f32\", [JSON.stringify(10), input])[0];\n                expect(result.length, 3);\n                expect(result[0], 1);\n                expect(result[1], 9);\n                expect(result[2], 3);\n                // Using a ZapArray\n                const input2 = yield zaplib.createMutableBuffer(new Float32Array([0.1, 0.9, 0.3]));\n                const result2 = zaplib.callRustInSameThreadSync(\"array_multiply_f32\", [JSON.stringify(10), input2])[0];\n                expect(result2.length, 3);\n                expect(result2[0], 1);\n                expect(result2[1], 9);\n                expect(result2[2], 3);\n                // Using a readonly ZapArray\n                const input3 = yield zaplib.createReadOnlyBuffer(new Float32Array([0.1, 0.9, 0.3]));\n                const result3 = zaplib.callRustInSameThreadSync(\"array_multiply_f32_readonly\", [JSON.stringify(10), input3])[0];\n                expect(result3.length, 3);\n                expect(result3[0], 1);\n                expect(result3[1], 9);\n                expect(result3[2], 3);\n            }),\n        };\n    const tests = Object.assign(Object.assign({ \"Call Rust\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const buffer = new SharedArrayBuffer(8);\n            new Uint8Array(buffer).set([1, 2, 3, 4, 5, 6, 7, 8]);\n            const uint8Part = new Uint8Array(buffer, 2, 4);\n            const [result] = yield zaplib.callRust(\"array_multiply_u8\", [\n                JSON.stringify(10),\n                uint8Part,\n            ]);\n            expect(result.length, 4);\n            expect(result[0], 30);\n            expect(result[1], 40);\n            expect(result[2], 50);\n            expect(result[3], 60);\n        }), \"Call Rust (no return)\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const buffer = new SharedArrayBuffer(8);\n            new Uint8Array(buffer).set([1, 2, 3, 4, 5, 6, 7, 8]);\n            const uint8Part = new Uint8Array(buffer, 2, 4);\n            const result = yield zaplib.callRust(\"call_rust_no_return\", [\n                JSON.stringify(10),\n                uint8Part,\n            ]);\n            expect(result.length, 0);\n        }), \"Call Rust (string return)\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const buffer = new SharedArrayBuffer(8);\n            const data = new Uint8Array(buffer);\n            data.set([1, 2, 3, 4, 5, 6, 7, 8]);\n            const [result] = yield zaplib.callRust(\"total_sum\", [data]);\n            expect(result, \"36\");\n        }), \"Call Rust (with ZapBuffer)\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const buffer = yield zaplib.createReadOnlyBuffer(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]));\n            const result = (yield zaplib.callRust(\"array_multiply_u8_readonly\", [\n                JSON.stringify(10),\n                buffer,\n            ]))[0];\n            expect(result.length, 8);\n            expect(result[0], 10);\n            expect(result[1], 20);\n            expect(result[2], 30);\n            expect(result[3], 40);\n            expect(result[4], 50);\n            expect(result[5], 60);\n            expect(result[6], 70);\n            expect(result[7], 80);\n            return Promise.all([\n                expectDeallocationOrUnregister(buffer),\n                expectDeallocationOrUnregister(result),\n            ]);\n        }), \"Call Rust (with Mutable ZapBuffer)\": () => __awaiter(void 0, void 0, void 0, function* () {\n            // TODO(Paras): Add enforcement of readonly ZapArrays and test it.\n            // const [buffer] = await zaplib.callRust(\"make_zapbuffer\");\n            // let err;\n            // try {\n            //     buffer[0] = 0;\n            // } catch (e) {\n            //     err = e;\n            // } finally {\n            //     expect(err?.message, \"Cannot mutate a read-only array\");\n            // }\n            const mutableBuffer = yield zaplib.createMutableBuffer(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]));\n            expect(mutableBuffer.length, 8);\n            expect(mutableBuffer[0], 1);\n            expect(mutableBuffer[1], 2);\n            expect(mutableBuffer[2], 3);\n            expect(mutableBuffer[3], 4);\n            expect(mutableBuffer[4], 5);\n            expect(mutableBuffer[5], 6);\n            expect(mutableBuffer[6], 7);\n            expect(mutableBuffer[7], 8);\n            // Mutate the buffer to ensure the changes are detected in Rust code\n            mutableBuffer[0] = 0;\n            mutableBuffer[1] = 0;\n            mutableBuffer[2] = 0;\n            mutableBuffer[3] = 0;\n            const result = (yield zaplib.callRust(\"array_multiply_u8\", [\n                JSON.stringify(10),\n                mutableBuffer,\n            ]))[0];\n            expect(result.length, 8);\n            expect(result[0], 0);\n            expect(result[1], 0);\n            expect(result[2], 0);\n            expect(result[3], 0);\n            expect(result[4], 50);\n            expect(result[5], 60);\n            expect(result[6], 70);\n            expect(result[7], 80);\n            return Promise.all([\n                expectDeallocationOrUnregister(mutableBuffer),\n                expectDeallocationOrUnregister(result),\n            ]);\n        }), \"Call Rust with Float32Array\": () => __awaiter(void 0, void 0, void 0, function* () {\n            // Using a normal array\n            const input = new Float32Array([0.1, 0.9, 0.3]);\n            const result = (yield zaplib.callRust(\"array_multiply_f32\", [\n                JSON.stringify(10),\n                input,\n            ]))[0];\n            expect(result.length, 3);\n            expect(result[0], 1);\n            expect(result[1], 9);\n            expect(result[2], 3);\n            // Using a ZapArray\n            const input2 = yield zaplib.createMutableBuffer(new Float32Array([0.1, 0.9, 0.3]));\n            const result2 = (yield zaplib.callRust(\"array_multiply_f32\", [\n                JSON.stringify(10),\n                input2,\n            ]))[0];\n            expect(result2.length, 3);\n            expect(result2[0], 1);\n            expect(result2[1], 9);\n            expect(result2[2], 3);\n            // Using a readonly ZapArray\n            const input3 = yield zaplib.createReadOnlyBuffer(new Float32Array([0.1, 0.9, 0.3]));\n            const result3 = (yield zaplib.callRust(\"array_multiply_f32_readonly\", [\n                JSON.stringify(10),\n                input3,\n            ]))[0];\n            expect(result3.length, 3);\n            expect(result3[0], 1);\n            expect(result3[1], 9);\n            expect(result3[2], 3);\n            return Promise.all([\n                expectDeallocationOrUnregister(result),\n                expectDeallocationOrUnregister(input2),\n                expectDeallocationOrUnregister(result2),\n                expectDeallocationOrUnregister(input3),\n                expectDeallocationOrUnregister(result3),\n            ]);\n        }), \"Cast WrBuffers\": () => __awaiter(void 0, void 0, void 0, function* () {\n            const input = yield zaplib.createMutableBuffer(new Float32Array([0.1]));\n            const castArray = new Uint8Array(input.buffer);\n            expect(castArray.length, 4);\n            expect(castArray[0], 205);\n            expect(castArray[1], 204);\n            expect(castArray[2], 204);\n            expect(castArray[3], 61);\n            yield expectThrowAsync(() => zaplib.callRust(\"verify_cast_array\", [castArray]), \"Cannot call Rust with a buffer which has been cast to a different type. Expected F32Buffer but got U8Buffer\");\n            const input2 = yield zaplib.createReadOnlyBuffer(new Float32Array([0.1]));\n            const castArray2 = new Uint8Array(input2.buffer);\n            expect(castArray2.length, 4);\n            expect(castArray2[0], 205);\n            expect(castArray2[1], 204);\n            expect(castArray2[2], 204);\n            expect(castArray2[3], 61);\n            yield expectThrowAsync(() => zaplib.callRust(\"verify_cast_array\", [castArray2]), \"Cannot call Rust with a buffer which has been cast to a different type. Expected ReadOnlyF32Buffer but got ReadOnlyU8Buffer\");\n        }), \"On the main thread inWorker returns false\": () => {\n            expect(inWorker, false);\n        } }, runtimeSpecificTests), zapBufferTests);\n    const makeButtons = () => {\n        const jsRoot = assertNotNull(document.getElementById(\"root\"));\n        const runAllButton = document.createElement(\"button\");\n        runAllButton.innerText = \"Run All Tests 3x\";\n        runAllButton.onclick = () => __awaiter(void 0, void 0, void 0, function* () {\n            setInTest(true);\n            for (let i = 0; i < 3; i++) {\n                for (const [testName, test] of Object.entries(tests)) {\n                    console.log(`Running test: ${testName}`);\n                    yield test();\n                    console.log(`✅ Success`);\n                }\n            }\n            console.log(`✅ All tests completed (3x to ensure no memory corruption!)`);\n            setInTest(false);\n        });\n        const buttonDiv = document.createElement(\"div\");\n        buttonDiv.append(runAllButton);\n        jsRoot.append(buttonDiv);\n        for (const [name, test] of Object.entries(tests)) {\n            const button = document.createElement(\"button\");\n            button.innerText = name;\n            button.onclick = () => __awaiter(void 0, void 0, void 0, function* () {\n                setInTest(true);\n                console.log(`Running test: ${name}`);\n                yield test();\n                console.log(`✅ Success`);\n                setInTest(false);\n            });\n            const buttonDiv = document.createElement(\"div\");\n            buttonDiv.append(button);\n            jsRoot.append(buttonDiv);\n        }\n    };\n    if (document.readyState !== \"loading\") {\n        makeButtons();\n    }\n    else {\n        document.addEventListener(\"DOMContentLoaded\", makeButtons);\n    }\n});\n","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";var e;!function(e){e[e.String=0]=\\\"String\\\",e[e.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",e[e.U8Buffer=2]=\\\"U8Buffer\\\",e[e.F32Buffer=3]=\\\"F32Buffer\\\",e[e.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\"}(e||(e={})),self;const r=\\\"function\\\"==typeof importScripts,t=(e,r)=>{if(r!==e)throw new Error(`Failure: Got ${e}, Expected ${r}`);console.debug(`Success: Got ${e}, Expected ${r}`)};class n extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function a(e){return class r extends e{constructor(...r){const t=r[0];if(\\\"object\\\"==typeof t&&t instanceof n){if(r.length<2&&(r[1]=t.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((t.__zaplibBufferData.bufferPtr+t.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<t.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>t.__zaplibBufferData.bufferPtr+t.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=t.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=t}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const s={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,r]of Object.entries(s))e in self&&(self[r]=a(self[e]));function o(e){if(\\\"object\\\"!=typeof e||null===e)return!1;if(Object.prototype.hasOwnProperty.call(e,\\\"__zaplibBuffer\\\"))return!0;if(Array.isArray(e)||e instanceof Set||e instanceof Map){for(const r of e)if(o(r))return!0}else if(Object.getPrototypeOf(e)===Object.getPrototypeOf({}))for(const r of Object.entries(e))if(o(r))return!0;return!1}function i(e){const r=e.postMessage;e.postMessage=function(...e){if(o(e[0]))throw new Error(\\\"Sending ZapBuffers to/from workers is not supported - use .slice() on typed array instead to make an explicit copy\\\");r.apply(this,e)}}const f=new WeakMap;function u(e){return\\\"object\\\"==typeof e&&e instanceof n}function l(r){if(!u(r.buffer))throw new Error(\\\"zapArray.buffer is not a ZapBuffer in checkValidZapArray\\\");const t=r.buffer;if(r.byteOffset!==t.__zaplibBufferData.bufferPtr||r.byteLength!==t.__zaplibBufferData.bufferLen)throw new Error(\\\"Called Rust with a buffer that does not span the entire underlying ZapBuffer\\\");const n=v(r,t.readonly);if(n!==t.__zaplibBufferData.paramType)throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${e[t.__zaplibBufferData.paramType]} but got ${e[n]}`)}const c={},h=new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete c[e],r&&r(e)})),y=new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)})),d=(e,r,t,a)=>{var s;if(r.readonly){if(null===(s=c[r.arcPtr])||void 0===s?void 0:s.deref())t(r.arcPtr);else{const a=new n(e.buffer,r);h.register(a,{arcPtr:r.arcPtr,destructor:t}),c[r.arcPtr]=new WeakRef(a)}return c[r.arcPtr].deref()}{const t=new n(e.buffer,r);return y.register(t,{bufferData:r,destructor:a},t),t}},p=e=>{if(e.readonly)throw new Error(\\\"`unregisterMutableBuffer` should only be called on mutable ZapBuffers\\\");y.unregister(e)};class b{constructor({buffer:e,byteOffset:r,slots:t,growCallback:n}){this._buffer=e,this._byteOffset=r,this._slots=t,this._growCallback=n,this._used=2,this._updateRefs()}_updateRefs(){this._f32=new Float32Array(this._buffer,this._byteOffset,this._slots),this._u32=new Uint32Array(this._buffer,this._byteOffset,this._slots),this._f64=new Float64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64=new BigUint64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64[0]=BigInt(this._slots)*BigInt(4)}_fit(e){if(this._used+e>this._slots){let r=Math.max(this._used+e,2*this._slots);1&r&&r++;const t=4*r,{buffer:n,byteOffset:a}=this._growCallback(this._buffer,this._byteOffset,t);this._buffer=n,this._byteOffset=a,this._slots=r,this._updateRefs()}const r=this._used;return this._used+=e,r}sendF32(e){const r=this._fit(1);this._f32[r]=e}sendU32(e){const r=this._fit(1);this._u32[r]=e}sendF64(e){if(1&this._used){const r=this._fit(3)+1;this._f64[r>>1]=e}else{const r=this._fit(2);this._f64[r>>1]=e}}sendU64(e){if(1&this._used){const r=this._fit(3)+1;this._u64[r>>1]=e}else{const r=this._fit(2);this._u64[r>>1]=e}}sendString(e){let r=this._fit(e.length+1);this._u32[r++]=e.length;for(let t=0;t<e.length;t++)this._u32[r++]=e.charCodeAt(t)}getData(){return{buffer:this._buffer,byteOffset:this._byteOffset}}}class _{constructor(e,r){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,r),this._u32=new Uint32Array(this._memory.buffer,r),this._f64=new Float64Array(this._memory.buffer,r),this._u64=new BigUint64Array(this._memory.buffer,r)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e=\\\"\\\";const r=this.parseU32();for(let t=0;t<r;t++){const r=this.parseU32();0!=r&&(e+=String.fromCharCode(r))}return e}parseU8Slice(){const e=this.parseU32(),r=e>>2,t=new Uint8Array(e),n=3&e;for(let e=0;e<r;e++){const r=e<<2,n=this.parseU32();t[r+0]=255&n,t[r+1]=n>>8&255,t[r+2]=n>>16&255,t[r+3]=n>>24&255}const a=r<<2;if(1==n){const e=this.parseU32();t[a+0]=255&e}else if(2==n){const e=this.parseU32();t[a+0]=255&e,t[a+1]=e>>8&255}else if(3==n){const e=this.parseU32();t[a+0]=255&e,t[a+1]=e>>8&255,t[a+2]=e>>16&255}return t}parseZapParams(){const r=this.parseU32(),t=[];for(let n=0;n<r;++n){const r=this.parseU32();if(r===e.String)t.push(this.parseString());else if(r===e.ReadOnlyU8Buffer||r===e.ReadOnlyF32Buffer){const e=this.parseU32(),n=this.parseU32(),a=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,arcPtr:a,readonly:!0})}else{if(r!==e.U8Buffer&&r!==e.F32Buffer)throw new Error(`Unknown ZapParam type: ${r}`);{const e=this.parseU32(),n=this.parseU32(),a=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,bufferCap:a,readonly:!1})}}}return t}}const g=\\\"$$RESPONSE\\\",w=\\\"$$ERROR\\\";class m{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===g)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:g,id:r},[]);const t=e[m.transferrables];delete e[m.transferrables];const n={topic:g,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:g,id:r,data:{[w]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,a={topic:e,id:n,data:r},s=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[w]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(a,t),s}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}m.transferrables=\\\"$$TRANSFERRABLES\\\";const E=(e,r,t)=>{new e.constructor(r,t,e.length).set(e)},v=(r,t)=>{if(r instanceof Uint8Array)return t?e.ReadOnlyU8Buffer:e.U8Buffer;if(r instanceof Float32Array)return t?e.ReadOnlyF32Buffer:e.F32Buffer;throw new Error(\\\"Invalid array type\\\")},B=(e,r,t)=>{const n=Number(r.allocWasmVec(BigInt(t.byteLength)));return E(t,e.buffer,n),n};var A,W,S,k,U;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\"}(A||(A={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(W||(W={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(S||(S={})),(U=k||(k={})).Init=\\\"MainWorkerChannelEvent.Init\\\",U.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",U.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",U.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\";let R,C,T,O,F=!1;const M=e=>{if(F)throw new Error(\\\"Only call zaplib.initializeWorker once\\\");if(F=!0,!r)throw new Error(\\\"zaplib.initializeWorker() can only be called in a WebWorker\\\");return function(){for(const[e,r]of Object.entries(s))e in self&&(self[e]=self[r]);i(self),i(self.Worker),i(self.MessagePort)}(),new Promise((r=>{R=new m(e),R.send(k.Init).then((({wasmModule:e,memory:t,taskWorkerSab:n,baseUri:a,appPtr:s,tlsAndStackData:o})=>{T=t,O=s;const i=(({getExports:e,memory:r,taskWorkerSab:t,fileHandles:n,sendEventFromAnyThread:a,threadSpawn:s,baseUri:o})=>{const i=new FileReaderSync,f=(e,t)=>{let n=\\\"\\\";const a=new Uint32Array(r.buffer,e,t);for(let e=0;e<t;e++)n+=String.fromCharCode(a[e]);return n};return{memory:r,_consoleLog:(e,r,t)=>{const n=f(parseInt(e),parseInt(r));t?console.error(n):console.log(n)},readUserFileRange:(e,t,a,s)=>{const o=n[e],f=Number(s),u=f+Number(a);o.lastReadStart<=f&&f<o.lastReadEnd&&console.warn(`Read start (${f}) fell in the range of the last read (${o.lastReadStart}-${o.lastReadEnd}); this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.`),o.lastReadStart=f,o.lastReadEnd=u;const l=i.readAsArrayBuffer(o.file.slice(f,u));return E(new Uint8Array(l),r.buffer,Number(t)),BigInt(l.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{s(e)},_sendEventFromAnyThread:e=>{a(e)},readUrlSync:(t,n,a,s)=>{const i=f(t,n),u=new XMLHttpRequest;if(u.responseType=\\\"arraybuffer\\\",u.open(\\\"GET\\\",new URL(i,o).href,!1),u.send(null),200===u.status){const t=e(),n=B(r,t,new Uint8Array(u.response));return new Uint32Array(r.buffer,a,1)[0]=n,new Uint32Array(r.buffer,s,1)[0]=u.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,r)=>{const t=new Int32Array(e);((e,r)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(t);const n=t[1];new Uint32Array(e)[n+2]=r,t[1]=n+1,((e,r)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,0,1)})(t),Atomics.notify(t,1)})(t,parseInt(e))}}})({getExports:function(){return C},memory:t,taskWorkerSab:n,fileHandles:[],sendEventFromAnyThread:e=>{R.send(k.SendEventFromAnyThread,e)},threadSpawn:()=>{throw new Error(\\\"Not yet implemented\\\")},baseUri:a});WebAssembly.instantiate(e,{env:i}).then((e=>{C=e.exports,((e,r)=>{e.__stack_pointer.value=Number(r.ptr)+r.size-8,e.__wasm_init_tls(Number(r.ptr))})(C,o),r()}))}))}))},I=e=>{C.decrementArc(BigInt(e))},D=({bufferPtr:e,bufferLen:r,bufferCap:t})=>{C.deallocVec(BigInt(e),BigInt(r),BigInt(t))},P=r=>function(r,t,n,a){return a.map((a=>{if(\\\"string\\\"==typeof a)return a;{const s=d(r,a,t,n);if(a.paramType===e.String)throw new Error(\\\"ZapParam buffer type called with string paramType\\\");const o={[e.U8Buffer]:Uint8Array,[e.ReadOnlyU8Buffer]:Uint8Array,[e.F32Buffer]:Float32Array,[e.ReadOnlyF32Buffer]:Float32Array}[a.paramType];return function(e,r){var t;return(null===(t=f.get(e))||void 0===t?void 0:t.BYTES_PER_ELEMENT)!==r.BYTES_PER_ELEMENT&&f.set(e,r),f.get(e)}(s,new o(s,a.bufferPtr,a.bufferLen/o.BYTES_PER_ELEMENT))}}))}(T,I,D,r),L=(e,r=[])=>{return t=void 0,n=void 0,s=function*(){const t=r.map((e=>\\\"string\\\"==typeof e?e:u(e.buffer)?(l(e),x(e)):(e.buffer instanceof SharedArrayBuffer||console.warn(\\\"Consider passing Uint8Arrays backed by ZapBuffer or SharedArrayBuffer into `callRust` to prevent copying data\\\"),e)));return P(yield R.send(k.CallRust,{name:e,params:t}))},new((a=void 0)||(a=Promise))((function(e,r){function o(e){try{f(s.next(e))}catch(e){r(e)}}function i(e){try{f(s.throw(e))}catch(e){r(e)}}function f(r){var t;r.done?e(r.value):(t=r.value,t instanceof a?t:new a((function(e){e(t)}))).then(o,i)}f((s=s.apply(t,n||[])).next())}));var t,n,a,s},z=(r,t=[])=>{const a=((e,r)=>{const t=Number(r.allocWasmMessage(BigInt(4096)));return new b({buffer:e.buffer,byteOffset:t,slots:1024,growCallback:(t,n,a)=>{const s=Number(r.reallocWasmMessage(BigInt(n),BigInt(a)));return{buffer:e.buffer,byteOffset:s}}})})(T,C);a.sendString(r),a.sendU32(t.length);for(const r of t)if(\\\"string\\\"==typeof r)a.sendU32(e.String),a.sendString(r);else if(r.buffer instanceof n)if(l(r),r.buffer.__zaplibBufferData.readonly){a.sendU32(v(r,!0));const e=r.buffer.__zaplibBufferData.arcPtr;C.incrementArc(BigInt(e)),a.sendU32(e)}else p(r.buffer),a.sendU32(v(r,!1)),a.sendU32(r.buffer.__zaplibBufferData.bufferPtr),a.sendU32(r.buffer.__zaplibBufferData.bufferLen),a.sendU32(r.buffer.__zaplibBufferData.bufferCap);else{console.warn(\\\"Consider passing Uint8Arrays backed by ZapBuffer to prevent copying data\\\");const e=r.byteLength,t=B(T,C,r);a.sendU32(v(r,!1)),a.sendU32(t),a.sendU32(e),a.sendU32(e)}const s=C.callRustInSameThreadSync(O,BigInt(a.getData().byteOffset)),o=new _(T,Number(s)).parseZapParams();return P(o)},N=e=>{const r=e.byteLength,t=B(T,C,e);return P([{paramType:v(e,!1),bufferPtr:t,bufferLen:r,bufferCap:r,readonly:!1}])[0]},Z=e=>{const r=B(T,C,e),t=v(e,!0),n=Number(C.createArcVec(BigInt(r),BigInt(e.length),BigInt(t)));return P([{paramType:t,bufferPtr:r,bufferLen:e.byteLength,arcPtr:n,readonly:!0}])[0]},x=e=>{if(\\\"object\\\"!=typeof e||!u(e.buffer))throw new Error(\\\"Only pass Zap arrays to serializeZapArrayForPostMessage\\\");const r=e.buffer;return r.__zaplibBufferData.readonly?C.incrementArc(BigInt(r.__zaplibBufferData.arcPtr)):p(r),{bufferData:r.__zaplibBufferData,byteOffset:e.byteOffset,byteLength:e.byteLength}};var $=function(e,r,t,n){return new(t||(t=Promise))((function(a,s){function o(e){try{f(n.next(e))}catch(e){s(e)}}function i(e){try{f(n.throw(e))}catch(e){s(e)}}function f(e){var r;e.done?a(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(o,i)}f((n=n.apply(e,r||[])).next())}))};const J=new m(self),j={testCallRustFromWorker:function(){return $(this,void 0,void 0,(function*(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const r=new Uint8Array(e,2,4),[n]=yield L(\\\"array_multiply_u8\\\",[JSON.stringify(10),r]);t(n.length,4),t(n[0],30),t(n[1],40),t(n[2],50),t(n[3],60)}))},testCallRustNoReturnFromWorker:function(){return $(this,void 0,void 0,(function*(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const r=new Uint8Array(e,2,4),n=yield L(\\\"call_rust_no_return\\\",[JSON.stringify(10),r]);t(n.length,0)}))},testCallRustInSameThreadSyncWithSignal:function(){const e=z(\\\"send_signal\\\");t(e.length,0)},testCallRustFloat32ArrayFromWorker:()=>$(void 0,void 0,void 0,(function*(){const e=new Float32Array([.1,.9,.3]),r=(yield L(\\\"array_multiply_f32\\\",[JSON.stringify(10),e]))[0];t(r.length,3),t(r[0],1),t(r[1],9),t(r[2],3);const n=N(new Float32Array([.1,.9,.3])),a=(yield L(\\\"array_multiply_f32\\\",[JSON.stringify(10),n]))[0];t(a.length,3),t(a[0],1),t(a[1],9),t(a[2],3);const s=Z(new Float32Array([.1,.9,.3])),o=(yield L(\\\"array_multiply_f32_readonly\\\",[JSON.stringify(10),s]))[0];t(o.length,3),t(o[0],1),t(o[1],9),t(o[2],3)})),testCallRustInSameThreadSyncFloat32ArrayFromWorker:()=>$(void 0,void 0,void 0,(function*(){const e=new Float32Array([.1,.9,.3]),r=z(\\\"array_multiply_f32\\\",[JSON.stringify(10),e])[0];t(r.length,3),t(r[0],1),t(r[1],9),t(r[2],3);const n=N(new Float32Array([.1,.9,.3])),a=z(\\\"array_multiply_f32\\\",[JSON.stringify(10),n])[0];t(a.length,3),t(a[0],1),t(a[1],9),t(a[2],3);const s=Z(new Float32Array([.1,.9,.3])),o=z(\\\"array_multiply_f32_readonly\\\",[JSON.stringify(10),s])[0];t(o.length,3),t(o[0],1),t(o[1],9),t(o[2],3)})),testInWorker:()=>{t(r,!0)}};J.receive(\\\"initWasm\\\",(e=>{M(e)})),J.receive(\\\"runTest\\\",(e=>$(void 0,void 0,void 0,(function*(){return j[e]()})))),J.receive(\\\"sendWorker\\\",(function(e){const r=(e=>{const r=d(T,e.bufferData,I,D);return new Uint8Array(r,e.byteOffset,e.byteLength)})(e);console.log(\\\"got data\\\",r)})),J.receive(\\\"testSendZapArrayToMainThread\\\",(function(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const r=new Uint8Array(e,2,4),t=z(\\\"array_multiply_u8\\\",[JSON.stringify(10),r])[0];return{array:x(t),subarray:x(t.subarray(1,3))}})),J.receive(\\\"testCallRustInSameThreadSyncWithZapbuffer\\\",(function(){const e=N(new Uint8Array([1,2,3,4,5,6,7,8])),[r]=z(\\\"array_multiply_u8\\\",[JSON.stringify(10),e]);if(\\\"string\\\"==typeof r)throw new Error(\\\"didn't expect result2 to be a string\\\");return x(r)}))})();\\n\", \"Worker\", undefined, undefined);\n}\n"],"names":["root","factory","exports","module","define","amd","self","___CSS_LOADER_EXPORT___","push","id","cssWithMappingToString","list","toString","this","map","item","content","needLayer","concat","length","join","i","modules","media","dedupe","supports","layer","undefined","alreadyImportedModules","k","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","data","sourceMapping","sourceURLs","sources","source","sourceRoot","stylesInDOM","getIndexByIdentifier","identifier","result","modulesToDom","options","idCountMap","identifiers","base","count","indexByIdentifier","obj","css","sourceMap","references","updater","addElementStyle","byIndex","splice","api","domAPI","update","newObj","remove","lastIdentifiers","newList","index","newLastIdentifiers","_i","_index","memo","insert","style","target","styleTarget","document","querySelector","window","HTMLIFrameElement","contentDocument","head","e","getTarget","Error","appendChild","element","createElement","setAttributes","attributes","styleElement","nonce","setAttribute","insertStyleElement","styleTagTransform","apply","parentNode","removeChild","removeStyleElement","styleSheet","cssText","firstChild","createTextNode","RESPONSE","ERROR","Rpc","constructor","channel","_messageId","_pendingCallbacks","_receivers","Map","_onChannelMessage","ev","topic","Promise","resolve","handler","get","then","postMessage","transferrables","message","catch","err","name","stack","_channel","onmessage","send","transfer","reject","info","error","receive","has","set","console","initTaskWorkerSab","taskWorkerSab","SharedArrayBuffer","taskWorkerSabi32","Int32Array","copyArrayToRustBuffer","inputBuffer","outputBuffer","outputPtr","getZapParamType","array","readonly","Uint8Array","Float32Array","transformParamsFromRustImpl","memory","destructor","mutableDestructor","params","param","zapBuffer","paramType","ArrayConstructor","bufferPtr","bufferLen","BYTES_PER_ELEMENT","assertNotNull","value","objectName","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","done","expect","actual","expected","debug","expectThrow","f","expectedMessage","expectThrowAsync","sleep","ms","setTimeout","checkConditionTimeout","condition","timeout","startTime","performance","now","generateGarbage","expectDeallocationOrUnregister","callRust","zapArray","buffer","__zaplibBufferData","arcPtr","BigInt","countBeforeDeallocation","arcAllocated","arcDeallocated","inTest","setInTest","v","jsRuntime","inWorker","importScripts","ZapParamType","ZapBuffer","bufferData","super","__zaplibWasmBuffer","byteLength","slice","args","zapBufferExtends","cls","ZapTypedArray","Math","floor","__zaplibBuffer","subarray","begin","end","byteOffset","classesToExtend","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint16ClampedArray","Uint32Array","Float64Array","BigInt64Array","BigUint64Array","DataView","zapCls","Object","entries","containsZapBuffer","object","prototype","hasOwnProperty","call","Array","isArray","Set","entry","getPrototypeOf","patchPostMessage","origPostMessage","overwriteTypedArraysWithZapArrays","Worker","MessagePort","zapBufferCache","WeakMap","getCachedZapBuffer","fallbackArray","_a","isZapBuffer","potentialZapBuffer","checkValidZapArray","bufferCache","allocatedArcs","allocatedVecs","bufferRegistry","FinalizationRegistry","mutableZapBufferRegistry","getZapBufferWasm","wasmMemory","deref","register","WeakRef","unregisterMutableBuffer","unregister","getZapBufferCef","bufferCap","Worker_fn","makeRpcMouseEvent","event","pageX","pageY","button","shiftKey","ctrlKey","metaKey","altKey","makeRpcTouchEvent","changedTouches","from","touch","makeRpcKeyboardEvent","keyCode","repeat","WorkerEvent","TaskWorkerEvent","AsyncWorkerEvent","MainWorkerChannelEvent","makeTextarea","callback","ta","textAreaPos","fixFocus","activeElement","getElementById","contains","focus","addEventListener","updateTextAreaPos","left","round","x","top","y","wasPaste","lastLen","uglyIMEHack","recreateTextarea","body","className","height","width","preventDefault","input","substring","type","TextInput","replaceLast","textValue","code","TextCopy","readOnly","KeyDown","KeyUp","showTextIME","textareaHasFocus","WebGLRenderer","canvas","sizingData","incompatibleBrowserCallback","uniformFnTable","float","loc","off","slot","gl","uniform1f","basef32","vec2","uniform2f","vec3","uniform3f","vec4","uniform4f","mat2","uniformMatrix2fv","mat3","uniformMatrix3fv","mat4","uniformMatrix4fv","sendFnTable","_self","parseShvarvec","len","zerdeParser","parseU32","vars","ty","parseString","ash","shaderId","fragment","vertex","geometrySlots","instanceSlots","passUniforms","viewUniforms","drawUniforms","userUniforms","textureSlots","compileWebGLShader","arrayBufferId","pointer","allocArrayBuffer","indexBufferId","allocIndexBuffer","vaoId","geomIbId","geomVbId","instVbId","allocVao","uniformsPassPtr","uniformsViewPtr","uniformsDrawPtr","uniformsUserPtr","textures","drawCall","textureId","dataPtr","allocTexture","passId","beginRenderTargets","initOnly","r","parseF32","g","b","a","addColorTarget","depth","setDepthTarget","endRenderTargets","setDefaultDepthAndBlendMode","beginMainCanvas","shaders","indexBuffers","arrayBuffers","vaos","framebuffers","targetWidth","targetHeight","clearFlags","clearR","clearG","clearB","clearA","clearDepth","preferLowPowerToHighPerformance","getContext","OESVertexArrayObject","getExtension","ANGLEInstancedArrays","resize","processMessages","zerdeParserPtr","baseu32","msgType","dpiFactor","getAttribLocations","program","slots","attribLocs","attribs","size","getAttribLocation","offset","stride","getUniformLocations","uniforms","uniformLocs","uniform","uniformSizeTable","getUniformLocation","fn","vsh","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","log","getShaderInfoLog","addLineNumbersToString","fsh","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","geomAttribs","instAttribs","buf","glBuf","createBuffer","bindBuffer","ARRAY_BUFFER","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","oldVao","deleteVertexArrayOES","glVao","createVertexArrayOES","vao","bindVertexArrayOES","shader","attr","vertexAttribPointer","FLOAT","enableVertexAttribArray","vertexAttribDivisorANGLE","passUniformsPtr","viewUniformsPtr","drawUniformsPtr","userUniformsPtr","texturesPtr","useProgram","indexBuffer","instanceBuffer","uni","texSlot","texId","texObj","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","uniform1i","indices","instances","drawElementsInstancedANGLE","TRIANGLES","UNSIGNED_INT","glTex","createTexture","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","RGBA","UNSIGNED_BYTE","glFramebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","mpWidth","mpHeight","COLOR_BUFFER_BIT","framebufferTexture2D","COLOR_ATTACHMENT0","glRenderBuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","DEPTH_BUFFER_BIT","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","DEPTH_ATTACHMENT","viewport","clearColor","clear","enable","DEPTH_TEST","depthFunc","LEQUAL","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","ONE_MINUS_SRC_ALPHA","BLEND","lines","split","out","addDefaultStyles","innerHTML","jsFunctions","registerCallJsCallbacks","fns","key","keys","assign","unregisterCallJsCallbacks","fnNames","rpc","newWorkerPort","MessageChannel","BindMainWorkerPort","port1","port2","DecrementArc","DeallocVec","transformParamsFromRust","temporarilyHeldBuffersForPostMessage","serializeZapArrayForPostMessage","add","IncrementArc","delete","transformedParams","warn","CallRust","createMutableBuffer","CreateBuffer","createReadOnlyBuffer","CreateReadOnlyBuffer","deserializeZapArrayFromPostMessage","postMessageData","callRustInSameThreadSync","_params","alreadyCalledInitialize","initialize","initParams","baseUri","location","protocol","host","wasmPath","URL","filename","href","wasmModulePromise","WebAssembly","compileStreaming","fetch","fileHandles","loader","isMobileSafari","navigator","platform","match","isAndroid","userAgent","defaultStyles","loadingIndicator","addLoadingIndicator","rpcInitialized","ShowIncompatibleBrowserNotification","span","color","replaceChild","RemoveLoadingIndicators","loaders","getElementsByClassName","removeLoadingIndicator","SetDocumentTitle","title","SetMouseCursor","cursor","Fullscreen","requestFullscreen","webkitRequestFullscreen","mozRequestFullscreen","Normalscreen","exitFullscreen","webkitExitFullscreen","mozExitFullscreen","TextCopyResponse","textCopyResponse","clipboard","writeText","EnableGlobalFileDropTarget","dataTransfer","types","stopPropagation","dropEffect","DragEnter","DragOver","clientX","clientY","DragLeave","files","fileHandlesToSend","file","fileHandle","basename","lastReadStart","lastReadEnd","Drop","CallJs","fnName","Element","CanvasMouseDown","WindowMouseUp","scrollTop","scrollLeft","WindowMouseMove","WindowMouseOut","WindowTouchStart","passive","WindowTouchMove","touchEndCancelLeave","WindowTouchEndCancelLeave","CanvasWheel","timeStamp","deltaMode","deltaX","deltaY","wheelDeltaY","makeRpcWheelEvent","WindowFocus","WindowBlur","taEvent","ShowTextIME","offscreenCanvas","webglRenderer","getSizingData","canFullscreen","fullscreenEnabled","webkitFullscreenEnabled","mozFullscreenEnabled","isFullscreen","fullscreenElement","webkitFullscreenElement","mozFullscreenElement","offsetWidth","offsetHeight","devicePixelRatio","onScreenResize","ScreenResize","mqString","mq","matchMedia","setInterval","Init","Memory","initial","maximum","shared","_","transferControlToOffscreen","RunWebGL","requestAnimationFrame","wasmModule","asyncWorkers","threadSpawn","ctxPtr","tlsAndStackData","worker","workerErrorHandler","onerror","onmessageerror","workerRpc","ThreadSpawn","Run","mainWorkerPort","finally","terminate","readyState","cursorMap","packKeyModifier","zerdeKeyboardHandlers","keyDown","zerdeBuilder","sendU32","sendF64","keyUp","textInput","sendString","textCopy","newCallbackId","pendingCallbacks","transformParamsForRust","cefBuffer","cefCreateArrayBuffer","callbackId","promise","_reject","cefCallRust","fromCefJsFunctions","_zaplibReturnParams","parse","cefReadyForMessages","forEach","transformReturnParams","returnParams","ParamTypeToArrayConstructor","cefCallRustInSameThreadSync","_postMessageData","fromCefSetMouseCursor","cursorId","fromCefCallJsFunction","growCallback","cefHandleKeyboardEvent","fromCefSetIMEPosition","cefTriggerCopy","cefTriggerCut","cefTriggerSelectAll","cefTriggerPaste","ZerdeBuilder","_buffer","_byteOffset","_slots","_growCallback","_used","_updateRefs","_f32","_u32","_f64","_u64","_fit","newSlots","max","newBytes","pos","sendF32","sendU64","str","charCodeAt","getData","ZerdeParser","zerdePtr","_memory","_usedSlots","parseF64","ret","parseU64","c","String","fromCharCode","parseU8Slice","u8Len","spare","u8Pos","u32","parseZapParams","workerConstructor","workerOptions","url","globalScope","blob","Blob","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","append","getBlob","webkitURL","objectURL","createObjectURL","revokeObjectURL","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","definition","o","defineProperty","enumerable","prop","Symbol","toStringTag","ZapUint8Array","ZapUint16Array","zapBufferTests","testBuffer","testShare","testOutOfBounds","testZapNameMatches","expectedName","testArrayBuffer","ArrayBuffer","testSubarray","regularArray","testContainsZapBuffer","runWorkerTest","testName","env","searchParams","zapWorkerPort","div","innerText","sendWorker","toSend","runtimeSpecificTests","uint8Part","input2","result2","input3","result3","tests","all","mutableBuffer","castArray","castArray2","makeButtons","jsRoot","runAllButton","onclick","test","buttonDiv"],"sourceRoot":""}