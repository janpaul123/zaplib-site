{"version":3,"file":"zaplib_worker_runtime.js","mappings":"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","sources":["webpack://zaplib/webpack/universalModuleDefinition","webpack://zaplib/webpack/bootstrap","webpack://zaplib/./types.ts","webpack://zaplib/webpack/runtime/define property getters","webpack://zaplib/webpack/runtime/hasOwnProperty shorthand","webpack://zaplib/webpack/runtime/make namespace object","webpack://zaplib/./type_of_runtime.ts","webpack://zaplib/./zap_buffer.ts","webpack://zaplib/./zerde.ts","webpack://zaplib/./common.ts","webpack://zaplib/./rpc_types.ts","webpack://zaplib/./zaplib_worker_runtime.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"zaplib\"] = factory();\n\telse\n\t\troot[\"zaplib\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// Keep in sync with `param.rs`\nexport var ZapParamType;\n(function (ZapParamType) {\n    ZapParamType[ZapParamType[\"String\"] = 0] = \"String\";\n    ZapParamType[ZapParamType[\"ReadOnlyU8Buffer\"] = 1] = \"ReadOnlyU8Buffer\";\n    ZapParamType[ZapParamType[\"U8Buffer\"] = 2] = \"U8Buffer\";\n    ZapParamType[ZapParamType[\"F32Buffer\"] = 3] = \"F32Buffer\";\n    ZapParamType[ZapParamType[\"ReadOnlyF32Buffer\"] = 4] = \"ReadOnlyF32Buffer\";\n})(ZapParamType || (ZapParamType = {}));\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// We only define `cefCallRust` if in CEF, so we can use this for environment detection.\n// This should only be used at the top level `zaplib_runtime` file or in test, since we want to keep\n// CEF and WASM code separate for bundle size.\nexport const jsRuntime = \"cefCallRust\" in self ? \"cef\" : \"wasm\";\n// Whether or not we're in a WebWorker.\n// From https://stackoverflow.com/a/23619712\nexport const inWorker = typeof importScripts === \"function\";\nexport const gitSha = __GIT_SHA__;\n","// Wrapper around SharedArrayBuffer to encapsulate ownership of particular segments of it\nimport { getZapParamType } from \"common\";\nimport { ZapParamType } from \"types\";\nimport { inTest } from \"test_suite/test_helpers\";\n// TODO(Paras) - Make sure we monkeypatch on web workers as well\nexport class ZapBuffer extends SharedArrayBuffer {\n    constructor(buffer, bufferData) {\n        super(0);\n        this.__zaplibWasmBuffer = buffer;\n        this.__zaplibBufferData = bufferData;\n    }\n    // TODO(Paras): Actually enforce this flag and prevent mutation of ZapArrays marked as readonly.\n    // Potentially, we can do this by hashing read only buffer data and periodically checking in debug\n    // builds if they have been modified/raising errors.\n    get readonly() {\n        return this.__zaplibBufferData.readonly;\n    }\n    // The only 2 methods on SharedArrayBuffer class to override:\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#instance_properties\n    get byteLength() {\n        return this.__zaplibWasmBuffer.byteLength;\n    }\n    slice(...args) {\n        return this.__zaplibWasmBuffer.slice(...args);\n    }\n}\n// This class is a drop-in replacement for all typed arrays\n// It uses ZapBuffer as a handle for underlying buffer as the object that keeps underlying data around\n// Requirements:\n//  * The underlying typed array behaves like it was created over the original view\n//  * When the new typed array (potentially with different class name) is created from the buffer of the original one,\n//  they share the same handle\n//\n// The Rust side assumes that underlying data buffer is immutable,\n// however it still could be accidentally modified on JS side leading to weird behavior\n// TODO(Dmitry): Throw an error if there is mutation of the data\nfunction zapBufferExtends(cls) {\n    return class ZapTypedArray extends cls {\n        constructor(...args) {\n            const buffer = args[0];\n            if (typeof buffer === \"object\" && buffer instanceof ZapBuffer) {\n                // Fill in byteOffset if that's omitted.\n                if (args.length < 2) {\n                    args[1] = buffer.__zaplibBufferData.bufferPtr;\n                }\n                // Fill in length (in elements, not in bytes) if that's omitted.\n                if (args.length < 3) {\n                    args[2] = Math.floor((buffer.__zaplibBufferData.bufferPtr +\n                        buffer.__zaplibBufferData.bufferLen -\n                        args[1]) /\n                        cls.BYTES_PER_ELEMENT);\n                }\n                if (args[1] < buffer.__zaplibBufferData.bufferPtr) {\n                    throw new Error(`Byte_offset ${args[1]} is out of bounds`);\n                }\n                if (args[1] + args[2] * cls.BYTES_PER_ELEMENT >\n                    buffer.__zaplibBufferData.bufferPtr +\n                        buffer.__zaplibBufferData.bufferLen) {\n                    throw new Error(`Byte_offset ${args[1]} + length ${args[2]} is out of bounds`);\n                }\n                // Whenever we create ZapUintArray using ZapBuffer as first argument\n                // pass the underlying full wasm_buffer further\n                args[0] = buffer.__zaplibWasmBuffer;\n                super(...args);\n                this.__zaplibBuffer = buffer;\n            }\n            else {\n                super(...args);\n            }\n        }\n        get buffer() {\n            return this.__zaplibBuffer || super.buffer;\n        }\n        subarray(begin = 0, end = this.length) {\n            if (begin < 0) {\n                begin = this.length + begin;\n            }\n            if (end < 0) {\n                end = this.length + end;\n            }\n            if (end < begin) {\n                end = begin;\n            }\n            return new ZapTypedArray(this.buffer, this.byteOffset + begin * this.BYTES_PER_ELEMENT, end - begin);\n        }\n    };\n}\n// Extending all typed arrays\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#indexed_collections\nexport const classesToExtend = {\n    Int8Array: \"ZapInt8Array\",\n    Uint8Array: \"ZapUint8Array\",\n    Uint8ClampedArray: \"ZapUint8ClampedArray\",\n    Int16Array: \"ZapInt16Array\",\n    Uint16Array: \"ZapUint16Array\",\n    Uint16ClampedArray: \"ZapUint16ClampedArray\",\n    Int32Array: \"ZapInt32Array\",\n    Uint32Array: \"ZapUint32Array\",\n    Float32Array: \"ZapFloat32Array\",\n    Float64Array: \"ZapFloat64Array\",\n    BigInt64Array: \"ZapBigInt64Array\",\n    BigUint64Array: \"ZapBigUint64Array\",\n    DataView: \"ZapDataView\",\n};\nfor (const [cls, zapCls] of Object.entries(classesToExtend)) {\n    // Get a new type name by prefixing old one with \"Zaplib\".\n    // e.g. Uint8Array is extended by ZapUint8Array, etc\n    if (cls in self) {\n        // @ts-ignore\n        self[zapCls] = zapBufferExtends(self[cls]);\n    }\n}\n// Checks if the given object itself or recursively contains ZapBuffers.\n// Exported for tests.\nexport function containsZapBuffer(object) {\n    if (typeof object != \"object\" || object === null) {\n        return false;\n    }\n    if (Object.prototype.hasOwnProperty.call(object, \"__zaplibBuffer\")) {\n        return true;\n    }\n    // Only supporting nesting for arrays, plain objects, maps and sets similar to StructuredClone algorithm\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types\n    if (Array.isArray(object) || object instanceof Set || object instanceof Map) {\n        for (const entry of object) {\n            if (containsZapBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    else if (Object.getPrototypeOf(object) === Object.getPrototypeOf({})) {\n        for (const entry of Object.entries(object)) {\n            if (containsZapBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction patchPostMessage(cls) {\n    const origPostMessage = cls.postMessage;\n    // Explicitly NOT a fat arrow (=>) since we want to keep the original `this`.\n    cls.postMessage = function (...args) {\n        if (containsZapBuffer(args[0])) {\n            // TODO(Dmitry): add a better error message showing the exact location of typed arrays\n            throw new Error(\"Sending ZapBuffers to/from workers is not supported - \" +\n                \"use .slice() on typed array instead to make an explicit copy\");\n        }\n        origPostMessage.apply(this, args);\n    };\n}\nexport function overwriteTypedArraysWithZapArrays() {\n    for (const [cls, zapCls] of Object.entries(classesToExtend)) {\n        if (cls in self) {\n            // @ts-ignore\n            self[cls] = self[zapCls];\n        }\n    }\n    patchPostMessage(self);\n    patchPostMessage(self.Worker);\n    // Skipping this in nodejs case as web-worker polyfill doesn't provide MessagePort\n    if (self.MessagePort) {\n        patchPostMessage(self.MessagePort);\n    }\n}\nconst zapBufferCache = new WeakMap();\nexport function getCachedZapBuffer(zapBuffer, fallbackArray) {\n    var _a;\n    if (!(\n    // Overwrite the cached value if we return a pointer to a buffer of a different type\n    // For example, Rust code may cast a float to an u8 and return the same buffer pointer.\n    (((_a = zapBufferCache.get(zapBuffer)) === null || _a === void 0 ? void 0 : _a.BYTES_PER_ELEMENT) ===\n        fallbackArray.BYTES_PER_ELEMENT))) {\n        zapBufferCache.set(zapBuffer, fallbackArray);\n    }\n    return zapBufferCache.get(zapBuffer);\n}\nexport function isZapBuffer(potentialZapBuffer) {\n    return (typeof potentialZapBuffer === \"object\" &&\n        potentialZapBuffer instanceof ZapBuffer);\n}\nexport function checkValidZapArray(zapArray) {\n    if (!isZapBuffer(zapArray.buffer)) {\n        throw new Error(\"zapArray.buffer is not a ZapBuffer in checkValidZapArray\");\n    }\n    const buffer = zapArray.buffer;\n    const bufferCoversZapBuffer = zapArray.byteOffset === buffer.__zaplibBufferData.bufferPtr &&\n        zapArray.byteLength === buffer.__zaplibBufferData.bufferLen;\n    if (!bufferCoversZapBuffer) {\n        throw new Error(\"Called Rust with a buffer that does not span the entire underlying ZapBuffer\");\n    }\n    const paramType = getZapParamType(zapArray, buffer.readonly);\n    if (paramType !== buffer.__zaplibBufferData.paramType) {\n        throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${ZapParamType[buffer.__zaplibBufferData.paramType]} but got ${ZapParamType[paramType]}`);\n    }\n}\n// Cache ZapBuffers so that we have a stable identity for ZapBuffers pointing to the same\n// Arc. This is useful for any downstream caches in user code.\nconst bufferCache = {};\nexport const allocatedArcs = {};\nexport const allocatedVecs = {};\nconst bufferRegistry = new FinalizationRegistry(({ arcPtr, destructor, }) => {\n    if (inTest) {\n        if (allocatedArcs[arcPtr] === false) {\n            throw new Error(`Deallocating an already deallocated arcPtr ${arcPtr}`);\n        }\n        else if (allocatedArcs[arcPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated arcPtr ${arcPtr}`);\n        }\n        allocatedArcs[arcPtr] = false;\n    }\n    delete bufferCache[arcPtr];\n    if (destructor)\n        destructor(arcPtr);\n});\nconst mutableZapBufferRegistry = new FinalizationRegistry(({ bufferData, destructor, }) => {\n    if (inTest) {\n        const { bufferPtr } = bufferData;\n        if (allocatedVecs[bufferPtr] === false) {\n            throw new Error(`Deallocating an already deallocated bufferPtr ${bufferPtr}`);\n        }\n        else if (allocatedVecs[bufferPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated bufferPtr ${bufferPtr}`);\n        }\n        allocatedVecs[bufferPtr] = false;\n    }\n    destructor(bufferData);\n});\n// Return a buffer with a stable identity based on arcPtr.\n// Register callbacks so we de-allocate the buffer when it goes out of scope.\nexport const getZapBufferWasm = (wasmMemory, bufferData, destructor, mutableDestructor) => {\n    var _a;\n    if (bufferData.readonly) {\n        if (!((_a = bufferCache[bufferData.arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            if (inTest) {\n                allocatedArcs[bufferData.arcPtr] = true;\n            }\n            const zapBuffer = new ZapBuffer(wasmMemory.buffer, bufferData);\n            bufferRegistry.register(zapBuffer, {\n                arcPtr: bufferData.arcPtr,\n                destructor,\n                /* no unregisterToken here since we never need to unregister */\n            });\n            bufferCache[bufferData.arcPtr] = new WeakRef(zapBuffer);\n        }\n        else {\n            // If we already hold a reference, decrement the Arc we were just given;\n            // otherwise we leak memory.\n            destructor(bufferData.arcPtr);\n        }\n        return bufferCache[bufferData.arcPtr].deref();\n    }\n    else {\n        if (inTest) {\n            allocatedVecs[bufferData.bufferPtr] = true;\n        }\n        const zapBuffer = new ZapBuffer(wasmMemory.buffer, bufferData);\n        mutableZapBufferRegistry.register(zapBuffer, {\n            bufferData,\n            destructor: mutableDestructor,\n        }, zapBuffer);\n        return zapBuffer;\n    }\n};\n// Remove mutable ZapBuffers without running destructors. This is useful\n// when transferring ownership of buffers to Rust without deallocating data.\nexport const unregisterMutableBuffer = (zapBuffer) => {\n    if (zapBuffer.readonly) {\n        throw new Error(\"`unregisterMutableBuffer` should only be called on mutable ZapBuffers\");\n    }\n    mutableZapBufferRegistry.unregister(zapBuffer);\n    if (inTest) {\n        allocatedVecs[zapBuffer.__zaplibBufferData.bufferPtr] = false;\n    }\n};\n// Return a buffer with a stable identity based on arcPtr\nexport const getZapBufferCef = (buffer, arcPtr, paramType) => {\n    var _a;\n    if (arcPtr) {\n        if (!((_a = bufferCache[arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            const zapBuffer = new ZapBuffer(buffer, {\n                bufferPtr: 0,\n                bufferLen: buffer.byteLength,\n                readonly: true,\n                paramType,\n                // TODO(Paras): These fields below do not apply to CEF\n                arcPtr: -1,\n            });\n            bufferRegistry.register(zapBuffer, { arcPtr });\n            bufferCache[arcPtr] = new WeakRef(zapBuffer);\n        }\n        return bufferCache[arcPtr].deref();\n    }\n    else {\n        return new ZapBuffer(buffer, {\n            bufferPtr: 0,\n            bufferLen: buffer.byteLength,\n            bufferCap: buffer.byteLength,\n            paramType,\n            readonly: false,\n        });\n    }\n};\n","// Zerde is our lightweight manual serialization/deserialization system.\n//\n// Keep in sync with zerde.rs, and see there for more information.\nimport { ZapParamType } from \"types\";\n// Construct a buffer that can be read in Rust, using the corresponding `ZerderParser` struct in Rust.\nexport class ZerdeBuilder {\n    constructor({ buffer, byteOffset, slots, growCallback, }) {\n        this._buffer = buffer;\n        this._byteOffset = byteOffset;\n        this._slots = slots;\n        this._growCallback = growCallback;\n        this._used = 2; // Skip 8 byte header which contains the size.\n        this._updateRefs();\n    }\n    _updateRefs() {\n        this._f32 = new Float32Array(this._buffer, this._byteOffset, this._slots);\n        this._u32 = new Uint32Array(this._buffer, this._byteOffset, this._slots);\n        this._f64 = new Float64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64 = new BigUint64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64[0] = BigInt(this._slots) * BigInt(4); // Write size to header.\n    }\n    _fit(slots) {\n        if (this._used + slots > this._slots) {\n            let newSlots = Math.max(this._used + slots, this._slots * 2); // Exponential growth\n            if (newSlots & 1)\n                newSlots++; // 64-bit align it\n            const newBytes = newSlots * 4;\n            const { buffer, byteOffset } = this._growCallback(this._buffer, this._byteOffset, newBytes);\n            this._buffer = buffer;\n            this._byteOffset = byteOffset;\n            this._slots = newSlots;\n            this._updateRefs();\n        }\n        const pos = this._used;\n        this._used += slots;\n        return pos;\n    }\n    sendF32(value) {\n        const pos = this._fit(1);\n        this._f32[pos] = value;\n    }\n    sendU32(value) {\n        const pos = this._fit(1);\n        this._u32[pos] = value;\n    }\n    sendF64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._f64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._f64[pos >> 1] = value;\n        }\n    }\n    sendU64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._u64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._u64[pos >> 1] = value;\n        }\n    }\n    sendString(str) {\n        let pos = this._fit(str.length + 1);\n        this._u32[pos++] = str.length;\n        for (let i = 0; i < str.length; i++) {\n            this._u32[pos++] = str.charCodeAt(i);\n        }\n    }\n    getData() {\n        return { buffer: this._buffer, byteOffset: this._byteOffset };\n    }\n}\nexport class ZerdeParser {\n    constructor(memory, zerdePtr) {\n        this._memory = memory;\n        // set up local shortcuts to the zerde memory chunk for faster parsing\n        this._usedSlots = 2; // skip the 8 byte header\n        this._f32 = new Float32Array(this._memory.buffer, zerdePtr);\n        this._u32 = new Uint32Array(this._memory.buffer, zerdePtr);\n        this._f64 = new Float64Array(this._memory.buffer, zerdePtr);\n        this._u64 = new BigUint64Array(this._memory.buffer, zerdePtr);\n    }\n    parseU32() {\n        return this._u32[this._usedSlots++];\n    }\n    parseF32() {\n        return this._f32[this._usedSlots++];\n    }\n    parseF64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._f64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseU64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._u64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseString() {\n        let str = \"\";\n        const len = this.parseU32();\n        for (let i = 0; i < len; i++) {\n            const c = this.parseU32();\n            if (c != 0)\n                str += String.fromCharCode(c);\n        }\n        return str;\n    }\n    parseU8Slice() {\n        const u8Len = this.parseU32();\n        const len = u8Len >> 2;\n        const data = new Uint8Array(u8Len);\n        const spare = u8Len & 3;\n        for (let i = 0; i < len; i++) {\n            const u8Pos = i << 2;\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n            data[u8Pos + 3] = (u32 >> 24) & 0xff;\n        }\n        const u8Pos = len << 2;\n        if (spare == 1) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n        }\n        else if (spare == 2) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n        }\n        else if (spare == 3) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n        }\n        return data;\n    }\n    parseZapParams() {\n        const len = this.parseU32();\n        const params = [];\n        for (let i = 0; i < len; ++i) {\n            const paramType = this.parseU32();\n            if (paramType === ZapParamType.String) {\n                params.push(this.parseString());\n            }\n            else if (paramType === ZapParamType.ReadOnlyU8Buffer ||\n                paramType === ZapParamType.ReadOnlyF32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const arcPtr = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    arcPtr,\n                    readonly: true,\n                });\n            }\n            else if (paramType === ZapParamType.U8Buffer ||\n                paramType === ZapParamType.F32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const bufferCap = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    bufferCap,\n                    readonly: false,\n                });\n            }\n            else {\n                throw new Error(`Unknown ZapParam type: ${paramType}`);\n            }\n        }\n        return params;\n    }\n}\n","// This file should only be imported by WebWorkers\n/// <reference lib=\"WebWorker\" />\nimport { ZapParamType, } from \"types\";\nimport { getCachedZapBuffer, getZapBufferWasm } from \"zap_buffer\";\nimport { ZerdeBuilder } from \"zerde\";\nconst RESPONSE = \"$$RESPONSE\";\nconst ERROR = \"$$ERROR\";\n// helper function to create linked channels for testing\nfunction _createLinkedChannels() {\n    const local = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (remote.onmessage) {\n                remote.onmessage(ev);\n            }\n        },\n    };\n    const remote = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (local.onmessage) {\n                local.onmessage(ev);\n            }\n        },\n    };\n    return { local, remote };\n}\n// This class allows you to hook up bi-directional async calls across web-worker\n// boundaries where a single call to or from a worker can 'wait' on the response.\n// Errors in receivers are propigated back to the caller as a rejection.\n// It also supports returning transferrables over the web-worker postMessage api,\n// which was the main shortcomming with the worker-rpc npm module.\n// To attach rpc to an instance of a worker in the main thread:\n//   const rpc = new Rpc(workerInstace);\n// To attach rpc within an a web worker:\n//   const rpc = new Rpc(global);\n// Check out the tests for more examples.\n// See `rpc_types.ts` for descriptions of how to set up typed interactions.\nexport class Rpc {\n    constructor(channel) {\n        this._messageId = 0;\n        this._pendingCallbacks = {};\n        this._receivers = new Map();\n        this._onChannelMessage = (ev) => {\n            const { id, topic, data } = ev.data;\n            if (topic === RESPONSE) {\n                this._pendingCallbacks[id](ev.data);\n                delete this._pendingCallbacks[id];\n                return;\n            }\n            // invoke the receive handler in a promise so if it throws synchronously we can reject\n            new Promise((resolve) => {\n                const handler = this._receivers.get(topic);\n                if (!handler) {\n                    throw new Error(`no receiver registered for ${topic}`);\n                }\n                // This works both when `handler` returns a value or a Promise.\n                resolve(handler(data));\n            })\n                .then((result) => {\n                if (!result) {\n                    this.postMessage({ topic: RESPONSE, id }, []);\n                    return;\n                }\n                const transferrables = result[Rpc.transferrables];\n                delete result[Rpc.transferrables];\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: result,\n                };\n                this.postMessage(message, transferrables);\n            })\n                .catch((err) => {\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: {\n                        [ERROR]: true,\n                        name: err.name,\n                        message: err.message,\n                        stack: err.stack,\n                    },\n                };\n                this.postMessage(message, []);\n            });\n        };\n        this._channel = channel;\n        if (this._channel.onmessage) {\n            throw new Error(\"channel.onmessage is already set. Can only use one Rpc instance per channel.\");\n        }\n        this._channel.onmessage = this._onChannelMessage;\n    }\n    // send a message across the rpc boundary to a receiver on the other side\n    // this returns a promise for the receiver's response.  If there is no registered\n    // receiver for the given topic, this method throws\n    send(topic, data, transfer) {\n        const id = this._messageId++;\n        const message = { topic, id, data };\n        const result = new Promise((resolve, reject) => {\n            this._pendingCallbacks[id] = (info) => {\n                if (info.data && info.data[ERROR]) {\n                    const error = new Error(info.data.message);\n                    error.name = info.data.name;\n                    error.stack = info.data.stack;\n                    reject(error);\n                }\n                else {\n                    resolve(info.data);\n                }\n            };\n        });\n        this.postMessage(message, transfer);\n        return result;\n    }\n    // register a receiver for a given message on a topic\n    // only one receiver can be registered per topic and currently\n    // 'deregistering' a receiver is not supported since this is not common\n    receive(topic, handler) {\n        if (this._receivers.has(topic)) {\n            throw new Error(`Receiver already registered for topic: ${topic}`);\n        }\n        this._receivers.set(topic, handler);\n    }\n    postMessage(message, transfer) {\n        try {\n            this._channel.postMessage(message, transfer);\n        }\n        catch (e) {\n            console.error(\"Rpc postMessage call itself failed: \", e);\n        }\n    }\n}\nRpc.transferrables = \"$$TRANSFERRABLES\";\n////////////////////////////////////////////////////////////////\n// Mutex\n////////////////////////////////////////////////////////////////\nconst MUTEX_UNLOCKED = 0;\nconst MUTEX_LOCKED = 1;\nexport const mutexLock = (sabi32, offset) => {\n    // This needs to be in a loop, because between the `wait` and `compareExchange` another thread might\n    // take the Mutex.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (Atomics.compareExchange(sabi32, offset, MUTEX_UNLOCKED, MUTEX_LOCKED) ==\n            MUTEX_UNLOCKED) {\n            return;\n        }\n        Atomics.wait(sabi32, offset, MUTEX_LOCKED);\n    }\n};\nexport const mutexUnlock = (sabi32, offset) => {\n    if (Atomics.compareExchange(sabi32, offset, MUTEX_LOCKED, MUTEX_UNLOCKED) !=\n        MUTEX_LOCKED) {\n        throw new Error(\"Called mutex_unlock on an already unlocked mutex\");\n    }\n    Atomics.notify(sabi32, offset, 1);\n};\n////////////////////////////////////////////////////////////////\n// Task worker\n////////////////////////////////////////////////////////////////\nexport const TW_SAB_MUTEX_PTR = 0;\nexport const TW_SAB_MESSAGE_COUNT_PTR = 1;\n// Initialize a SharedArrayBuffer used to communicate with task_worker.ts. This\n// is a one-way communication channel; use pointers into `memory` for communicating\n// information back.\n//\n// We use this because we typically can't use `postMessage`; see task_worker.ts\n// for more details.\n//\n// Format:\n// * i32 (4 bytes)         - read/write mutex\n// * i32 (4 bytes)         - number of messages in queue (notify on this to wake up the task worker - it will\n//                           read this before taking a mutex, but then reread it after taking the mutex)\n// * n * u32 (n * 4 bytes) - pointers to messages serialized with `ZerdeBuilder`\nexport const initTaskWorkerSab = () => {\n    const bufferSizeBytes = 10000;\n    const taskWorkerSab = new SharedArrayBuffer(bufferSizeBytes);\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    taskWorkerSabi32[TW_SAB_MUTEX_PTR] = MUTEX_UNLOCKED;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = 0;\n    return taskWorkerSab;\n};\n// Append a new message pointer to the SharedArrayBuffer used by task_worker.ts,\n// and wake it up so it can process this new message (unless it's currently in polling\n// mode, in that case the `Atomics.notify` will just not do anything).\nconst sendTaskWorkerMessage = (taskWorkerSab, twMessagePtr) => {\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    mutexLock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    const currentNumberOfMessages = taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR];\n    // Use unsigned numbers for the actual pointer, since they can be >2GB.\n    new Uint32Array(taskWorkerSab)[currentNumberOfMessages + 2] = twMessagePtr;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = currentNumberOfMessages + 1;\n    mutexUnlock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    Atomics.notify(taskWorkerSabi32, 1);\n};\n////////////////////////////////////////////////////////////////\n// Wasm Thread initialization\n////////////////////////////////////////////////////////////////\n// Threads in WebAssembly! They are.. fun! Here's what happens.\n//\n// The first Wasm instance we start is in the main worker. It does the following:\n// - It initializes static memory using `__wasm_init_memory`, which is automatically set\n//   by LLVM as the special \"start\" function.\n// - It already has memory allocated for the \"shadow stack\". This is like any stack in a\n//   native program, but in WebAssembly it's called the \"shadow stack\" because WebAssembly\n//   itself also has a notion of a stack built-in. It is however not suitable for all\n//   kinds of data, which is why we need another separate stack.\n// - We allocate Thread Local Storage (TLS) by allocating some memory on the heap (an\n//   operation which by itself should not require TLS; otherwise we'd have a Catch-22\n//   situation..), and calling `initThreadLocalStorageMainWorker` with it.\n//\n// Then, when we make any other WebAssembly threads (e.g. in our own WebWorkers, or in\n// the WebWorkers of users), we do the following:\n// - `__wasm_init_memory` is again called automatically, but will be skipped, since an\n//   (atomic) flag has been set not to initialize static memory again.\n// - We need to initialize memory for both the shadow stack and the Thread Local\n//   Storage (TLS), using `makeThreadLocalStorageAndStackDataOnExistingThread`. We do this\n//   by allocating memory on the heap on an already initialized thread, since allocating memory DOES\n//   require the shadow stack to be initialized.\n// - We then use this memory for both the TLS (on the lower side) and the shadow stack\n//   (on the upper side, since it moves downward), using `initThreadLocalStorageAndStackOtherWorkers`.\n//\n// TODO(JP): This currently leaks memory since we never deallocate the TLS/shadow stack!\n//\n// TODO(JP): Even if we do deallocate the memory, there is currently no way to call TLS\n// destructors; so we'd still leak memory. See https://github.com/rust-lang/rust/issues/77839\n// The \"shadow stack\" size for new threads. Note that the main thread will\n// keep using its own shadow stack size.\nconst WASM_STACK_SIZE_BYTES = 2 * 1024 * 1024; // 2 MB\n// For the main worker, we only need to initialize Thread Local Storage (TLS).\nexport const initThreadLocalStorageMainWorker = (wasmExports) => {\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(wasmExports.__tls_size.value));\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    wasmExports.__wasm_init_tls(Number(ptr));\n};\n// For non-main workers, we need to allocate enough data for Thread Local Storage (TLS)\n// and the \"shadow stack\". We allocate this data in the main worker, and then send the\n// pointer + size to other workers.\n//\n// This is easier than trying to allocate the appropriate amount of data in the other\n// itself, which is possible (e.g. using memory.grow) but kind of cumbersome.\nexport const makeThreadLocalStorageAndStackDataOnExistingThread = (wasmExports) => {\n    // Align size to 64 bits / 8 bytes.\n    const size = Math.ceil((wasmExports.__tls_size.value + WASM_STACK_SIZE_BYTES) / 8) * 8;\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(size));\n    return { ptr, size };\n};\n// Set the shadow stack pointer and initialize thet Thread Local Storage (TLS).\n//\n// Note that the TLS sits on the lower side of the memory, wheras the shadow stack\n// starts on the upper side of the memory and grows downwards.\n//\n// TODO(JP): __wasm_init_tls takes a Number, which might not work when it is >2GB.\nexport const initThreadLocalStorageAndStackOtherWorkers = (wasmExports, tlsAndStackData) => {\n    // Start the shadow stack pointer on the upper side of the memory, though subtract\n    // 8 so we don't overwrite the byte right after the memory, while still keeping it\n    // 64-bit aligned. TODO(JP): Is the 64-bit alignment necessary for the shadow stack?\n    wasmExports.__stack_pointer.value =\n        Number(tlsAndStackData.ptr) + tlsAndStackData.size - 8;\n    wasmExports.__wasm_init_tls(\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    Number(tlsAndStackData.ptr));\n};\n////////////////////////////////////////////////////////////////\n// Common wasm functions\n////////////////////////////////////////////////////////////////\nexport const copyArrayToRustBuffer = (inputBuffer, outputBuffer, outputPtr) => {\n    // should be the same type as inputBuffer\n    // @ts-ignore: constructor is getting typed as Function instead of a constructor\n    new inputBuffer.constructor(outputBuffer, outputPtr, inputBuffer.length).set(inputBuffer);\n};\nexport const getZapParamType = (array, readonly) => {\n    if (array instanceof Uint8Array) {\n        return readonly ? ZapParamType.ReadOnlyU8Buffer : ZapParamType.U8Buffer;\n    }\n    else if (array instanceof Float32Array) {\n        return readonly ? ZapParamType.ReadOnlyF32Buffer : ZapParamType.F32Buffer;\n    }\n    else {\n        throw new Error(\"Invalid array type\");\n    }\n};\nexport const createWasmBuffer = (memory, exports, data) => {\n    const vecPtr = Number(exports.allocWasmVec(BigInt(data.byteLength)));\n    copyArrayToRustBuffer(data, memory.buffer, vecPtr);\n    return vecPtr;\n};\nexport const makeZerdeBuilder = (memory, wasmExports) => {\n    const slots = 1024;\n    // We have get memory.buffer *after* calling `allocWasmMessage`, because\n    // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n    const byteOffset = Number(wasmExports.allocWasmMessage(BigInt(slots * 4)));\n    return new ZerdeBuilder({\n        buffer: memory.buffer,\n        byteOffset: byteOffset,\n        slots,\n        growCallback: (_buffer, oldByteOffset, newBytes) => {\n            const newByteOffset = Number(wasmExports.reallocWasmMessage(BigInt(oldByteOffset), BigInt(newBytes)));\n            // We have get memory.buffer *after* calling `reallocWasmMessage`, because\n            // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n            return { buffer: memory.buffer, byteOffset: newByteOffset };\n        },\n    });\n};\nexport const getWasmEnv = ({ getExports, memory, taskWorkerSab, fileHandles, sendEventFromAnyThread, threadSpawn, baseUri, }) => {\n    const parseString = (ptr, len) => {\n        let out = \"\";\n        // Can't use TextDecoder here since it doesn't work with SharedArrayBuffer.\n        // TODO(JP): If it becomes important enough, we can see if making a copy to a regular\n        // ArrayBuffer and then using TextDecoder is faster than what we do here.\n        const array = new Uint32Array(memory.buffer, ptr, len);\n        for (let i = 0; i < len; i++) {\n            out += String.fromCharCode(array[i]);\n        }\n        return out;\n    };\n    return {\n        memory,\n        _consoleLog: (charsPtr, len) => {\n            const out = parseString(parseInt(charsPtr), parseInt(len));\n            console.log(out);\n        },\n        _throwError: (charsPtr, len) => {\n            throw new RustPanic(parseString(parseInt(charsPtr), parseInt(len)));\n        },\n        readUserFileRange: (userFileId, bufPtr, bufLen, fileOffset) => {\n            const file = fileHandles[userFileId];\n            const start = Number(fileOffset);\n            const end = start + Number(bufLen);\n            if (file.lastReadStart <= start && start < file.lastReadEnd) {\n                console.warn(`Read start (${start}) fell in the range of the last read (${file.lastReadStart}-${file.lastReadEnd}); ` +\n                    \"this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.\");\n            }\n            file.lastReadStart = start;\n            file.lastReadEnd = end;\n            // TODO(JP): This creates a new buffer instead of reading directly into the wasm memory.\n            // Maybe we can avoid this by using a stream with a ReadableStreamBYOBReader, but that is\n            // asynchronous, so we'd have to do a dance with another thread and atomics and all that,\n            // and I don't know if that overhead would be worth it..\n            const fileReaderSync = new FileReaderSync();\n            const buffer = fileReaderSync.readAsArrayBuffer(file.file.slice(start, end));\n            copyArrayToRustBuffer(new Uint8Array(buffer), memory.buffer, Number(bufPtr));\n            return BigInt(buffer.byteLength);\n        },\n        performanceNow: () => {\n            return performance.now();\n        },\n        threadSpawn: (ctxPtr) => {\n            threadSpawn(ctxPtr);\n        },\n        _sendEventFromAnyThread: (eventPtr) => {\n            sendEventFromAnyThread(eventPtr);\n        },\n        readUrlSync: (urlPtr, urlLen, bufPtrOut, bufLenOut) => {\n            const url = parseString(urlPtr, urlLen);\n            const request = new XMLHttpRequest();\n            request.responseType = \"arraybuffer\";\n            request.open(\"GET\", new URL(url, baseUri).href, false /* synchronous */);\n            request.send(null);\n            if (request.status === 200) {\n                const exports = getExports();\n                const outputBufPtr = createWasmBuffer(memory, exports, new Uint8Array(request.response));\n                new Uint32Array(memory.buffer, bufPtrOut, 1)[0] = outputBufPtr;\n                new Uint32Array(memory.buffer, bufLenOut, 1)[0] =\n                    request.response.byteLength;\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        },\n        randomU64: () => new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],\n        sendTaskWorkerMessage: (twMessagePtr) => {\n            sendTaskWorkerMessage(taskWorkerSab, parseInt(twMessagePtr));\n        },\n    };\n};\nexport function transformParamsFromRustImpl(memory, destructor, mutableDestructor, params) {\n    return params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else {\n            const zapBuffer = getZapBufferWasm(memory, param, destructor, mutableDestructor);\n            if (param.paramType === ZapParamType.String) {\n                throw new Error(\"ZapParam buffer type called with string paramType\");\n            }\n            // These are actually ZapArray types, since we overwrite TypedArrays in overwriteTypedArraysWithZapArrays()\n            const ArrayConstructor = {\n                [ZapParamType.U8Buffer]: Uint8Array,\n                [ZapParamType.ReadOnlyU8Buffer]: Uint8Array,\n                [ZapParamType.F32Buffer]: Float32Array,\n                [ZapParamType.ReadOnlyF32Buffer]: Float32Array,\n            }[param.paramType];\n            return getCachedZapBuffer(zapBuffer, new ArrayConstructor(zapBuffer, param.bufferPtr, param.bufferLen / ArrayConstructor.BYTES_PER_ELEMENT));\n        }\n    });\n}\nexport function assertNotNull(value, objectName = \"Value\") {\n    if (value === null || value === undefined) {\n        throw new Error(`Assertion failed: ${objectName} is null`);\n    }\n    return value;\n}\nexport class RustPanic extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"RustPanic\";\n    }\n}\nexport const createErrorCheckers = (wasmInitialized) => {\n    const checkWasm = () => {\n        if (!wasmInitialized())\n            throw new Error(\"Zaplib WebAssembly instance crashed\");\n    };\n    return {\n        checkWasm,\n        wrapWasmExports: (exports) => new Proxy(exports, {\n            get: function (obj, prop) {\n                checkWasm();\n                return obj[prop];\n            },\n        }),\n    };\n};\n","export var WorkerEvent;\n(function (WorkerEvent) {\n    WorkerEvent[\"CallRust\"] = \"WorkerEvent.CallRust\";\n    WorkerEvent[\"CreateBuffer\"] = \"WorkerEvent.CreateBuffer\";\n    WorkerEvent[\"CreateReadOnlyBuffer\"] = \"WorkerEvent.CreateReadOnlyBuffer\";\n    WorkerEvent[\"BindMainWorkerPort\"] = \"WorkerEvent.BindMainWorkerPort\";\n    WorkerEvent[\"DecrementArc\"] = \"WorkerEvent.DecrementArc\";\n    WorkerEvent[\"DeallocVec\"] = \"WorkerEvent.DeallocVec\";\n    WorkerEvent[\"IncrementArc\"] = \"WorkerEvent.IncrementArc\";\n    WorkerEvent[\"DragEnter\"] = \"WorkerEvent.DragEnter\";\n    WorkerEvent[\"DragOver\"] = \"WorkerEvent.DragOver\";\n    WorkerEvent[\"DragLeave\"] = \"WorkerEvent.DragLeave\";\n    WorkerEvent[\"Drop\"] = \"WorkerEvent.Drop\";\n    WorkerEvent[\"WindowMouseUp\"] = \"WorkerEvent.WindowMouseUp\";\n    WorkerEvent[\"CanvasMouseDown\"] = \"WorkerEvent.CanvasMouseDown\";\n    WorkerEvent[\"WindowMouseMove\"] = \"WorkerEvent.WindowMouseMove\";\n    WorkerEvent[\"WindowMouseOut\"] = \"WorkerEvent.WindowMouseOut\";\n    WorkerEvent[\"WindowFocus\"] = \"WorkerEvent.WindowFocus\";\n    WorkerEvent[\"WindowBlur\"] = \"WorkerEvent.WindowBlur\";\n    WorkerEvent[\"ScreenResize\"] = \"WorkerEvent.ScreenResize\";\n    WorkerEvent[\"CanvasWheel\"] = \"WorkerEvent.CanvasWheel\";\n    WorkerEvent[\"ShowIncompatibleBrowserNotification\"] = \"WorkerEvent.ShowIncompatibleBrowserNotification\";\n    WorkerEvent[\"RemoveLoadingIndicators\"] = \"WorkerEvent.RemoveLoadingIndicators\";\n    WorkerEvent[\"SetDocumentTitle\"] = \"WorkerEvent.SetDocumentTitle\";\n    WorkerEvent[\"SetMouseCursor\"] = \"WorkerEvent.SetMouseCursor\";\n    WorkerEvent[\"Fullscreen\"] = \"WorkerEvent.Fullscreen\";\n    WorkerEvent[\"Normalscreen\"] = \"WorkerEvent.Normalscreen\";\n    WorkerEvent[\"TextCopyResponse\"] = \"WorkerEvent.TextCopyResponse\";\n    WorkerEvent[\"EnableGlobalFileDropTarget\"] = \"WorkerEvent.EnableGlobalFileDropTarget\";\n    WorkerEvent[\"CallJs\"] = \"WorkerEvent.CallJs\";\n    WorkerEvent[\"ShowTextIME\"] = \"WorkerEvent.ShowTextIME\";\n    WorkerEvent[\"TextInput\"] = \"WorkerEvent.TextInput\";\n    WorkerEvent[\"TextCopy\"] = \"WorkerEvent.TextCopy\";\n    WorkerEvent[\"KeyDown\"] = \"WorkerEvent.KeyDown\";\n    WorkerEvent[\"KeyUp\"] = \"WorkerEvent.KeyUp\";\n    WorkerEvent[\"Init\"] = \"WorkerEvent.Init\";\n    WorkerEvent[\"RunWebGL\"] = \"WorkerEvent.RunWebGL\";\n    WorkerEvent[\"ThreadSpawn\"] = \"WorkerEvent.ThreadSpawn\";\n    WorkerEvent[\"WindowTouchStart\"] = \"WorkerEvent.WindowTouchStart\";\n    WorkerEvent[\"WindowTouchMove\"] = \"WorkerEvent.WindowTouchMove\";\n    WorkerEvent[\"WindowTouchEndCancelLeave\"] = \"WorkerEvent.WindowTouchEndCancelLeave\";\n    WorkerEvent[\"Panic\"] = \"WorkerEvent.Panic\";\n})(WorkerEvent || (WorkerEvent = {}));\nexport var TaskWorkerEvent;\n(function (TaskWorkerEvent) {\n    TaskWorkerEvent[\"Init\"] = \"TaskWorkerEvent.Init\";\n})(TaskWorkerEvent || (TaskWorkerEvent = {}));\nexport var AsyncWorkerEvent;\n(function (AsyncWorkerEvent) {\n    AsyncWorkerEvent[\"Run\"] = \"AsyncWorkerEvent.Run\";\n    AsyncWorkerEvent[\"ThreadSpawn\"] = \"AsyncWorkerEvent.ThreadSpawn\";\n})(AsyncWorkerEvent || (AsyncWorkerEvent = {}));\nexport var MainWorkerChannelEvent;\n(function (MainWorkerChannelEvent) {\n    MainWorkerChannelEvent[\"Init\"] = \"MainWorkerChannelEvent.Init\";\n    MainWorkerChannelEvent[\"BindMainWorkerPort\"] = \"MainWorkerChannelEvent.BindMainWorkerPort\";\n    MainWorkerChannelEvent[\"CallRust\"] = \"MainWorkerChannelEvent.CallRust\";\n    MainWorkerChannelEvent[\"SendEventFromAnyThread\"] = \"MainWorkerChannelEvent.SendEventFromAnyThread\";\n})(MainWorkerChannelEvent || (MainWorkerChannelEvent = {}));\n","/// <reference lib=\"WebWorker\" />\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// The \"Zaplib WebWorker runtime\" exposes some common Zaplib functions inside your WebWorkers, like `callRust`.\n//\n// Include the output of this (zaplib_worker_runtime.js) at the start of each worker, and initialize the runtime\n// by calling `self.initializeWorker` with a `MessagePort` obtained by `newWorkerPort` (which is\n// available on `window` in the main browser thread, and in any worker that already has the runtime running). You\n// can pass the port to the worker using `postMessage`; just be sure to include it in the list of transferables.\n//\n// Currently this is only supported in WebAssembly, not when using CEF.\nimport { createErrorCheckers, createWasmBuffer, getWasmEnv, getZapParamType, initThreadLocalStorageAndStackOtherWorkers, makeZerdeBuilder, Rpc, transformParamsFromRustImpl, } from \"common\";\nimport { MainWorkerChannelEvent } from \"rpc_types\";\nimport { ZapParamType, } from \"types\";\nimport { inWorker } from \"type_of_runtime\";\nimport { getZapBufferWasm, isZapBuffer, overwriteTypedArraysWithZapArrays, unregisterMutableBuffer, ZapBuffer, checkValidZapArray, } from \"zap_buffer\";\nimport { ZerdeParser } from \"zerde\";\nlet rpc;\nlet wasmExports;\nlet wasmMemory;\nlet wasmAppPtr;\nlet alreadyCalledInitialize = false;\nlet wasmOnline;\nconst wasmInitialized = () => Atomics.load(wasmOnline, 0) === 1;\nconst { checkWasm, wrapWasmExports } = createErrorCheckers(wasmInitialized);\nexport const initializeWorker = (zapWorkerPort) => {\n    if (alreadyCalledInitialize) {\n        throw new Error(\"Only call zaplib.initializeWorker once\");\n    }\n    alreadyCalledInitialize = true;\n    if (!inWorker) {\n        throw new Error(\"zaplib.initializeWorker() can only be called in a WebWorker\");\n    }\n    overwriteTypedArraysWithZapArrays();\n    return new Promise((resolve) => {\n        rpc = new Rpc(zapWorkerPort);\n        rpc\n            .send(MainWorkerChannelEvent.Init)\n            .then(({ wasmModule, memory, taskWorkerSab, baseUri, appPtr, tlsAndStackData, wasmOnline: _wasmOnline, }) => {\n            wasmOnline = _wasmOnline;\n            wasmMemory = memory;\n            wasmAppPtr = appPtr;\n            function getExports() {\n                return wasmExports;\n            }\n            const env = getWasmEnv({\n                getExports,\n                memory,\n                taskWorkerSab,\n                fileHandles: [],\n                sendEventFromAnyThread: (eventPtr) => {\n                    rpc.send(MainWorkerChannelEvent.SendEventFromAnyThread, eventPtr);\n                },\n                threadSpawn: () => {\n                    throw new Error(\"Not yet implemented\");\n                },\n                baseUri,\n            });\n            WebAssembly.instantiate(wasmModule, { env }).then((instance) => {\n                initThreadLocalStorageAndStackOtherWorkers(instance.exports, tlsAndStackData);\n                wasmExports = wrapWasmExports(instance.exports);\n                resolve();\n            });\n        });\n    });\n};\nconst destructor = (arcPtr) => {\n    wasmExports.decrementArc(BigInt(arcPtr));\n};\nconst mutableDestructor = ({ bufferPtr, bufferLen, bufferCap, }) => {\n    wasmExports.deallocVec(BigInt(bufferPtr), BigInt(bufferLen), BigInt(bufferCap));\n};\nconst transformParamsFromRust = (params) => transformParamsFromRustImpl(wasmMemory, destructor, mutableDestructor, params);\nexport const newWorkerPort = () => {\n    const channel = new MessageChannel();\n    rpc.send(MainWorkerChannelEvent.BindMainWorkerPort, channel.port1, [\n        channel.port1,\n    ]);\n    return channel.port2;\n};\n// TODO(JP): Allocate buffers on the wasm memory directly here.\nexport const callRust = (name, params = []) => __awaiter(void 0, void 0, void 0, function* () {\n    checkWasm();\n    const transformedParams = params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else if (isZapBuffer(param.buffer)) {\n            checkValidZapArray(param);\n            return serializeZapArrayForPostMessage(param);\n        }\n        else {\n            if (!(param.buffer instanceof SharedArrayBuffer)) {\n                console.warn(\"Consider passing Uint8Arrays backed by ZapBuffer or SharedArrayBuffer into `callRust` to prevent copying data\");\n            }\n            return param;\n        }\n    });\n    return transformParamsFromRust(yield rpc.send(MainWorkerChannelEvent.CallRust, {\n        name,\n        params: transformedParams,\n    }));\n});\n// TODO(JP): Some of this code is duplicated with callRust/call_js; see if we can reuse some.\nexport const callRustInSameThreadSync = (name, params = []) => {\n    checkWasm();\n    const zerdeBuilder = makeZerdeBuilder(wasmMemory, wasmExports);\n    zerdeBuilder.sendString(name);\n    zerdeBuilder.sendU32(params.length);\n    for (const param of params) {\n        if (typeof param === \"string\") {\n            zerdeBuilder.sendU32(ZapParamType.String);\n            zerdeBuilder.sendString(param);\n        }\n        else {\n            if (param.buffer instanceof ZapBuffer) {\n                checkValidZapArray(param);\n                if (param.buffer.__zaplibBufferData.readonly) {\n                    zerdeBuilder.sendU32(getZapParamType(param, true));\n                    const arcPtr = param.buffer.__zaplibBufferData.arcPtr;\n                    // ZapParam parsing code will construct an Arc without incrementing\n                    // the count, so we do it here ahead of time.\n                    wasmExports.incrementArc(BigInt(arcPtr));\n                    zerdeBuilder.sendU32(arcPtr);\n                }\n                else {\n                    // TODO(Paras): User should not be able to access the buffer after\n                    // passing it to Rust here\n                    unregisterMutableBuffer(param.buffer);\n                    zerdeBuilder.sendU32(getZapParamType(param, false));\n                    zerdeBuilder.sendU32(param.buffer.__zaplibBufferData.bufferPtr);\n                    zerdeBuilder.sendU32(param.buffer.__zaplibBufferData.bufferLen);\n                    zerdeBuilder.sendU32(param.buffer.__zaplibBufferData.bufferCap);\n                }\n            }\n            else {\n                console.warn(\"Consider passing Uint8Arrays backed by ZapBuffer to prevent copying data\");\n                const vecLen = param.byteLength;\n                const vecPtr = createWasmBuffer(wasmMemory, wasmExports, param);\n                zerdeBuilder.sendU32(getZapParamType(param, false));\n                zerdeBuilder.sendU32(vecPtr);\n                zerdeBuilder.sendU32(vecLen);\n                zerdeBuilder.sendU32(vecLen);\n            }\n        }\n    }\n    const returnPtr = wasmExports.callRustInSameThreadSync(wasmAppPtr, BigInt(zerdeBuilder.getData().byteOffset));\n    const zerdeParser = new ZerdeParser(wasmMemory, Number(returnPtr));\n    const returnParams = zerdeParser.parseZapParams();\n    return transformParamsFromRust(returnParams);\n};\n// TODO(JP): See comment at CreateBufferWorkerSync type.\nexport const createMutableBuffer = (data) => {\n    checkWasm();\n    const bufferLen = data.byteLength;\n    const bufferPtr = createWasmBuffer(wasmMemory, wasmExports, data);\n    return transformParamsFromRust([\n        {\n            paramType: getZapParamType(data, false),\n            bufferPtr,\n            bufferLen,\n            bufferCap: bufferLen,\n            readonly: false,\n        },\n    ])[0];\n};\n// TODO(JP): See comment at CreateBufferWorkerSync type.\nexport const createReadOnlyBuffer = (data) => {\n    checkWasm();\n    const bufferPtr = createWasmBuffer(wasmMemory, wasmExports, data);\n    const paramType = getZapParamType(data, true);\n    const arcPtr = Number(wasmExports.createArcVec(BigInt(bufferPtr), BigInt(data.length), BigInt(paramType)));\n    return transformParamsFromRust([\n        {\n            paramType,\n            bufferPtr,\n            bufferLen: data.byteLength,\n            arcPtr,\n            readonly: true,\n        },\n    ])[0];\n};\n// TODO(JP): Somewhat duplicated with the other implementation.\nexport const serializeZapArrayForPostMessage = (zapArray) => {\n    if (!(typeof zapArray === \"object\" && isZapBuffer(zapArray.buffer))) {\n        throw new Error(\"Only pass Zap arrays to serializeZapArrayForPostMessage\");\n    }\n    const zapBuffer = zapArray.buffer;\n    if (zapBuffer.__zaplibBufferData.readonly) {\n        wasmExports.incrementArc(BigInt(zapBuffer.__zaplibBufferData.arcPtr));\n    }\n    else {\n        unregisterMutableBuffer(zapBuffer);\n    }\n    return {\n        bufferData: zapBuffer.__zaplibBufferData,\n        byteOffset: zapArray.byteOffset,\n        byteLength: zapArray.byteLength,\n    };\n};\nexport const deserializeZapArrayFromPostMessage = (postMessageData) => {\n    const zapBuffer = getZapBufferWasm(wasmMemory, postMessageData.bufferData, destructor, mutableDestructor);\n    return new Uint8Array(zapBuffer, postMessageData.byteOffset, postMessageData.byteLength);\n};\n"],"names":["root","factory","exports","module","define","amd","self","ZapParamType","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","inWorker","importScripts","ZapBuffer","SharedArrayBuffer","constructor","buffer","bufferData","super","this","__zaplibWasmBuffer","__zaplibBufferData","readonly","byteLength","slice","args","zapBufferExtends","cls","ZapTypedArray","length","bufferPtr","Math","floor","bufferLen","BYTES_PER_ELEMENT","Error","__zaplibBuffer","subarray","begin","end","byteOffset","classesToExtend","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint16ClampedArray","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","DataView","zapCls","entries","containsZapBuffer","object","Array","isArray","Set","Map","entry","getPrototypeOf","patchPostMessage","origPostMessage","postMessage","apply","zapBufferCache","WeakMap","isZapBuffer","potentialZapBuffer","checkValidZapArray","zapArray","paramType","getZapParamType","bufferCache","bufferRegistry","FinalizationRegistry","arcPtr","destructor","mutableZapBufferRegistry","getZapBufferWasm","wasmMemory","mutableDestructor","_a","deref","zapBuffer","register","WeakRef","unregisterMutableBuffer","unregister","ZerdeBuilder","slots","growCallback","_buffer","_byteOffset","_slots","_growCallback","_used","_updateRefs","_f32","_u32","_f64","_u64","BigInt","_fit","newSlots","max","newBytes","pos","sendF32","sendU32","sendF64","sendU64","sendString","str","i","charCodeAt","getData","ZerdeParser","memory","zerdePtr","_memory","_usedSlots","parseU32","parseF32","parseF64","ret","parseU64","parseString","len","c","String","fromCharCode","parseU8Slice","u8Len","data","spare","u8Pos","u32","parseZapParams","params","push","ReadOnlyU8Buffer","ReadOnlyF32Buffer","U8Buffer","F32Buffer","bufferCap","RESPONSE","ERROR","Rpc","channel","_messageId","_pendingCallbacks","_receivers","_onChannelMessage","ev","id","topic","Promise","resolve","handler","then","result","transferrables","message","catch","err","name","stack","_channel","onmessage","send","transfer","reject","info","error","receive","has","set","e","console","copyArrayToRustBuffer","inputBuffer","outputBuffer","outputPtr","array","createWasmBuffer","vecPtr","Number","allocWasmVec","RustPanic","WorkerEvent","TaskWorkerEvent","AsyncWorkerEvent","MainWorkerChannelEvent","rpc","wasmExports","wasmAppPtr","wasmOnline","alreadyCalledInitialize","checkWasm","wrapWasmExports","wasmInitialized","Atomics","load","Proxy","createErrorCheckers","initializeWorker","zapWorkerPort","Worker","MessagePort","overwriteTypedArraysWithZapArrays","Init","wasmModule","taskWorkerSab","baseUri","appPtr","tlsAndStackData","_wasmOnline","env","getExports","fileHandles","sendEventFromAnyThread","threadSpawn","ptr","out","_consoleLog","charsPtr","parseInt","log","_throwError","readUserFileRange","userFileId","bufPtr","bufLen","fileOffset","file","start","lastReadStart","lastReadEnd","warn","FileReaderSync","readAsArrayBuffer","performanceNow","performance","now","ctxPtr","_sendEventFromAnyThread","eventPtr","readUrlSync","urlPtr","urlLen","bufPtrOut","bufLenOut","url","request","XMLHttpRequest","responseType","open","URL","href","status","outputBufPtr","response","randomU64","crypto","getRandomValues","sendTaskWorkerMessage","twMessagePtr","taskWorkerSabi32","sabi32","offset","compareExchange","wait","mutexLock","currentNumberOfMessages","notify","mutexUnlock","getWasmEnv","SendEventFromAnyThread","WebAssembly","instantiate","instance","__stack_pointer","size","__wasm_init_tls","initThreadLocalStorageAndStackOtherWorkers","decrementArc","deallocVec","transformParamsFromRust","map","param","ArrayConstructor","fallbackArray","getCachedZapBuffer","transformParamsFromRustImpl","newWorkerPort","MessageChannel","BindMainWorkerPort","port1","port2","callRust","thisArg","_arguments","generator","transformedParams","serializeZapArrayForPostMessage","CallRust","P","fulfilled","step","next","rejected","done","callRustInSameThreadSync","zerdeBuilder","allocWasmMessage","oldByteOffset","newByteOffset","reallocWasmMessage","makeZerdeBuilder","incrementArc","vecLen","returnPtr","returnParams","createMutableBuffer","createReadOnlyBuffer","createArcVec","deserializeZapArrayFromPostMessage","postMessageData"],"sourceRoot":""}