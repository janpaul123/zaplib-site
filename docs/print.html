<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Zaplib docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="basic_tooling.html"><strong aria-hidden="true">3.</strong> Basic Tooling</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic APIs</li><li class="chapter-item expanded "><a href="tutorial_hello_world_console.html"><strong aria-hidden="true">4.</strong> Tutorial: Hello World Console</a></li><li class="chapter-item expanded "><a href="tutorial_hello_thread.html"><strong aria-hidden="true">5.</strong> Tutorial: Hello Thread, Hello File</a></li><li class="chapter-item expanded "><a href="basic_api_overview.html"><strong aria-hidden="true">6.</strong> API Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">JS-Rust Bridge</li><li class="chapter-item expanded "><a href="tutorial_js_rust_bridge.html"><strong aria-hidden="true">7.</strong> Tutorial: Integrating with JS</a></li><li class="chapter-item expanded "><a href="tutorial_sharing_data.html"><strong aria-hidden="true">8.</strong> Tutorial: Sharing Data</a></li><li class="chapter-item expanded "><a href="bridge_api.html"><strong aria-hidden="true">9.</strong> API Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bridge_api_basics.html"><strong aria-hidden="true">9.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="bridge_api_params.html"><strong aria-hidden="true">9.2.</strong> Types of Parameters</a></li><li class="chapter-item expanded "><a href="bridge_api_workers.html"><strong aria-hidden="true">9.3.</strong> Web Workers</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Rendering</li><li class="chapter-item expanded "><a href="tutorial_hello_world_canvas.html"><strong aria-hidden="true">10.</strong> Tutorial: Hello World Canvas</a></li><li class="chapter-item expanded "><a href="tutorial_2d_rendering.html"><strong aria-hidden="true">11.</strong> Tutorial: Rendering 2D Shapes</a></li><li class="chapter-item expanded "><a href="tutorial_3d_rendering.html"><strong aria-hidden="true">12.</strong> Tutorial: Rendering 3D Meshes</a></li><li class="chapter-item expanded "><a href="rendering_api_overview.html"><strong aria-hidden="true">13.</strong> API Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rendering_api_overview_model.html"><strong aria-hidden="true">13.1.</strong> Rendering model</a></li><li class="chapter-item expanded "><a href="rendering_api_events_overview.html"><strong aria-hidden="true">13.2.</strong> Events</a></li><li class="chapter-item expanded "><a href="rendering_api_overview_geometry.html"><strong aria-hidden="true">13.3.</strong> Geometry</a></li><li class="chapter-item expanded "><a href="rendering_api_shaders.html"><strong aria-hidden="true">13.4.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="rendering_api_drawing.html"><strong aria-hidden="true">13.5.</strong> Drawing</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">UI</li><li class="chapter-item expanded "><a href="tutorial_ui_components.html"><strong aria-hidden="true">14.</strong> Tutorial: UI Components</a></li><li class="chapter-item expanded "><a href="tutorial_ui_layout.html"><strong aria-hidden="true">15.</strong> Tutorial: UI Layout</a></li><li class="chapter-item expanded "><a href="ui_api_overview.html"><strong aria-hidden="true">16.</strong> API Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ui_api_overview_components.html"><strong aria-hidden="true">16.1.</strong> UI Components</a></li><li class="chapter-item expanded "><a href="ui_api_overview_layout.html"><strong aria-hidden="true">16.2.</strong> Layout</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="known_issues.html"><strong aria-hidden="true">17.</strong> Known Issues</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Zaplib docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Zaplib</strong> is an open-source library for speeding up web applications using Rust and WebAssembly. It lets you write high-performance code in Rust, alongside your existing JavaScript code, using simple APIs.</p>
<p>The goal of Zaplib is to make it easy to build performance-intensive applications in the browser. While it is possible to make JavaScript run fast, over time it may become hard to manage lots of optimizations. In Rust you tend to need way fewer optimizations to get to similar or even higher levels of performance, allowing you to focus on actually building stuff.</p>
<p>The idea is to start with your existing web-based codebase, and incrementally move pieces of code over to Zaplib:</p>
<ul>
<li>You might start with a small computation;</li>
<li>then port some 2d/3d rendering;</li>
<li>then move over some UI elements;</li>
<li>and so on.</li>
</ul>
<p>Over time, you could port your entire codebase over to Rust, or you might keep JavaScript and Rust code side-by-side.</p>
<p>At this point Zaplib should be considered in an &quot;alpha&quot; state. It still has quite a few issues, but it's rapidly improving. If you want to use this library in production, please <a href="/">contact us</a>.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Zaplib roughly consists of these parts:</p>
<ol>
<li><strong>Basic APIs.</strong> A &quot;standard library&quot; for WebAssembly: console logging, low-level multithreading, HTTP requests, file reading, and so on.</li>
<li><strong>JS-Rust bridge.</strong> Communicating data between JS and Rust.</li>
<li><strong>Rendering.</strong> Low-level GPU-based 2d and 3d rendering APIs, and eventing.</li>
<li><strong>UI.</strong> UI components, layout engine, animation.</li>
</ol>
<p>Current development is mostly focused on 1-3, and at this point we recommend to keep using JavaScript/CSS for UI elements. But in the future we aim to support building entire applications fully within Zaplib.</p>
<p>The focus of Zaplib is on WebAssembly, but it also runs natively on various systems. This is useful while developing and testing components in isolation, comparable to using <a href="https://storybook.js.org/">Storybook</a>.</p>
<p>Zaplib runs on the following platforms:</p>
<ol>
<li><strong>WebAssembly / WebGL.</strong> Tested on recent versions of Chrome, Firefox, Edge, and Safari — though there are some known issues.</li>
<li><strong>Mac OS X / Metal.</strong> Tested on 11.6 Big Sur (on Intel mostly).</li>
<li><strong>Linux / OpenGL.</strong> Not well supported; some APIs missing; but should run.</li>
<li><strong>Windows / DirectX 11.</strong> Currently broken.. (sorry!)</li>
</ol>
<p>There is also a highly experimental feature where we embed a <a href="https://en.wikipedia.org/wiki/Chromium_(web_browser)">Chromium</a> instance in a desktop build. This is similar to running Rust code alongside JavaScript in a browser using WebAssembly, except that your Rust code runs completely natively instead of in WebAssembly. Rendering is also done natively instead of using WebGL. This is generally more performant, and makes it easier to attach debuggers and profilers. We do not recommend using this in production yet, but it can be useful for debugging.</p>
<h2 id="team"><a class="header" href="#team">Team</a></h2>
<p>The open source core team consists of:</p>
<table style="margin: 0">
    <tr style="vertical-align: top">
        <td><a href="https://github.com/janpaul123"><img style="width: 150px; max-width: 150px" src="./img/jp.jpg"><br>JP Posma (Zaplib)</a></td>
        <td><a href="https://github.com/stevekrouse"><img style="width: 150px; max-width: 150px" src="./img/steve.jpg"><br>Steve Krouse (Zaplib)</a></td>
        <td><a href="https://github.com/disambiguator"><img style="width: 150px; max-width: 150px" src="./img/paras.jpg"><br>Paras Sanghavi (Cruise)</a></td>
    </tr>
    <tr style="vertical-align: top">
        <td><a href="https://github.com/hhsaez"><img style="width: 150px; max-width: 150px" src="./img/hernan.png"><br>Hernan Saez (Cruise)</a></td>
        <td><a href="https://github.com/pankdm"><img style="width: 150px; max-width: 150px" src="./img/dmitry.jpg"><br>Dmitry Panin (Cruise)</a></td>
    </tr>
</table>
<p>Also a big shoutout to the <a href="https://github.com/makepad/makepad">Makepad</a> folks, whose open source framework we originally forked and with whom we've had a fruitful collaboration ever since.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Zaplib is distributed under the terms of both the MIT license and the Apache License (version 2.0).</p>
<p>See <code>LICENSE-APACHE</code> and <code>LICENSE-MIT</code> in the repo root for details. Third party license notices are available in <code>LICENSES-THIRD-PARTY</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>First let's install some dependencies:</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Install Rust</a></li>
<li>Clone the repo: <code>git clone https://github.com/Zaplib/zaplib.git</code></li>
<li>Navigate to the repo: <code>cd zaplib</code></li>
<li>Install the Cargo extension for Zaplib <code>cargo install cargo-zaplib</code></li>
<li>Run the dependency installation using Zaplib Cargo tool <code>cargo zaplib install-deps</code>
<ul>
<li>If you're going to do local development of Zaplib, be sue to add the <code>--devel</code> flag which installs some more dependencies, like <a href="https://github.com/chromiumembedded">CEF</a> binaries.</li>
</ul>
</li>
</ul>
<p>Now you're ready to run a simple example natively. Here are some fun ones to play with:</p>
<ul>
<li><code>cargo run -p example_single_button</code></li>
<li><code>cargo run -p example_charts</code></li>
<li><code>cargo run -p example_text</code></li>
<li><code>cargo run -p example_lightning</code> (heavy; best to do a release build; see below)</li>
<li><code>cargo run -p example_bigedit</code> (heavy; best to do a release build; see below)</li>
</ul>
<p>For a more performant build, add the <code>--release</code> flag, e.g.:</p>
<ul>
<li><code>cargo run -p example_single_button --release</code></li>
</ul>
<p>Of course, Zaplib is primarily a framework for WebAssembly, so let's run these examples in a browser:</p>
<ul>
<li>Download the latest version of a modern browser, like <a href="https://www.google.com/chrome/">Chrome</a>.</li>
<li>In a separate terminal window, run a basic server: <code>zaplib/scripts/server.py</code> (Note that this still requires Python 2).</li>
<li>In another separate terminal window, start yarn to build the Zaplib javascript files:
<ul>
<li><code>cd zaplib/web &amp;&amp; yarn &amp;&amp; yarn watch</code></li>
</ul>
</li>
<li>Build one of the examples using the Zaplib Cargo tool, e.g.:
<ul>
<li><code>cargo zaplib build -p example_single_button</code></li>
</ul>
</li>
<li>Navigate your browser to:
<ul>
<li><a href="http://localhost:3000/zaplib/examples/example_single_button"><code>http://localhost:3000/zaplib/examples/example_single_button</code></a></li>
</ul>
</li>
<li>Again, for a more performant build, add the <code>--release</code> flag, e.g.:
<ul>
<li><code>cargo zaplib build -p example_single_button --release</code></li>
</ul>
</li>
<li>With a release build, add a <code>?release</code> flag to the URL:
<ul>
<li><a href="http://localhost:3000/zaplib/examples/example_single_button/?release"><code>http://localhost:3000/zaplib/examples/example_single_button/?release</code></a></li>
</ul>
</li>
</ul>
<p>Feel free to check out the <code>examples</code> directory for more examples to play with!</p>
<p>To view automatically generated API documentation, run:</p>
<ul>
<li><code>zaplib/scripts/build_rustdoc.sh</code></li>
</ul>
<p>If you're wondering what to do next, here are some options:</p>
<ul>
<li>Set up your <a href="./basic_tooling.html">tooling</a>.</li>
<li>Dive into some tutorials.</li>
<li>Look at the code for one of the examples (<code>example_single_button</code> is a great simple one to start with) and try to modify it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-tooling"><a class="header" href="#basic-tooling">Basic Tooling</a></h1>
<p>Now that you're able to <a href="./getting_started.html">run some examples</a>, lets set up your development environment.</p>
<h2 id="editor-vscode"><a class="header" href="#editor-vscode">Editor: VSCode</a></h2>
<ul>
<li>We currently recommend using <a href="https://code.visualstudio.com/">VSCode</a>. In the future we'll add guides for other editors/IDEs.</li>
<li>After installing VSCode, open up <code>workspace.code-workspace</code> in the root of the repo. VSCode will prompt you to install our recommended extensions.</li>
<li>We recommend NOT installing the official Rust extension since it conflicts with <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer"><code>matklad.rust-analyzer</code></a>. If you already have it installed, it's best to disable it.</li>
<li>Feel free to copy the settings from <code>workspace.code-workspace</code> to your own projects!</li>
</ul>
<p>If you go to the &quot;Run and Debug&quot; tab in VSCode, you should see a bunch of preconfigured run profiles at the top of the screen (from <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a>).</p>
<h2 id="chrome-debugging"><a class="header" href="#chrome-debugging">Chrome debugging</a></h2>
<p>To get Rust source maps when doing local development in <a href="https://www.google.com/chrome/">Chrome</a>:</p>
<ul>
<li>Install <a href="https://goo.gle/wasm-debugging-extension">this extension</a>.</li>
<li>Open Chrome DevTools, click the gear (⚙) icon in the top right corner of DevTools pane, go to the Experiments panel and tick <strong>WebAssembly Debugging: Enable DWARF support</strong>. (See also <a href="https://developer.chrome.com/blog/wasm-debugging-2020/">this article</a>).</li>
</ul>
<p>Note that these source maps read from hardcoded local file paths, so they'll only work on the computer that you've compiled on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-hello-world-console"><a class="header" href="#tutorial-hello-world-console">Tutorial: Hello World Console</a></h1>
<p>Let's write the most basic application: printing &quot;Hello, world!&quot; to the console.</p>
<p>Either create a new folder in <code>zaplib/examples</code>, or follow along with the existing <code>tutorial_hello_world_console</code>.</p>
<p>First, let's create our <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;tutorial_hello_world_console&quot;
version = &quot;0.0.1&quot;
edition = &quot;2021&quot;

[dependencies]
zaplib = { path=&quot;../../main&quot; }
</code></pre>
<p>Now, let's create <code>src/main.rs</code>:</p>
<pre><code class="language-rust noplayground">use zaplib::*;

#[derive(Default)]
struct App {}

impl App {
    fn new(_cx: &amp;mut Cx) -&gt; Self {
        Self::default()
    }

    fn handle(&amp;mut self, _cx: &amp;mut Cx, event: &amp;mut Event) {
        if let Event::Construct = event {
            log!(&quot;Hello, world!&quot;);
        }
    }
    fn draw(&amp;mut self, _cx: &amp;mut Cx) {}
}

main_app!(App);
</code></pre>
<p>Let's break it down a bit. The app must be a <code>struct</code> that implement three methods:</p>
<ul>
<li><code>new</code> — Returns an initialized struct and any initial state we add. For now, let's call the <code>default</code> implementation.</li>
<li><code>handle</code> — An entrypoint into Zaplib's event handling system. We will go in depth on various event types in a different tutorial. For now, we'll put our <code>log!()</code> call in the the <code>Construct</code> event.</li>
<li><code>draw</code> — Called when requesting a draw. This will control what gets shown on the application window, which we don't use yet.</li>
</ul>
<p>The call to <code>main_app!()</code> tells Zaplib to use the <code>App</code> struct for all its eventing and rendering.</p>
<p>This is already enough to run the native version: <code>cargo run -p tutorial_hello_world_console</code>. Hurray! It prints &quot;Hello, world!&quot;.</p>
<p>Notice how this program currently never exits on its own. That behavior is similar to the web version, where the program doesn't exit until the browser window is closed. In our case here we don't have a native window yet, so terminate the program using CTRL+C.</p>
<h3 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h3>
<p>Now let's add an <code>index.html</code>:</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;/zaplib/web/dist/zaplib_runtime.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        zaplib.initialize({
            filename: 'target/wasm32-unknown-unknown/debug/tutorial_hello_world_console.wasm',
            defaultStyles: true,
        });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>Compile to WebAssembly: <code>zaplib/scripts/build_wasm.sh -p tutorial_hello_world_console</code></p>
<p>Be sure to run the server, as described in <a href="./getting_started.html">Getting Started</a>.</p>
<p>Navigate to <a href="http://localhost:5000/zaplib/examples/tutorial_hello_world_console">http://localhost:5000/zaplib/examples/tutorial_hello_world_console</a>, open the browser console, and again, see how it has printed &quot;Hello, world!&quot;.</p>
<p>Congratulations, you've written your first Zaplib program! 😄</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-hello-thread-hello-file"><a class="header" href="#tutorial-hello-thread-hello-file">Tutorial: Hello Thread, Hello File</a></h1>
<p>This tutorial builds on top of the previous <a href="./tutorial_hello_world_console.html">Hello World</a> tutorial, by modifying it. Let's do some more stuff.</p>
<p>First, let's replace our &quot;Hello, world!&quot; logging, with spawning some threads:</p>
<pre><code class="language-rust noplayground">for i in 0..3 {
    universal_thread::spawn(move || {
        log!(&quot;Hello, world! {i}&quot;);
    });
}
</code></pre>
<p><code>universal_thread</code> is our abstraction that works just like Rust's <a href="https://doc.rust-lang.org/std/thread/">std::thread</a>, but with added support for WebAssembly.</p>
<p>When running this (either natively or in WebAssembly), you will see something like:</p>
<pre><code>zaplib/examples/tutorial_hello_world_console/src/main.rs:22 - Hello, world! 2
zaplib/examples/tutorial_hello_world_console/src/main.rs:22 - Hello, world! 0
zaplib/examples/tutorial_hello_world_console/src/main.rs:22 - Hello, world! 1
</code></pre>
<p>If you run it multiple times you'll see different orderings, since it's not deterministic which thread prints first.</p>
<p>Notice how relatively easy it was to spawn some threads, and transfer data into them (<code>i</code>), compared with using Web Workers and <code>postMessage</code>! Threading is still fairly advanced Rust, but in our experience, once you've gotten used to it, it ends up quite a bit easier to work with than threading in JavaScript.</p>
<h2 id="reading-files"><a class="header" href="#reading-files">Reading files</a></h2>
<p>Let's read some files! In Rust, you would normally use the <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>std::file::File</code></a> object, but again, that is not available in WebAssembly. So instead, we use our <code>UniversalFile</code> abstraction. We read and print our <code>Cargo.toml</code> file:</p>
<pre><code class="language-rust noplayground">// Top of the file:
use std::io::Read;

// Replace the logging code with:
let path = &quot;zaplib/examples/tutorial_hello_world_console/Cargo.toml&quot;;
let mut file = UniversalFile::open(path).unwrap();
let mut contents = String::new();
file.read_to_string(&amp;mut contents).unwrap();
log!(&quot;Contents of Cargo.toml: {contents}&quot;);
</code></pre>
<p>This should now print the contents of Cargo.toml, both natively and in WebAssembly.</p>
<p>Note that this is a synchronous API, so it will block further execution. JavaScript typically solves this by using <code>Promise</code>s, potentially combined with <code>async</code> and <code>await</code>. In Rust — and native programming in general — we can solve this by instead putting our synchronous code in a thread:</p>
<pre><code class="language-rust noplayground">universal_thread::spawn(|| {
    let path = &quot;zaplib/examples/tutorial_hello_world_console/Cargo.toml&quot;;
    let mut file = UniversalFile::open(path).unwrap();
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();
    log!(&quot;Contents of Cargo.toml: {contents}&quot;);
}
</code></pre>
<p>Since we're using a standard API interface, this code will work with any library that accepts a <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>std::io::Read</code></a> object, as opposed to WebAssembly libraries that expose more exotic asynchronous APIs.</p>
<h2 id="drag--drop-files"><a class="header" href="#drag--drop-files">Drag &amp; drop files</a></h2>
<p>Now let's put it all together. This might be a bit overwhelming all at once, but it gives you a glimpse into how various APIs work, such as drawing, event handling, threading, and file reading.</p>
<pre><code class="language-rust noplayground">use std::io::Read;

use zaplib::*;

#[derive(Default)]
struct App {
    window: Window,
}

impl App {
    fn new(_cx: &amp;mut Cx) -&gt; Self {
        Self { window: Window { create_add_drop_target_for_app_open_files: true, ..Window::default() } }
    }

    fn handle(&amp;mut self, _cx: &amp;mut Cx, event: &amp;mut Event) {
        if let Event::AppOpenFiles(aof) = event {
            // Get a copy of the file handle for use in the thread.
            let mut file = aof.user_files[0].file.clone();

            universal_thread::spawn(move || {
                let mut contents = String::new();
                file.read_to_string(&amp;mut contents).unwrap();
                log!(&quot;Contents of dropped file: {contents}&quot;);
            });
        }
    }

    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.window.end_window(cx);
    }
}

main_app!(App);
</code></pre>
<p>This code is also in the <code>tutorial_hello_thread</code> example, so you can just run <code>cargo run -p tutorial_hello_thread</code>.</p>
<p>Run this either natively or in WebAssembly, and then drag in a small text file. It should print the contents to the console. Since we did the file reading in a thread, it won't block any other code; though in this example it's hard to tell the difference. 😉</p>
<p>If you're actually going to do file reading, be sure to read up on the <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>std::file::File</code></a> documentation, since the advice there still applies (e.g. it's often a good idea to wrap things in a <code>BufReader</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-overview"><a class="header" href="#api-overview">API Overview</a></h1>
<h2 id="universal-apis"><a class="header" href="#universal-apis">Universal APIs</a></h2>
<p>For the most part, you can use normal Rust APIs. However, some standard Rust APIs don't work with WebAssembly, so we've built our own cross-platform &quot;universal&quot; APIs.</p>
<table><thead><tr><th>Rust API</th><th>Universal API</th><th></th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a></td><td><a href="/target/doc/zaplib/macro.log.html"><code>log!</code></a></td><td>Logs to the console (with line number).</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/thread/"><code>thread</code></a></td><td><a href="/target/doc/zaplib/universal_thread/index.html"><code>universal_thread</code></a></td><td><ul><li><code><a href="/target/doc/zaplib/universal_thread/fn.spawn.html">spawn</a></code> (without <code><a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html">JoinHandle</a></code>)</li><li><code><a href="/target/doc/zaplib/universal_thread/fn.sleep.html">sleep</a></code></li><li>We recommend using a thread pool, e.g. the <a href="https://docs.rs/rayon/latest/rayon/struct.ThreadPoolBuilder.html#method.spawn_handler">rayon crate's <code>ThreadPoolBuilder</code></a>.</li></ul></td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a></td><td><a href="/target/doc/zaplib/universal_instant/struct.UniversalInstant.html"><code>UniversalInstant</code></a></td><td><code>elapsed, now, duration_since, checked_add, checked_sub, +, -, +=, -=</code></td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/thread/"><code>File</code></a></td><td><a href="/target/doc/zaplib/universal_file/struct.UniversalFile.html"><code>UniversalFile</code></a></td><td><ul><li><code><a href="/target/doc/zaplib/universal_file/struct.UniversalFile.html#method.open">open</a></code> (on WebAssembly this blocks until the whole file is loaded in memory)</li><li><code><a href="/target/doc/zaplib/universal_file/struct.UniversalFile.html#method.open_url">open_url</a></code> (non-standard; load an absolute URL)</li><li><code><a href="/target/doc/zaplib/universal_file/struct.UniversalFile.html#method.clone">clone</a></code> (cheap; clones just a handle to the data; doesn't preserve cursor)</li><li><code><a href="https://doc.rust-lang.org/std/io/trait.Read.html">std::io::Read</a></code></li><li><code><a href="https://doc.rust-lang.org/std/io/trait.Seek.html">std::io::Seek</a></code></li><li><code><a href="/target/doc/zaplib/read_seek/trait.ReadSeek.html">ReadSeek</a></code> (non-standard; convenient trait for <code>Read + Seek</code>)</li></ul></td></tr>
<tr><td>non-standard</td><td><a href="/target/doc/zaplib/universal_http_stream/index.html"><code>universal_http_stream</code></a></td><td><ul><li><code><a href="/target/doc/zaplib/universal_http_stream/fn.request.html">request</a></code> (returns data as it comes in; useful for large files)</li><li><code><a href="https://doc.rust-lang.org/std/io/trait.Read.html">std::io::Read</a></code></li></ul></td></tr>
<tr><td>non-standard</td><td><a href="/target/doc/zaplib/universal_rand/index.html"><code>universal_rand</code></a></td><td><a href="/target/doc/zaplib/universal_rand/fn.random_128.html"><code>random_128</code></a></td></tr>
</tbody></table>
<h2 id="cx--basic-events"><a class="header" href="#cx--basic-events"><code>Cx</code> &amp; basic events</a></h2>
<p>As you might have seen in <a href="./tutorial_hello_world_console.html">Tutorial: Hello World Console</a>, we can get events in our application.</p>
<p>We also have access to a <a href="/target/doc/zaplib/cx/struct.Cx.html"><code>Cx</code></a> object. This is a global &quot;context&quot; object, that gets passed around practically everywhere.</p>
<p>Here we'll look at the basic calls you can make on <code>Cx</code>, and their associated events. We'll save rendering-related calls and events for a <a href="./rendering_api_events_overview.html">later chapter</a>.</p>
<h3 id="construction"><a class="header" href="#construction">Construction</a></h3>
<p>When the app is constructed and APIs can be called, a <a href="/target/doc/zaplib/enum.Event.html#variant.Construct"><code>Construct</code></a> event is fired. It is fired exactly once, and before any other calls to <code>handle</code> or <code>draw</code>. The event contains no further information.</p>
<h3 id="timers"><a class="header" href="#timers">Timers</a></h3>
<p>Calling <a href="/target/doc/zaplib/struct.Cx.html#method.start_timer"><code>cx.start_timer</code></a> creates a new <a href="/target/doc/zaplib/struct.Timer.html"><code>Timer</code></a> object. When the timer fires, a <a href="/target/doc/zaplib/struct.TimerEvent.html"><code>TimerEvent</code></a> event is dispatched. Use <a href="/target/doc/zaplib/struct.Timer.html#method.is_timer"><code>timer.is_timer</code></a> to check if that event belongs to a particular timer. Use <a href="/target/doc/zaplib/struct.Cx.html#method.stop_timer"><code>cx.stop_timer</code></a> to stop it.</p>
<h3 id="signals"><a class="header" href="#signals">Signals</a></h3>
<p>Signals are user-defined events that can be used for anything you want. Create a new <a href="/target/doc/zaplib/struct.Signal.html"><code>Signal</code></a> object by calling <a href="/target/doc/zaplib/struct.Cx.html#method.new_signal"><code>cx.new_signal</code></a>. Then send it with a <a href="/target/doc/zaplib/type.StatusId.html"><code>StatusId</code></a> using <a href="/target/doc/zaplib/struct.Cx.html#method.send_signal"><code>cx.send_signal</code></a> (same thread) or <a href="/target/doc/zaplib/struct.Cx.html#method.post_signal"><code>Cx::post_signal</code></a> (any thread). This will trigger a <a href="/target/doc/zaplib/struct.SignalEvent.html"><code>SignalEvent</code></a> on the main thread (<code>handle</code> and <code>draw</code> are always called on the main thread).</p>
<p>Note that the Signals API is a bit complicated currently; we aim to improve this so you can send any user-defined events.</p>
<h3 id="websockets"><a class="header" href="#websockets">WebSockets</a></h3>
<p><a href="/target/doc/zaplib/struct.Cx.html#method.websocket_send"><code>cx.websocket_send</code></a> sends a message on a WebSocket. If no WebSocket yet exists for the given URL, a new one is opened. When receiving a message on a WebSocket, a <a href="/target/doc/zaplib/struct.WebSocketMessageEvent.html">WebSocketMessageEvent</a> is fired.</p>
<h3 id="focus"><a class="header" href="#focus">Focus</a></h3>
<p>If the browser tab or native window gets or loses focus, then <a href="/target/doc/zaplib/enum.Event.html#variant.AppFocus"><code>AppFocus</code></a> or <a href="/target/doc/zaplib/enum.Event.html#variant.AppFocusLost"><code>AppFocusLost</code></a> are fired respectively.</p>
<h3 id="user-files"><a class="header" href="#user-files">User files</a></h3>
<p>This is getting a bit into rendering territory, since we already showed this in a <a href="./tutorial_hello_thread.html#drag--drop-files">tutorial</a>, we'll cover it here. To create a drop target for the entire window / browser tab, we have to create a <a href="/target/doc/zaplib/struct.Window.html"><code>Window</code></a> with <a href="/target/doc/zaplib/struct.Window.html#structfield.create_add_drop_target_for_app_open_files"><code>create_add_drop_target_for_app_open_files</code></a>. Then, when dropping a file, an <a href="/target/doc/zaplib/struct.AppOpenFilesEvent.html"><code>AppOpenFilesEvent</code></a> event will fire.</p>
<p>There are also events for when a file drag is <a href="/target/doc/zaplib/enum.Event.html#variant.FileDragBegin">started</a>, <a href="/target/doc/zaplib/enum.Event.html#variant.FileDragUpdate">updated</a>, or <a href="/target/doc/zaplib/enum.Event.html#variant.FileDragCancel">cancelled</a>.</p>
<h3 id="profiling"><a class="header" href="#profiling">Profiling</a></h3>
<p>Basic profiling using the console can be done using <a href="/target/doc/zaplib/struct.Cx.html#method.profile_start"><code>cx.profile_start</code></a> and <a href="/target/doc/zaplib/struct.Cx.html#method.profile_end"><code>cx.profile_end</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!---
TODO(Paras): Rustdoc for register_call_rust
Can we somehow bolded code changes between code snippets?
-->
<h1 id="tutorial-integrating-with-js"><a class="header" href="#tutorial-integrating-with-js">Tutorial: Integrating with JS</a></h1>
<p>This guide will show you how to add Rust code to an existing JavaScript codebase, explaining how to:</p>
<ul>
<li>Create a WebAssembly instance and load your Rust code.</li>
<li>Call functions in Rust and communicate results to JavaScript.</li>
</ul>
<p>You can either follow this tutorial directly; creating the necessary files from scratch. It's easiest to create your code in the <code>zaplib</code> directory.</p>
<p>Or for a full working example, check out <code>tutorial_js_rust_bridge</code> in the <code>zaplib/examples</code> directory.</p>
<h2 id="identifying-a-need"><a class="header" href="#identifying-a-need">Identifying a need</a></h2>
<p>Let's say you have a JavaScript codebase which needs to calculate the sum of all values in an array.</p>
<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-js">// index.js
const values = [1,2,3,4,5,6,7,8,9,10];
const sum = values.reduce((acc, v) =&gt; acc + v);

document.getElementById('root').textContent = sum;
</code></pre>
<p>This is a contrived example which does not need performance optimization, but importantly, one that locks the entire main thread while calculating results.</p>
<p>There are a few ways to make this better, in order:</p>
<ul>
<li>Moving to a promise-based approach with a loading state, so other interactions aren't blocked — this achieves <em>concurrency</em>.</li>
<li>Moving this computation into a Web Worker — this achieves <em>parallelism</em> and better utilizes multi-core machines.</li>
<li>Translating this computation to a <em>compiled language</em> (like Rust or C++) and attaching to a browser using WebAssembly — this lets us utilize the performance characteristics of other languages, which are usually better than JavaScript.</li>
</ul>
<p>Zaplib provides a communication framework to do this last option with a bit more ease than other options today. Let's walk through how.</p>
<h2 id="serving-a-webassembly-binary"><a class="header" href="#serving-a-webassembly-binary">Serving a WebAssembly binary</a></h2>
<p>Let's start a new Zaplib application! We'll need to create a Rust entrypoint and add some boilerplating so it can compile. After this, we'll show how to actually execute this code.</p>
<p>Additionally, we'll add a basic version of our existing JavaScript logic as Rust code.</p>
<pre><code class="language-rust noplayground">// src/main.rs
use zaplib::*;

fn sum() {
    // Hardcode the values for now. Later, we'll show how to communicate parameters.
    let values = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let sum = values.iter().sum();

    // Log sum to console. Later, we'll actually return this to JavaScript.
    log!(sum);
}

fn call_rust(name: String, _params: Vec&lt;ZapParam&gt;) -&gt; Vec&lt;ZapParam&gt; {
    if name == &quot;sum&quot; {
        sum();
    }

    vec![]
}

register_call_rust!(call_rust);
</code></pre>
<pre><code class="language-toml"># Cargo.toml
[package]
name = &quot;tutorial_js_rust_bridge&quot;
version = &quot;0.0.1&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
zaplib = { path=&quot;../../main&quot; }
</code></pre>
<!--- TODO(Paras): What will be the path to zaplib in Cargo.toml? -->
<h3 id="whats-new"><a class="header" href="#whats-new">What's new?</a></h3>
<p>We just added a lot, so here are the key things.</p>
<h4 id="srcmainrs"><a class="header" href="#srcmainrs">src/main.rs</a></h4>
<p>This will be our Rust entrypoint for the package.</p>
<ul>
<li><code>use zaplib::*;</code> imports the Zaplib library.</li>
<li><code>register_call_rust</code> lets us register Rust code as callable from JavaScript. The registered function will act on two arguments: a <code>name</code> field which specifies our input argument from JavaScript, and <code>params</code> with any input data. The function returns an output vector. We'll get to that in a bit.</li>
</ul>
<!--- TODO(Paras): Rustdoc for register_call_rust -->
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h4>
<p>This is our package manifest, needed when structuring any Rust application. For more information on basic Rust packaging, see <a href="https://doc.rust-lang.org/cargo/guide/creating-a-new-project.html">the official Cargo guide</a>. We specify <code>zaplib</code> in the dependencies.</p>
<h3 id="compiling"><a class="header" href="#compiling">Compiling</a></h3>
<p>Compile this into a WebAssembly binary by calling:</p>
<pre><code>./build_wasm.sh -p tutorial_js_rust_bridge
</code></pre>
<!--- TODO(Paras): Not sure what the path will be for this script. -->
<p>You'll now see a binary placed in <code>target/wasm32-unknown-unknown/debug/tutorial_js_rust_bridge.wasm</code>.</p>
<h3 id="serving"><a class="header" href="#serving">Serving</a></h3>
<p>To load this file on the Web, we'll need an HTTP server. There's no strict requirement on the backend, as long as:</p>
<ul>
<li>The <code>wasm</code> file is served with the <code>application/wasm</code> MIME type.</li>
<li>CORS headers are set with at least:</li>
</ul>
<pre><code>Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
Access-Control-Allow-Origin: *
</code></pre>
<!--- TODO(Paras): More restrictive CORS requirements probably exist. -->
<p>If you already have the server running per instructions in <a href="./getting_started.html">Getting Started</a>, then great, you can keep using that! If you're interested in a more minimal server example, check out <code>zaplib/examples/tutorial_js_rust_bridge/server.py</code>.</p>
<h2 id="connecting-to-web"><a class="header" href="#connecting-to-web">Connecting to web</a></h2>
<p>Now that we have our backend ready, let's write our new JavaScript.</p>
<p>Our existing code is modified to be:</p>
<pre><code class="language-js">// index.js
zaplib.initialize({
    filename: `path/to/target/wasm32-unknown-unknown/debug/tutorial_js_rust_bridge.wasm`,
    defaultStyles: true
}).then(() =&gt; {
  zaplib.callRust('sum');
});
</code></pre>
<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/zaplib_runtime.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="whats-new-1"><a class="header" href="#whats-new-1">What's new?</a></h3>
<ul>
<li><code>zaplib.initialize</code>, with a path to the <code>.wasm</code> file. This assumes our web server is at the same port that served this HTML.</li>
<li><code>zaplib.callRust</code>, where the first parameter specifies a <code>name</code> of associated logic in Rust.</li>
<li>Importing <code>zaplib_runtime</code> in our HTML.</li>
</ul>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<p>Load up the web page — in the console you should see your summed up result. Hooray! Baby steps.</p>
<h2 id="getting-javascript-inputs-in-rust"><a class="header" href="#getting-javascript-inputs-in-rust">Getting JavaScript inputs in Rust</a></h2>
<p>This approach shows how to trigger Rust code from JavaScript, but is missing fundamentals, notably the ability to pass input or read output. Let's first start with inputs.</p>
<p>Here is our modified code.</p>
<pre><code class="language-js">// index.js (after zaplib.initialize)
const values = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
zaplib.callRust('sum', [values]);
</code></pre>
<pre><code class="language-rust noplayground">// src/main.rs
use zaplib::*;

fn sum(values: &amp;[u8]) {
    let sum = values.iter().sum();

    // Log sum to console. Later, we'll actually return this to JavaScript.
    log!(sum);
}

fn call_rust(name: String, params: Vec&lt;ZapParam&gt;) -&gt; Vec&lt;ZapParam&gt; {
    if name == &quot;sum&quot; {
        let values = params[0].as_u8_slice();
        sum(&amp;values);
    }

    vec![]
}

register_call_rust!(call_rust);
</code></pre>
<h3 id="whats-new-2"><a class="header" href="#whats-new-2">What's new?</a></h3>
<p><code>callRust</code> can be passed a second parameter, a list of parameters of arbitrary length. Parameters must be either strings or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">TypedArrays</a>. In the above case, we're using a <code>Uint8Array</code>.</p>
<p>Our callback in Rust must now read this value, casting the parameter to the correct type. For Uint8Arrays, we can use the <code>as_u8_slice()</code> convenience method for this. Now we can use this like any normal array!</p>
<h2 id="getting-rust-outputs-into-javascript"><a class="header" href="#getting-rust-outputs-into-javascript">Getting Rust outputs into JavaScript</a></h2>
<p>Outputs work with a similar parameter structure, with the ability to pass both strings and buffers.</p>
<p>Here is our modified code.</p>
<pre><code class="language-js">// index.js (after zaplib.initialize)
const values = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
const [sumArray] = await zaplib.callRust('sum', [values]);
const sum = sumArray[0];
document.getElementById('root').textContent = sum;
</code></pre>
<pre><code class="language-rust noplayground">// src/main.rs
use zaplib::*;

fn sum(values: &amp;[u8]) -&gt; u8 {
    values.iter().sum()
}

fn call_rust(name: String, params: Vec&lt;ZapParam&gt;) -&gt; Vec&lt;ZapParam&gt; {
    if name == &quot;sum&quot; {
        let values = params[0].as_u8_slice();
        let response = vec![sum(&amp;values)].into_param();
        return vec![response];
    }

    vec![]
}

register_call_rust!(call_rust);
</code></pre>
<h3 id="whats-new-3"><a class="header" href="#whats-new-3">What's new?</a></h3>
<p><code>callRust</code> will respond asynchronously with an array of parameters, so our function must now use async/await. We'll populate the first item of this array with our sum, which will be a buffer with one item.</p>
<p>In Rust, our function can now return a vector of results. Note that each result value must be of type <code>ZapParam</code> using the helper <code>into_param()</code>.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>We now have a web application which uses Zaplib to offload computations to Rust! To reiterate, this solution:</p>
<ul>
<li>Has built-in parallelism, since Zaplib computations happen in Web Workers.</li>
<li>Offers Rust's trademark memory safety and performance.</li>
</ul>
<p>This solution works well, but still has one big disadvantage regarding performance: copying data. In the above example, our provided Uint8Array will be copied every time this function is called into the WebAssembly memory.</p>
<p>To ensure great performance, we must instead structure our application to share memory across JavaScript and Rust, which we'll talk about in the <a href="./tutorial_sharing_data.html">next tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-sharing-data"><a class="header" href="#tutorial-sharing-data">Tutorial: Sharing Data</a></h1>
<p>This guide is a followup to the <a href="./tutorial_js_rust_bridge.html">Tutorial: Integrating with JS</a>. It will show you how to avoid copying data when calling across the JavaScript-Rust boundary.</p>
<h2 id="identifying-a-need-1"><a class="header" href="#identifying-a-need-1">Identifying a need</a></h2>
<p>Let's start with our example from before, with a few modifications. We still want to calculate a sum in WebAssembly, but now we also want to calculate the product using a separate function call.</p>
<pre><code class="language-js">// index.js (after zaplib.initialize)
const values = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
const [sumArray] = await zaplib.callRust('sum', [values]);
const sum = sumArray[0];
document.getElementById('root').textContent = sum;
</code></pre>
<p>Like in our last guide, this is a contrived example, but one that illustrates a pitfall when repeatedly calling Rust with an input buffer.</p>
<p>Since the input buffer is stored in memory separate from WebAssembly, every call will re-copy it so that our Rust code can read the values. For large enough arrays, this can lead to a significant slowdown.</p>
<p>Zaplib helps you solve this problem by giving you read and write access to Rust-managed memory.</p>
<h2 id="allocating-memory-in-rust"><a class="header" href="#allocating-memory-in-rust">Allocating memory in Rust</a></h2>
<p>Let's first create a Uint8Array that's managed in Rust. Our new code:</p>
<pre><code class="language-js">// index.js (after zaplib.initialize)
const values = await zaplib.createReadOnlyBuffer(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));
const [sumArray] = await zaplib.callRust('sum', [values]);
const sum = sumArray[0];
document.getElementById('root').textContent = sum;
</code></pre>
<h3 id="whats-new-4"><a class="header" href="#whats-new-4">What's new?</a></h3>
<p>We only change one line above: initializing <code>values</code> using <code>zaplib.createReadOnlyBuffer</code>. This consumes a <code>Uint8Array</code> and copies it into WebAssembly memory, which is Rust-managed.</p>
<h2 id="reusing-the-allocated-memory"><a class="header" href="#reusing-the-allocated-memory">Reusing the allocated memory.</a></h2>
<p>Let's add to our contrived example, and get both the sum and the product of the values, using two separate calls to <code>callRust</code>:</p>
<pre><code class="language-rust noplayground">// src/main.rs
use zaplib::*;

fn sum(values: &amp;[u8]) -&gt; u8 {
    values.iter().sum()
}

fn product(values: &amp;[u8]) -&gt; u8 {
    values.iter().product()
}

fn call_rust(name: String, params: Vec&lt;ZapParam&gt;) -&gt; Vec&lt;ZapParam&gt; {
    if name == &quot;sum&quot; {
        let values = params[0].as_u8_slice();
        let response = vec![sum(&amp;values)].into_param();
        return vec![response];
    } else if name == &quot;product&quot; {
        let values = params[0].as_u8_slice();
        let response = vec![product(&amp;values)].into_param();
        return vec![response];
    }
    vec![]
}

register_call_rust!(call_rust);
</code></pre>
<pre><code class="language-js">// index.js (after zaplib.initialize)
const values = await zaplib.createReadOnlyBuffer(new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));
const sum = (await zaplib.callRust('sum', [values]))[0][0];
const product = (await zaplib.callRust('product', [values]))[0][0];
document.getElementById('root').textContent = &quot;sum: &quot; + sum + &quot; product: &quot; + product;
</code></pre>
<p>Even though we called <code>callRust</code> multiple times with <code>values</code>, there was no copying of data involved!</p>
<h2 id="read-only-vs-mutable"><a class="header" href="#read-only-vs-mutable">Read-Only vs Mutable</a></h2>
<p>The <code>values</code> buffer is read-only, which means that you can safely read from it in JavaScript and Rust at the same time! In fact, you can pass it safely to Rust threads or Web Workers (using <code>zaplib.serializeZapArrayForPostMessage</code>). Zaplib will keep track of where you use the array, so that it gets properly deallocated when you don't use it anymore.</p>
<p>Note that we currently don't enforce that you don't mutate <code>values</code>. There is no built-in way in JavaScript to do that. (In the future we might run periodic checksums on the data in debug builds, to prevent bugs.)</p>
<p>To mutate the data on the JavaScript side, the easiest way is to make a copy of <code>values</code> and call <code>zaplib.createReadOnlyBuffer</code> again. On the Rust side, you can use <code>let new_vec = values.as_vec();</code> to copy into a new <code>Vec&lt;u8&gt;</code>, and then return that using <code>new_vec.into_param()</code>.</p>
<p>It is also possible to mutate data on either side without copying, but that is a more advanced technique with we'll cover in a future tutorial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-overview-1"><a class="header" href="#api-overview-1">API Overview</a></h1>
<p>This is an overview of the different APIs for communicating between JavaScript and Rust.</p>
<p>The <a href="https://www.npmjs.com/package/zaplib">Zaplib package</a> on npm has two entrypoints:</p>
<ol>
<li><code>zaplib_runtime.js</code>: the main runtime, to be used on the browser's main thread.</li>
<li><code>zaplib_worker_runtime.js</code>: the Web Worker runtime, for use in your workers.</li>
</ol>
<p>The APIs between these runtimes is mostly the same, but there are some small differences which we will note.</p>
<p>As noted in the <a href="./introduction.html">Introduction</a>, we also have a highly experimental feature of including Chromium in the native Mac OS X build, using <a href="https://bitbucket.org/chromiumembedded/cef/src/master/">CEF</a>. This gets enabled when compiling zaplib with the <code>cef</code> <a href="https://doc.rust-lang.org/cargo/reference/features.html">feature</a>. Generally this is not recommended to use in production yet, but we'll still note its level of support for the different APIs.</p>
<p>Here is an overview of all the JS APIs, and their support with the WebAssembly runtime and the experimental native (CEF) runtime:</p>
<table><thead><tr><th>API</th><th style="text-align: center">browser top-level</th><th style="text-align: center">browser Web Worker</th><th style="text-align: center">native top-level</th><th style="text-align: center">native Web Worker</th></tr></thead><tbody>
<tr><td>zaplib.initialize</td><td style="text-align: center">✅</td><td style="text-align: center">—</td><td style="text-align: center">✅</td><td style="text-align: center">—</td></tr>
<tr><td>zaplib.initializeWorker</td><td style="text-align: center">—</td><td style="text-align: center">✅</td><td style="text-align: center">—</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.registerCallJsCallbacks</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.unregisterCallJsCallbacks</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.callRust</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.createReadOnlyBuffer</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.createMutableBuffer</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.callRustInSameThreadSync</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.newWorkerPort</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.serializeZapArrayForPostMessage</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.deserializeZapArrayFromPostMessage</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td>zaplib.jsRuntime</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
</tbody></table>
<p>✅ = implemented<br/>
❌ = TODO<br/>
—  = not applicable</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>First, make sure to install the <a href="https://www.npmjs.com/package/zaplib">npm package</a> and include the main entry point (<code>zaplib_runtime.js</code>).</p>
<h2 id="zaplibinitialize"><a class="header" href="#zaplibinitialize">zaplib.initialize</a></h2>
<p>This initializes the library. A couple of things happen:</p>
<ul>
<li>The <code>.wasm</code> file is downloaded and compiled.</li>
<li>A Web Worker is created for the main Rust event loop.</li>
<li>A <code>&lt;canvas&gt;</code> element spanning the entire page is created and added to <code>&lt;body&gt;</code>. It is transparent and doesn't respond to input events except when actively doing rendering within Rust. But if you need to fully hide it or override styles, use the <code>.zaplib_canvas</code> CSS class.</li>
<li>A <code>&lt;textarea&gt;</code> element is added to <code>&lt;body&gt;</code>. Again, it only springs into action when necessary. But if you need to fully hide it, use the <code>.zaplib_textarea</code> CSS class.</li>
<li>We add event listeners on the full page to capture events that are relevant for Zaplib.</li>
<li>We monkey-patch typed array constructors (e.g. <code>new Uint8Array</code>) and <code>postMessage</code> calls to add some additional features. See <a href="./bridge_api_params.html">next chapter</a> for more details.</li>
</ul>
<table><thead><tr><th>Parameter (Typescript)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>initParams.filename: string</code></td><td>Path to the <code>.wasm</code> file. During development, typically something like <code>/target/wasm32-unknown-unknown/debug/my_package_name.wasm</code>.</td></tr>
<tr><td><code>initParams.defaultStyles?: boolean</code></td><td>Whether to inject some default styles, including a loading indicator. Useful for examples / getting started.</td></tr>
</tbody></table>
<p></p>
<table><thead><tr><th>Returns (Typescript)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Promise&lt;void&gt;</code></td><td>Promise that resolves when you can call other functions.</td></tr>
</tbody></table>
<p><strong>Caveats</strong></p>
<ul>
<li>Can only be called on the browser's main thread; in a worker use <code>zaplib.initializeWorker()</code>.</li>
<li><code>filename</code> is ignored in CEF.</li>
</ul>
<h2 id="zaplibcallrust"><a class="header" href="#zaplibcallrust">zaplib.callRust</a></h2>
<p>Calls Rust with some parameters. The Rust code gets executed inside the main Rust Web Worker.</p>
<table><thead><tr><th>Parameter (Typescript)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name: string</code></td><td>Some descriptive name of what you want to call.</td></tr>
<tr><td><code>params?: (Uint8Array | Float32Array | string)[]</code></td><td>Array of parameters. See <a href="./bridge_api_params.html">next chapter</a> for more details.</td></tr>
</tbody></table>
<p></p>
<table><thead><tr><th>Returns (Typescript)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Promise&lt;(Uint8Array | Float32Array | string)[]&gt;</code></td><td>Return parameters. Typed arrays are backed by the WebAssembly memory, and are zero-copy. Strings are always copied.</td></tr>
</tbody></table>
<p>On the Rust side, define a function to handle <code>callRust</code> calls using the <code>register_call_rust!()</code> macro:</p>
<pre><code class="language-rust noplayground">fn call_rust(name: String, params: Vec&lt;ZapParam&gt;) -&gt; Vec&lt;ZapParam&gt; { ... }
register_call_rust!(call_rust);
</code></pre>
<p>Or if you have an application struct which you need access to, use <code>cx.on_call_rust()</code>:</p>
<pre><code class="language-rust noplayground">impl ExampleApp {
    fn new(cx: &amp;mut Cx) -&gt; Self {
        cx.on_call_rust(Self::on_call_rust);
        Self {}
    }

    fn on_call_rust(
        &amp;mut self,
        cx: &amp;mut Cx,
        name: String,
        params: Vec&lt;ZapParam&gt;
    ) -&gt; Vec&lt;ZapParam&gt; {}
}
</code></pre>
<p><code>ZapParam</code> matches the type of parameter that was pass in on the JS side. Get out the actual data using an <code>as_*</code> or <code>into_*</code> helper function. Similarly, return data by turning it into a <code>ZapParam</code> using the <code>into_param</code> on a supported type. For example, for converting to and from <code>String</code>s:</p>
<pre><code class="language-rust noplayground">fn call_rust(name: String, params: Vec&lt;ZapParam&gt;) -&gt; Vec&lt;ZapParam&gt; {
    // Converting to a string, and printing it:
    log!(&quot;String value: {}&quot;, params[0].as_str());
    return vec![&quot;Return value&quot;.to_string().into_param()];
}
</code></pre>
<p>For more information about the parameter types, see the <a href="./bridge_api_params.html">next chapter</a>.</p>
<h2 id="zaplibcreatereadonlybuffer--zaplibcreatemutablebuffer"><a class="header" href="#zaplibcreatereadonlybuffer--zaplibcreatemutablebuffer">zaplib.createReadOnlyBuffer &amp; zaplib.createMutableBuffer</a></h2>
<p>Use these functions to allocate raw data on the WebAssembly heap. These are convenience functions that have the same effect as calling <code>zaplib.callRust</code> with non-Zaplib-backed typed arrays and immediately returning them.</p>
<p>Note that when called on the browser's main thread, these calls are asynchronous (they return a <code>Promise</code>), while within Web Workers they are synchronous. In the future, we would like to make them synchronous in both cases.</p>
<h2 id="zaplibregistercalljscallbacks--zaplibunregistercalljscallbacks"><a class="header" href="#zaplibregistercalljscallbacks--zaplibunregistercalljscallbacks">zaplib.registerCallJsCallbacks &amp; zaplib.unregisterCallJsCallbacks</a></h2>
<p>In order to call JS from Rust — e.g. in response to an event — you can register callbacks on the JS side, using <code>zaplib.registerCallJsCallbacks</code>. An example:</p>
<pre><code class="language-js">zaplib.registerCallJsCallbacks({
    log(params) {
        console.log(&quot;log fn called&quot;, params[0]);
    },
});
</code></pre>
<p>Then, in Rust, use: <code>cx.call_js(&quot;log&quot;, vec![&quot;Hello, World!&quot;.to_string().into_param()])</code>, similarly to returning params from <code>call_rust</code>.</p>
<p>Currently these calls are one-way; it is not possible to directly return values. In order to do that, make a separate call to <code>zaplib.callRust</code>.</p>
<p>In order to unregister callbacks, use e.g. <code>zaplib.unregisterCallJsCallbacks([&quot;log&quot;]);</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-of-parameters"><a class="header" href="#types-of-parameters">Types of Parameters</a></h1>
<p>These are all the types of parameters that can be sent over the JS-Rust bridge:</p>
<table>
<thead><tr><td colspan="2">ZapParam::String</td></tr></thead>
<tr><td colspan="2"><em>Most common for small JSON-serialized data (e.g. using <a href="https://serde.rs/">Serde</a>).</em></td></tr>
<tr><td>Create in JS</td><td><code>"Hello, world!"</code></td></tr>
<tr><td>Type in Rust</td><td><code>String</code></td></tr>
<tr><td>Returned to JS</td><td><code>String</code></td></tr>
<tr><td>Borrowing data</td><td><code>as_str() -> &str</code></td></tr>
<tr><td>Transferring ownership</td><td><code>into_string() -> String</code></td></tr>
<tr><td>Caveats</td><td>Data is copied when passed over the bridge.</td></tr>
<thead><tr><td colspan="2">ZapParam::ReadOnlyU8Buffer</td></tr></thead>
<tr><td colspan="2"><em>Most common for large serialized data.</em></td></tr>
<tr><td>Create in JS</td><td><code>zaplib.createReadOnlyBuffer(new Uint8Array([1, 2, 3]))</code></td></tr>
<tr><td>Type in Rust</td><td><code>Arc&lt;Vec&lt;u8>></code></td></tr>
<tr><td>Returned to JS</td><td><code>ZapTypedArray (extends Uint8Array)</code></td></tr>
<tr><td>Borrowing data</td><td><code>as_u8_slice() -> &[u8]</code></td></tr>
<tr><td>Adding ownership (refcount)</td><td><code>as_arc_vec_u8() -> Arc&lt;Vec&lt;u8>></code></td></tr>
<tr><td>Caveats</td><td>No enforcement of read-only on JS side (yet).</td></tr>
<thead><tr><td colspan="2">ZapParam::ReadOnlyF32Buffer</td></tr></thead>
<tr><td colspan="2"><em>Most common for graphics data.</em></td></tr>
<tr><td colspan="2">Same as above, but instead with <code>f32</code> and <code>Float32Array</code>.</td></tr>
<thead><tr><td colspan="2">ZapParam::MutableU8Buffer</td></tr></thead>
<tr><td colspan="2"><em>Less common.</em></td></tr>
<tr><td>Create in JS</td><td><code>zaplib.createMutableBuffer(new Uint8Array([1, 2, 3]))</code></td></tr>
<tr><td>Type in Rust</td><td><code>Vec&lt;u8></code></td></tr>
<tr><td>Returned to JS</td><td><code>ZapTypedArray (extends Uint8Array)</code></td></tr>
<tr><td>Borrowing data</td><td><code>as_u8_slice() -> &[u8]</code></td></tr>
<tr><td>Transferring ownership</td><td><code>into_vec_u8() -> Vec&lt;u8></code></td></tr>
<tr><td>Caveats</td><td>Once passed from JS to Rust, the data cannot be used on the JS side any more (neither reading nor writing); representing transfer of ownership to Rust. This is not enforced (yet).</td></tr>
<thead><tr><td colspan="2">ZapParam::MutableF32Buffer</td></tr></thead>
<tr><td colspan="2"><em>Less common.</em></td></tr>
<tr><td colspan="2">Same as above, but instead with <code>f32</code> and <code>Float32Array</code>.</td></tr>
</table>
<p>As noted in the caveats above, you must take care when using these buffers on the JavaScript side:</p>
<ul>
<li><strong>Read-only buffers should not be mutated in JS.</strong> If you do mutate them anyway, race conditions and data corruption can occur. This restriction is not enforced (yet).</li>
<li>Mutable buffers can be mutated in JS. However, <strong>once you pass a mutable buffer into Rust, you cannot use the buffer in JS in <em>any way</em>.</strong> This is because ownership is passed to Rust, which can now mutate the data. If you read from such a stale buffer in JS, race conditions and data corruption can occur. This restriction is not enforced (yet).
<ul>
<li>It is possible to mutate some data in JS, then in Rust, and then in JS again, without ever copying of the data. Just pass the mutable buffer back from Rust to JS when you're done with it.</li>
</ul>
</li>
</ul>
<p>When a <code>u8</code> or <code>f32</code> buffer is returned to JS, you get a <code>ZapTypedArray</code>:</p>
<ul>
<li>This extends either <code>Uint8Array</code> or <code>Float32Array</code>.</li>
<li>This typed array is backed by the WebAssembly memory.</li>
<li>When the typed array gets garbage collected, the WebAssembly memory is updated accordingly (the refcount is decreased for read-only buffers; and the memory is freed for mutable buffers).</li>
<li>This does mean that if you want to pass such a typed array to a Web Worker, that you have to use <code>zaplib.serializeZapArrayForPostMessage</code>. If you don't, the data might get de- or re-allocated before you can use it.
<ul>
<li>This <em>is</em> enforced by monkey-patching <code>postMessage</code> when you call <code>zaplib.initialize()</code>, so don't worry too much about it.</li>
</ul>
</li>
<li>It is possible to call <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray"><code>subarray()</code></a> on these typed arrays, and the garbage collection be tracked properly.
<ul>
<li>It is even possible to create a new typed array using <code>new Uint8Array(zapArray.buffer, zapArray.byteOffset, zapArray.length)</code>, and the garbage collection will still be tracked properly!</li>
<li>This makes it possible to pass these typed arrays into most existing libraries.</li>
<li>However, it's not possible to pass a sub-slice of a typed array to Rust.</li>
</ul>
</li>
</ul>
<p>When sending small amounts of data in either direction, we recommend simply JSON-serializing the data and sending it as a string. On the Rust side, <a href="https://serde.rs/">Serde</a> is a fine library for this.</p>
<p>Futher note that when using CEF, data is often copied anyway, even when in the WebAssembly version it is not. This is one of the reasons why we do not recommend using CEF yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-workers"><a class="header" href="#web-workers">Web Workers</a></h1>
<p>Zaplib can also be used inside of your own Web Workers. This comes with both some extra features, as well as some caveats.</p>
<p>First, include the Web Worker entry point (<code>zaplib_worker_runtime.js</code>).</p>
<p>Note that when using CEF we don't support any of these functions yet.</p>
<h2 id="zaplibnewworkerport--zaplibinitializeworker"><a class="header" href="#zaplibnewworkerport--zaplibinitializeworker">zaplib.newWorkerPort &amp; zaplib.initializeWorker</a></h2>
<p>In order to use Zaplib inside Web Workers, we first have to create a &quot;worker port&quot; on the main thread, using <code>zaplib.newWorkerPort()</code>. Send that port to the Web Worker using whatever <code>postMessage</code> mechanism you already use. Be sure to add the port to the list of transferables. Example:</p>
<pre><code class="language-js">const zapWorkerPort = zaplib.newWorkerPort();
myWorker.postMessage(zapWorkerPort, [zapWorkerPort]);
</code></pre>
<p>Within the Web Worker, receive this port, and call <code>zaplib.initializeWorker(zapWorkerPort)</code>. Just like <code>zaplib.initialize</code> this returns a <code>Promise</code> indicating when you can call other functions on <code>zaplib</code>. Under the hood, we do the following:</p>
<ul>
<li>A cached, compiled version of the main <code>.wasm</code> file is loaded and instantiated.</li>
<li>A thread-specific stack and thread-local storage are allocated and initialized.</li>
<li>Shared WebAssembly memory is mounted.</li>
</ul>
<p>In the worker, the code would look something like this:</p>
<pre><code class="language-js">self.onmessage = function(e) {
    const zapWorkerPort = e.data;
    zaplib.initializeWorker(zapWorkerPort).then(() =&gt; {
        // actual code here.
    });
};
</code></pre>
<h2 id="zaplibserializezaparrayforpostmessage--zaplibdeserializezaparrayfrompostmessage"><a class="header" href="#zaplibserializezaparrayforpostmessage--zaplibdeserializezaparrayfrompostmessage">zaplib.serializeZapArrayForPostMessage &amp; zaplib.deserializeZapArrayFromPostMessage</a></h2>
<p>When a Zaplib-managed typed array gets garbage collected, the WebAssembly memory is updated accordingly (the refcount is decreased for read-only buffers; and the memory is freed for mutable buffers). This does mean that if you want to pass such a typed array to a Web Worker, that you have to use <code>zaplib.serializeZapArrayForPostMessage</code>. If you don't, the data might get de- or re-allocated before you can use it.</p>
<p>Note that this <em>is</em> enforced by monkey-patching <code>postMessage</code> when you call <code>zaplib.initialize()</code> or <code>zaplib.initializeWorker</code>, so don't worry about getting this wrong.</p>
<ul>
<li>Zaplib-managed typed arrays are those returned by <code>zaplib.createReadOnlyBuffer</code>, <code>zaplib.callRust</code>, and so on.</li>
<li>When sending a Zaplib-managed over <code>postMessage</code>, just wrap it in <code>zaplib.serializeZapArrayForPostMessage()</code>.</li>
<li>On the other side of the <code>postMessage</code> interface, get back a Zaplib-managed typed array by calling <code>zaplib.deserializeZapArrayFromPostMessage()</code>.</li>
<li>Both of these methods are synchronous.</li>
</ul>
<h2 id="zaplibcallrustinsamethreadsync"><a class="header" href="#zaplibcallrustinsamethreadsync">zaplib.callRustInSameThreadSync</a></h2>
<p>In Web Workers we also support calling Rust within that very thread. This means that execution transfers from JS to Rust, and no other processing can happen until the function returns. It also means that no <code>Promise</code>s are involved; it's purely synchronous code.</p>
<p>To register a callback, you have to use <code>cx.on_call_rust_in_same_thread_sync()</code>. However, the callback function has no access to the application struct, nor to <code>Cx</code> itself:</p>
<pre><code class="language-rust noplayground">impl ExampleApp {
    fn new(cx: &amp;mut Cx) -&gt; Self {
        cx.on_call_rust_in_same_thread_sync(Self::on_call_rust_in_same_thread_sync);
        Self {}
    }

    fn on_call_rust_in_same_thread_sync(
        name: String,
        params: Vec&lt;ZapParam&gt;
    ) -&gt; Vec&lt;ZapParam&gt; {}
}
</code></pre>
<p>On the JS side, call <code>zaplib.callRustInSameThreadSync()</code>. This has the same function signature as <code>zaplib.callRust</code>, except that its results are not wrapped in a <code>Promise</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-hello-world-canvas"><a class="header" href="#tutorial-hello-world-canvas">Tutorial: Hello World Canvas</a></h1>
<p>Let's build a simple Zaplib application that draws &quot;Hello, World!&quot; on the screen.</p>
<p>First we create a <code>Cargo.toml</code> file with the Zaplib dependency:</p>
<pre><code class="language-toml">[package]
name = &quot;tutorial_hello_world_canvas&quot;
version = &quot;0.0.1&quot;
edition = &quot;2021&quot;

[dependencies]
zaplib = { path=&quot;../../main&quot; }
</code></pre>
<p>In <code>src/main.rs</code>, we need to define a main app to draw from:</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
struct App {
}

impl App {
    fn new(cx: &amp;mut Cx) -&gt; Self {
        Self::default()
    }

    fn handle(&amp;mut self, cx: &amp;mut Cx, event: &amp;mut Event) {
    }

    fn draw(&amp;mut self, cx: &amp;mut Cx) {
    }
}

main_app!(App);
</code></pre>
<p>Just like in <a href="./tutorial_hello_world_console.html">Tutorial: Hello World Console</a>, the <code>App</code> implements 3 main functions: <code>new</code>, <code>handle</code>, and <code>draw</code>. Next we create a window with some text in the <code>draw</code> function:</p>
<pre><code class="language-rust noplayground">    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
        self.view.begin_view(cx, LayoutSize::FILL);

        cx.begin_padding_box(Padding::vh(50., 50.));
        TextIns::draw_walk(cx, &quot;Hello, World!&quot;, &amp;TextInsProps::default());
        cx.end_padding_box();

        self.view.end_view(cx);
        self.pass.end_pass(cx);
        self.window.end_window(cx);
    }
</code></pre>
<ul>
<li><code>window</code> refers to the main desktop or browser window.</li>
<li><code>pass</code> refers to our rendering context. We specify a black background — we can use any hex color here.</li>
<li><code>view</code> refers to our layout. We provide a <code>FILL</code> layout, which translates to 100% of the available width and height.</li>
<li><code>begin_padding_box</code> adds a padding so that text doesn't overlap with the native window buttons.</li>
<li><code>TextIns</code> is Zaplib's implementation for text rendering. We pass in our desired string and any formatting properties. We'll stick with default formatting for now.</li>
</ul>
<p>Add the relevant state to <code>App</code>:</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
struct App {
    window: Window,
    pass: Pass,
    view: View,
}
</code></pre>
<p>You can run this full example with Cargo:</p>
<pre><code class="language-bash">cargo run -p tutorial_hello_world_canvas
</code></pre>
<p><img src="./img/tutorial_hello_world_canvas.png" alt="" /></p>
<p>Congratulations! You just did your first rendering in Zaplib. In the <a href="./tutorial_2d_rendering.html">next tutorial</a> we will cover how to do 2D rendering.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-rendering-2d-shapes"><a class="header" href="#tutorial-rendering-2d-shapes">Tutorial: Rendering 2D Shapes</a></h1>
<p>Now that we've put <a href="./tutorial_hello_world.html">Hello World</a> on the screen, let's draw some more interesting shapes.</p>
<h2 id="step-1-render-colored-rectangle"><a class="header" href="#step-1-render-colored-rectangle">Step 1: Render colored rectangle</a></h2>
<p>A shader is a type of program that runs on the GPU. Typically the process of rendering using shaders goes through multiple stages:</p>
<ul>
<li>Geometry Definition — defining the base geometry figure, which can be as simple as a rectangle or as complex as a teapot (which we'll look at in <a href="./tutorial_rendering.html">Tutorial: Rendering 3D Meshes</a>).</li>
<li>Vertex Shader — transforming the geometry's coordinates into screen coordinates.</li>
<li>Rasterization — determining which pixels are inside the figure.</li>
<li>Pixel Shader — computing the color of each pixel inside the rasterized figure.</li>
<li>Instancing — repeat the above process for multiple instances of the same geometry, with some different instance-specific variables each time (like color or position).</li>
</ul>
<p>See <a href="https://learnopengl.com/Getting-started/Hello-Triangle">Learn OpenGL</a> for an example how this works in OpenGL.</p>
<p>Now let's go through the process of creating our own shader using Zaplib. First, write a function that builds a geometry:</p>
<pre><code class="language-rust noplayground">fn build_geom() -&gt; Geometry {
    let vertex_attributes = vec![
        // top left vertex
        vec2(0., 0.),
        // top right vertex
        vec2(1., 0.),
        // bottom right vertex
        vec2(1., 1.),
        // bottom left vertex
        vec2(0., 1.),
    ];
    let indices = vec![
        // top-right triangle
        [0, 1, 2],
        // bottom-left triangle
        [2, 3, 0],
    ];
    Geometry::new(vertex_attributes, indices)
}
</code></pre>
<p>This function defines 2 adjacent triangles that form a rectangle.</p>
<p>Define a <code>SHADER</code> object:</p>
<pre><code class="language-rust noplayground">static SHADER: Shader = Shader {
    build_geom: Some(build_geom),
    code_to_concatenate: &amp;[
        Cx::STD_SHADER,
        code_fragment!(
            r#&quot;
            geometry geom: vec2;
            instance color: vec4;

            fn vertex() -&gt; vec4 {
                return vec4(geom.x, geom.y, 0., 1.);
            }

            fn pixel() -&gt; vec4 {
                return color;
            }
            &quot;#
        ),
    ],
    ..Shader::DEFAULT
};
</code></pre>
<ul>
<li><code>code_to_concatenate</code> is the custom code assigned to the shader. We add <code>Cx::STD_SHADER</code> as a first argument which is a standard library of shaders within Zaplib.</li>
<li><code>geometry</code> is a qualifier that defines the data passed from <code>build_geom</code> output. Since our <code>vertex_attributes</code> in <code>build_geom</code> consist of <code>Vec2</code> objects, we define it as such here.</li>
<li><code>instance</code> is a qualifier that defines an instance-specific variable — more about that later.</li>
<li><code>color</code> is used to define which color to use for rectangle.</li>
<li><code>fn vertex()</code> defines the vertex shader. This gets called for each vertex returned from <code>build_geom</code>, with <code>geom</code> getting set to the corresponding point. It returns <code>vec4(x, y, z, w)</code> where the values mean the following:
<ul>
<li><code>x, y</code> — coordinates on the screen (from -1 to 1).</li>
<li><code>z</code> — draw order (from 0 to 1). Draws with higher <code>z</code> will be on top.</li>
<li><code>w</code> — normalization parameter. Not very important for now, so we'll set it currently to 1.0.</li>
</ul>
</li>
<li><code>fn pixel()</code> defines the pixel shader. Since we are not drawing any special shapes yet, we'll set every pixel to the same color. The pixel shader is called once for each pixel in the output image.</li>
</ul>
<p>Define the struct to pass the color into the shader as an instance variable:</p>
<pre><code class="language-rust noplayground">#[derive(Clone)]
#[repr(C)]
struct RectIns {
    color: Vec4,
}
</code></pre>
<p>Now we can combine all of this together and use the following <code>draw</code> function in our application:</p>
<pre><code class="language-rust noplayground">    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
        self.view.begin_view(cx, LayoutSize::FILL);

        let color = vec4(1., 0., 0., 1.);
        cx.add_instances(&amp;SHADER, &amp;[RectIns { color }]);

        self.view.end_view(cx);
        self.pass.end_pass(cx);
        self.window.end_window(cx);
    }
</code></pre>
<ul>
<li><code>let color</code> defines the red color.</li>
<li><code>cx.add_instances</code> takes a shader and passes the <code>MyIns</code> data into it. Under the hood this creates a new &quot;draw call&quot;.</li>
</ul>
<p>You can run this full example with Cargo:</p>
<pre><code class="language-bash">cargo run -p tutorial_2d_rendering_step1
</code></pre>
<p><img src="./img/tutorial_2d_rendering_step1.png" alt="" /></p>
<p>Note: the coordinates of vertices returned from <code>vertex()</code> shader are in <code>[0; 1]</code> range, while the window canvas uses <code>[-1; 1]</code>. That's why we see a red rectangle covering only a quarter of the window. In the next section we'll see how to draw with pixel coordinates.</p>
<h2 id="step-2-render-multiple-bordered-rectangles"><a class="header" href="#step-2-render-multiple-bordered-rectangles">Step 2: Render multiple bordered rectangles</a></h2>
<p>Now let's modify our example to draw 2 bordered rectangles of the given sizes on top of each other.</p>
<p>Modify <code>RectIns</code> to include the top-left position of rectangle and its size:</p>
<pre><code class="language-rust noplayground">#[derive(Clone)]
#[repr(C)]
struct RectIns {
    color: Vec4,
    rect_pos: Vec2,
    rect_size: Vec2,
}
</code></pre>
<p>Update the shader code:</p>
<pre><code class="language-rust noplayground">            r#&quot;
            geometry geom: vec2;
            instance color: vec4;
            instance rect_pos: vec2;
            instance rect_size: vec2;
            varying pos: vec2;

            fn vertex() -&gt; vec4 {
                let point = geom * rect_size + rect_pos;
                pos = (point - rect_pos) / rect_size;
                return camera_projection * camera_view * vec4(point.x, point.y, 0., 1.);
            }

            fn pixel() -&gt; vec4 {
                let border = 10.;
                let pt = pos * rect_size;
                if pt.x &lt; border || pt.y &lt; border || pt.x &gt; rect_size.x - border || pt.y &gt; rect_size.y - border {
                    return vec4(1., 1., 0., 1.0);
                }
                return color;
            }
            &quot;#
</code></pre>
<ul>
<li><code>instance</code> variables <code>color</code>, <code>rect_pos</code>, <code>rect_size</code> define the data passed into the shader. They must be in the same order as the fields of the <code>RectIns</code> struct.</li>
<li><code>varying pos</code> defines a local variable that gets passed from <code>vertex()</code> shader to the <code>pixel()</code> shader.</li>
<li>Inside <code>vertex()</code> we transform the geometry points to absolute coordinates of the rectangle to draw. In the end we apply <code>camera_projection</code> and <code>camera_view</code>, which are helper structs built into Zaplib that transform the absolute coordinates in pixels on the screen to <code>[-1; 1]</code> range.</li>
<li>Inside <code>pixel()</code> we define a 10 pixel border and return yellow for the pixels within that border, and <code>color</code> for other pixels in that rectangle.</li>
</ul>
<p>Finally, update the <code>draw</code> function to pass the new <code>RectIns</code> struct with new colors and positions of rectangles to draw:</p>
<pre><code class="language-rust noplayground">    fn draw(&amp;mut self, cx: &amp;mut Cx) {
       self.window.begin_window(cx);
       self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
       self.view.begin_view(cx, LayoutSize::FILL);

       let rect1 = RectIns { color: vec4(1., 0., 0., 1.), rect_pos: vec2(50., 50.), rect_size: vec2(400., 200.) };
       let rect2 = RectIns { color: vec4(0., 0., 1., 1.), rect_pos: vec2(100., 100.), rect_size: vec2(200., 400.) };

       cx.add_instances(&amp;SHADER, &amp;[rect1, rect2]);

       self.view.end_view(cx);
       self.pass.end_pass(cx);
       self.window.end_window(cx);
   }
</code></pre>
<p>You can run this full example with Cargo:</p>
<pre><code class="language-bash">cargo run -p tutorial_2d_rendering_step2
</code></pre>
<p><img src="./img/tutorial_2d_rendering_step2.png" alt="" /></p>
<h2 id="step-3-using-quadins"><a class="header" href="#step-3-using-quadins">Step 3: Using <code>QuadIns</code></a></h2>
<p>Drawing rectangles is very common in graphics, so Zaplib provides a convenient <code>QuadIns</code> struct. Let's use it in our latest example.</p>
<p>Update the <code>SHADER</code> definition:</p>
<pre><code class="language-rust noplayground">static SHADER: Shader = Shader {
    build_geom: Some(QuadIns::build_geom),
    code_to_concatenate: &amp;[
        Cx::STD_SHADER,
        QuadIns::SHADER,
        code_fragment!(
            r#&quot;
            instance color: vec4;
            fn pixel() -&gt; vec4 {
                let border = 10.;
                let pt = pos * rect_size;
                if pt.x &lt; border || pt.y &lt; border || pt.x &gt; rect_size.x - border || pt.y &gt; rect_size.y - border {
                    return vec4(1., 1., 0., 1.0);
                }
                return color;
            }
            &quot;#
        ),
    ],
    ..Shader::DEFAULT
};
</code></pre>
<ul>
<li>Pass in the <code>QuadIns::build_geom</code> function — it is identical to the <code>build_geom</code> function we defined above!</li>
<li>Prefix the shader with <code>QuadIns::SHADER</code>. This defines a <code>vertex()</code> shader, so we can remove that code.</li>
<li>We can remove <code>geom</code>, <code>rect_pos</code>, <code>rect_size</code>, and <code>pos</code>, since those are also defined inside <code>QuadIns::SHADER</code>.</li>
</ul>
<p>Update <code>RectIns</code> to use <code>QuadIns</code> instead of <code>rect_pos</code> and <code>rect_size</code>:</p>
<pre><code class="language-rust noplayground">#[repr(C)]
struct RectIns {
    quad: QuadIns,
    color: Vec4,
}
</code></pre>
<p>We put <code>quad</code> on top to match the order in which shaders are concatenated above</p>
<p>Finally, change the <code>draw</code> function to pass new <code>RectIns</code> objects to the <code>add_instances</code> calls:</p>
<pre><code class="language-rust noplayground">    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
        self.view.begin_view(cx, LayoutSize::FILL);

        let rect1 = RectIns {
            quad: QuadIns { rect_pos: vec2(50., 50.), rect_size: vec2(400., 200.), draw_depth: 0. },
            color: vec4(1., 0., 0., 1.),
        };
        let rect2 = RectIns {
            quad: QuadIns { rect_pos: vec2(100., 100.), rect_size: vec2(200., 400.), draw_depth: 0. },
            color: vec4(0., 0., 1., 1.),
        };

        cx.add_instances(&amp;SHADER, &amp;[rect1, rect2]);

        self.view.end_view(cx);
        self.pass.end_pass(cx);
        self.window.end_window(cx);
    }
</code></pre>
<p>You can run this full example with Cargo:</p>
<pre><code class="language-bash">cargo run -p tutorial_2d_rendering_step3
</code></pre>
<p>The output hasn't changed:</p>
<p><img src="./img/tutorial_2d_rendering_step2.png" alt="" /></p>
<p>This is what the full code looks like:</p>
<pre><code class="language-rust noplayground">use zaplib::*;

#[repr(C)]
struct RectIns {
    quad: QuadIns,
    color: Vec4,
}

static SHADER: Shader = Shader {
    build_geom: Some(QuadIns::build_geom),
    code_to_concatenate: &amp;[
        Cx::STD_SHADER,
        QuadIns::SHADER,
        code_fragment!(
            r#&quot;
            instance color: vec4;

            fn pixel() -&gt; vec4 {
                let border = 10.;
                let pt = pos * rect_size;
                if pt.x &lt; border || pt.y &lt; border || pt.x &gt; rect_size.x - border || pt.y &gt; rect_size.y - border {
                    return vec4(1., 1., 0., 1.0);
                }
                return color;
            }
            &quot;#
        ),
    ],
    ..Shader::DEFAULT
};

#[derive(Default)]
struct App {
    window: Window,
    pass: Pass,
    view: View,
}

impl App {
    fn new(_cx: &amp;mut Cx) -&gt; Self {
        Self::default()
    }

    fn handle(&amp;mut self, _cx: &amp;mut Cx, _event: &amp;mut Event) {}

    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
        self.view.begin_view(cx, LayoutSize::FILL);

        let rect1 = RectIns {
            quad: QuadIns { rect_pos: vec2(50., 50.), rect_size: vec2(400., 200.), draw_depth: 0. },
            color: vec4(1., 0., 0., 1.),
        };
        let rect2 = RectIns {
            quad: QuadIns { rect_pos: vec2(100., 100.), rect_size: vec2(200., 400.), draw_depth: 0. },
            color: vec4(0., 0., 1., 1.),
        };

        cx.add_instances(&amp;SHADER, &amp;[rect1, rect2]);

        self.view.end_view(cx);
        self.pass.end_pass(cx);
        self.window.end_window(cx);
    }
}

main_app!(App);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-3d-meshes"><a class="header" href="#rendering-3d-meshes">Rendering 3D Meshes</a></h1>
<p>This guides will walk through the rendering API provided by Zaplib. We'll go through a few steps:</p>
<ol>
<li>Start with a JavaScript application, which extracts a geometry <a href="https://en.wikipedia.org/wiki/File:Utah_teapot_(solid).stl">from an STL file</a> and renders it using ThreeJS and GLSL shaders.</li>
<li>Move our STL loading logic into Zaplib and communicate results using Web Workers.</li>
<li>Render using Zaplib.<!-- Potentially this step should be in its own guide --></li>
</ol>
<p>This guide assumes an understanding of JavaScript web development, basic 3D graphics, and writing GPU shaders using a shading language (such as GLSL/HLSL).</p>
<p>You can either follow this tutorial directly; creating the necessary files from scratch, or read the working incremental versions of each step, located in <code>zaplib/examples/tutorial_3d_rendering/</code>. To start from scratch, copy <code>zaplib/examples/tutorial_3d_rendering/step1</code> into a new directory at the top level of the <code>zaplib</code> repository called <code>tutorial_3d_rendering</code>.</p>
<h2 id="step-1-rendering-a-mesh-in-threejs"><a class="header" href="#step-1-rendering-a-mesh-in-threejs">Step 1: Rendering a mesh in ThreeJS</a></h2>
<p>This guide starts with a working 3D visualization in JavaScript, which renders an example using the popular <a href="https://threejs.org/">ThreeJS</a> library. Let's take a look at our existing files.</p>
<p>Our <code>index.html</code> looks like the following:</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;
    &lt;div id=&quot;root&quot; style=&quot;height: 100%; width: 100%;&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>In it, we define a top level full-page <code>div</code> with an id of <code>root</code>. We load <code>index.js</code> as well, reproduced below. Afterward, we'll go through its important pieces.</p>
<details>
  <summary>index.js</summary>
<pre><code class="language-js">import * as THREE from 'https://cdn.skypack.dev/three@v0.135.0';
import { OrbitControls } from 'https://cdn.skypack.dev/three@v0.135.0/examples/jsm/controls/OrbitControls'

const loadSTLIntoGeometry = async (assetUrl) =&gt; {
    const buffer = await fetch(assetUrl).then(r =&gt; r.arrayBuffer());
    const data = new DataView(buffer);

    const HEADER_LENGTH = 80;
    const numTriangles = data.getUint32(HEADER_LENGTH, true);
    const vertices = new Float32Array(numTriangles * 9);
    const normals = new Float32Array(numTriangles * 9);
    for (let i = 0; i &lt; numTriangles; i++) {
        const offset = HEADER_LENGTH + 4 + i * 50;

        const normalX = data.getFloat32(offset, true);
        const normalY = data.getFloat32(offset + 4, true);
        const normalZ = data.getFloat32(offset + 8, true);

        for (let j = i * 9, k = 0; k &lt; 36; j += 3, k += 12) {
            vertices[j] = data.getFloat32(offset + 12 + k, true);
            vertices[j + 1] = data.getFloat32(offset + 16 + k, true);
            vertices[j + 2] = data.getFloat32(offset + 20 + k, true);

            normals[j] = normalX;
            normals[j + 1] = normalY;
            normals[j + 2] = normalZ;
        }
    }
    const geometry = new THREE.BufferGeometry();
    geometry.attributes.position = new THREE.BufferAttribute(vertices, 3);
    geometry.attributes.normal = new THREE.BufferAttribute(normals, 3);
    geometry.attributes.offset = new THREE.InstancedBufferAttribute(new Float32Array([-10, 0, 10]), 1);
    geometry.attributes.color = new THREE.InstancedBufferAttribute(new Float32Array([1, 1, 0, 0, 1, 1, 1, 0, 1]), 3);

    return geometry;
}

const material = new THREE.ShaderMaterial({
    vertexShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec3 vColor;
    attribute float offset;
    attribute vec3 color;
    void main() {
        vPos = position;
        vNormal = normal;
        vColor = color;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(vec3(position.x, position.y + offset, position.z),1.0);
    }
    `,
    fragmentShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec3 vColor;
    void main() {
        vec3 lightPosition = vec3(20.,0.,30.);
        vec3 lightDirection = normalize(vPos.xyz - lightPosition);
        gl_FragColor = vec4(clamp(dot(-lightDirection, vNormal), 0.0, 1.0) * vColor,1.0);
    }
    `,
});

const init = async () =&gt; {
    const div = document.getElementById(&quot;root&quot;);
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(40, div.offsetWidth / div.offsetHeight, 0.1, 1000);
    camera.position.set(0, -30, 30);

    const renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(div.offsetWidth, div.offsetHeight);
    div.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);

    const render = () =&gt; {
        renderer.render(scene, camera);
    }

    const geometry = await loadSTLIntoGeometry(&quot;/zaplib/examples/tutorial_rendering/teapot.stl&quot;);
    const mesh = new THREE.InstancedMesh(geometry, material, 3);
    scene.add(mesh);

    function animate() {
        requestAnimationFrame(animate);
        render();
    }
    animate();
}

init();
</code></pre>
</details>
<p>This renders ThreeJS to the <code>root</code> div, which displays our 3D scene.</p>
<p>Let's focus on what is happening in the <code>init</code> function.</p>
<h3 id="first-we-have-our-threejs-boilerplating"><a class="header" href="#first-we-have-our-threejs-boilerplating">First we have our ThreeJS boilerplating.</a></h3>
<pre><code class="language-js">    const div = document.getElementById(&quot;root&quot;);
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(40, div.offsetWidth / div.offsetHeight, 0.1, 1000);
    camera.position.set(0, -30, 30);

    const renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(div.offsetWidth, div.offsetHeight);
    div.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);

    const render = () =&gt; {
        renderer.render(scene, camera);
    }
</code></pre>
<p>This does the following:</p>
<ul>
<li>Defines a new 3D scene, rendering results to our supplied <code>div</code>.</li>
<li>Defines a camera using a perspective projection, a field of view of 40, and a near/far z-axis of 0.1 and 1000. These numbers are not specifically important, but they are the defaults in Zaplib's Viewport, which we'll see later.</li>
<li>Sets up OrbitControls, which lets us pan and zoom around our scene easily. OrbitControls by default lets us use the left mouse button to rotate the camera around the origin (0,0,0) while maintaining camera distance, and the right mouse button to pan around the scene freely.</li>
</ul>
<h3 id="defining-geometry"><a class="header" href="#defining-geometry">Defining geometry</a></h3>
<pre><code class="language-js">    const geometry = await loadSTLIntoGeometry(&quot;/zaplib/examples/tutorial_rendering/teapot.stl&quot;);
    const mesh = new THREE.InstancedMesh(geometry, material, 3);
    scene.add(mesh);
</code></pre>
<p>This defines a ThreeJS InstancedMesh using a custom geometry and material. We supply an instance count of <code>3</code>, meaning that we will be rendering our model three times, with some custom properties per instance.</p>
<p>The geometry is loaded from a remote STL file using <code>loadSTLIntoGeometry</code>, let's take a look at that.</p>
<pre><code class="language-js">const loadSTLIntoGeometry = async (assetUrl) =&gt; {
    const buffer = await fetch(assetUrl).then(r =&gt; r.arrayBuffer());
    const data = new DataView(buffer);

    const HEADER_LENGTH = 80;
    const numTriangles = data.getUint32(HEADER_LENGTH, true);
    const vertices = new Float32Array(numTriangles * 9);
    const normals = new Float32Array(numTriangles * 9);
    for (let i = 0; i &lt; numTriangles; i++) {
        const offset = HEADER_LENGTH + 4 + i * 50;

        const normalX = data.getFloat32(offset, true);
        const normalY = data.getFloat32(offset + 4, true);
        const normalZ = data.getFloat32(offset + 8, true);

        for (let j = i * 9, k = 0; k &lt; 36; j += 3, k += 12) {
            vertices[j] = data.getFloat32(offset + 12 + k, true);
            vertices[j + 1] = data.getFloat32(offset + 16 + k, true);
            vertices[j + 2] = data.getFloat32(offset + 20 + k, true);

            normals[j] = normalX;
            normals[j + 1] = normalY;
            normals[j + 2] = normalZ;
        }
    }
    const geometry = new THREE.BufferGeometry();
    geometry.attributes.position = new THREE.BufferAttribute(vertices, 3);
    geometry.attributes.normal = new THREE.BufferAttribute(normals, 3);
    geometry.attributes.offset = new THREE.InstancedBufferAttribute(new Float32Array([-10, 0, 10]), 1);
    geometry.attributes.color = new THREE.InstancedBufferAttribute(new Float32Array([1, 1, 0, 0, 1, 1, 1, 0, 1]), 3);

    return geometry;
}
</code></pre>
<p>Without going line by line here, the function does the following:</p>
<ul>
<li>Fetch a remote asset and load its result into an ArrayBuffer. We'll be rendering a <a href="https://en.wikipedia.org/wiki/Utah_teapot">Utah teapot</a> - by default this will be available in <code>zaplib/examples/tutorial_3d_rendering/</code>.</li>
<li>Read through the buffer, extracting information for each triangle one by one. <a href="https://en.wikipedia.org/wiki/STL_(file_format)#Binary_STL">See the binary STL spec here</a> for information about its structure. We load each vertex and its corresponding normal into Float32Arrays.</li>
<li>Define a new ThreeJS BufferGeometry and create new attributes to define its shapes.
<ul>
<li>The extracted position and normal data is loaded in as BufferAttributes.</li>
<li>We give each instance a y-axis offset, represented as floats, and load it as InstanceBufferAttribute.</li>
<li>We give each instance a color, represented as RGB values, and load it as an InstancedBufferAttribute.</li>
</ul>
</li>
</ul>
<p>Our mesh's material is specified using a ShaderMaterial, and aims to provide very basic lighting with a fixed point light.</p>
<p>The vertex shader saves our position and normal as varying parameters to be used in the fragment shader, and converting our position from world coordinates to screen coordinates. We apply our instance <code>offset</code> value to get a final position.</p>
<pre><code class="language-glsl">    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec3 vColor;
    attribute float offset;
    attribute vec3 color;
    void main() {
        vPos = position;
        vNormal = normal;
        vColor = color;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(vec3(position.x, position.y + offset, position.z),1.0);
    }
</code></pre>
<p>The fragment shader specifies a fixed light source and calculates pixel color by multiplying our instance color and  light intensity, using the dot product of the light direction and normal vector. We clamp light intensity between 0 and 1.</p>
<pre><code class="language-glsl">    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec3 vColor;
    void main() {
        vec3 lightPosition = vec3(20.,0.,30.);
        vec3 lightDirection = normalize(vPos.xyz - lightPosition);
        gl_FragColor = vec4(clamp(dot(-lightDirection, vNormal), 0.0, 1.0) * vColor,1.0);
    }
</code></pre>
<p>Great! Running the example, we see our 3D scene with rudimentary lighting and pan/zoom controls with the mouse. There is a delay between page loading and scene rendering, due to our STL extraction code.</p>
<h2 id="step-2-stl-extraction-in-rust"><a class="header" href="#step-2-stl-extraction-in-rust">Step 2: STL extraction in Rust</a></h2>
<p>WebAssembly and Rust are most useful for expensive operations, so let's offload STL extraction from JavaScript there and look at the tradeoffs. At a high level, this means:</p>
<ul>
<li>performing STL extraction using a Web Worker and therefore parallel to our main thread</li>
<li>performing our network request for the STL file in Rust</li>
<li>communicating our result buffer back to JavaScript</li>
</ul>
<p>As a reminder, a working example at the end of this step is available in <code>zaplib/examples/tutorial_3d_rendering/step2</code>.</p>
<h3 id="instantiate-a-new-zaplib-project"><a class="header" href="#instantiate-a-new-zaplib-project">Instantiate a new Zaplib project</a></h3>
<p>This structure is further explained in previous tutorials. We'll need:</p>
<ul>
<li>a <code>Cargo.toml</code> file with the Zaplib dependency.</li>
</ul>
<pre><code class="language-toml">[package]
name = &quot;tutorial_3d_rendering&quot;
version = &quot;0.0.1&quot;
edition = &quot;2018&quot;

[dependencies]
zaplib = { path = &quot;../zaplib/main&quot; }
</code></pre>
<ul>
<li>and a Zaplib entrypoint for WebAssembly, in <code>src/main.rs</code>.</li>
</ul>
<pre><code class="language-rust noplayground">use zaplib::*;

fn call_rust(_name: String, _params: Vec&lt;ZapParam&gt;) -&gt; Vec&lt;ZapParam&gt; {
    vec![]
}

register_call_rust!(call_rust);
</code></pre>
<h3 id="port-stl-loading-to-rust"><a class="header" href="#port-stl-loading-to-rust">Port STL loading to Rust</a></h3>
<p>Add a function to <code>src/main.rs</code> for STL loading. We can mirror the algorithm we have in JavaScript. Here's what that looks like:</p>
<pre><code class="language-rust noplayground">fn parse_stl() -&gt; Vec&lt;ZapParam&gt; {
    let mut file = UniversalFile::open(&quot;zaplib/examples/tutorial_3d_rendering/teapot.stl&quot;).unwrap();
    let mut data = vec![];
    file.read_to_end(&amp;mut data).unwrap();

    const HEADER_LENGTH: usize = 80;
    let num_triangles = get_u32_le(&amp;data, HEADER_LENGTH) as usize;
    let mut vertices = Vec::with_capacity(num_triangles * 9);
    let mut normals = Vec::with_capacity(num_triangles * 9);
    for i in 0..num_triangles {
        let offset = HEADER_LENGTH + 4 + i * 50;

        let normal_x = get_f32_le(&amp;data, offset);
        let normal_y = get_f32_le(&amp;data, offset + 4);
        let normal_z = get_f32_le(&amp;data, offset + 8);

        for j in (0..36).step_by(12) {
            vertices.push(get_f32_le(&amp;data, offset + 12 + j));
            vertices.push(get_f32_le(&amp;data, offset + 16 + j));
            vertices.push(get_f32_le(&amp;data, offset + 20 + j));

            normals.push(normal_x);
            normals.push(normal_y);
            normals.push(normal_z);
        }
    }

    vec![vertices.into_param(), normals.into_param()]
}
</code></pre>
<p>This code looks mostly the same; here are a few notable differences:</p>
<ul>
<li>We make a web request and read to a file using Zaplib's <code>UniversalFile</code> API.</li>
<li>We use Zaplib's performant <code>byte_extract</code> module to read data. This must be imported by adding <code>use zaplib::byte_extract::{get_f32_le, get_u32_le};</code>. The module provides both little endian and big endian extraction functions for different primitive types.</li>
<li>We use the <code>into_param()</code> helper to convert Float32 vectors into params we can return to JavaScript.</li>
</ul>
<p>We then integrate this to <code>call_rust</code>:</p>
<pre><code class="language-rust noplayground">fn call_rust(name: String, _params: Vec&lt;ZapParam&gt;) -&gt; Vec&lt;ZapParam&gt; {
    if name == &quot;parse_stl&quot; {
        parse_stl()
    } else {
        panic!(&quot;Unknown function name&quot;);
    }
}
</code></pre>
<p>To build, run:</p>
<pre><code class="language-bash">./scripts/build_wasm.sh -p tutorial_3d_rendering
</code></pre>
<h3 id="calling-from-js"><a class="header" href="#calling-from-js">Calling from JS</a></h3>
<p>To call this function from our JavaScript, let's add the Zaplib dependency to <code>index.html</code>. Add a line in the <code>&lt;body&gt;</code> section:</p>
<pre><code class="language-html">    &lt;script type=&quot;text/javascript&quot; src=&quot;/zaplib/web/dist/zaplib_runtime.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>Then, modify <code>loadSTLIntoGeometry</code> to replace our JavaScript parsing code.</p>
<pre><code class="language-js">const loadSTLIntoGeometry = async (assetUrl) =&gt; {
    await zaplib.initialize({ filename: '/target/wasm32-unknown-unknown/debug/tutorial_3d_rendering.wasm' });

    const [vertices, normals] = await zaplib.callRust(&quot;parse_stl&quot;);
    const geometry = new THREE.BufferGeometry();
    geometry.attributes.position = new THREE.BufferAttribute(vertices, 3);
    geometry.attributes.normal = new THREE.BufferAttribute(normals, 3);

    return geometry;
}
</code></pre>
<p>A few key changes:</p>
<ul>
<li>We call <code>zaplib.initialize</code> with the location of our built WebAssembly binary.</li>
<li><code>zaplib.callRust</code> returns our vertices and normals already as Float32Arrays, which we can plug into ThreeJS.</li>
</ul>
<p>Great! Now let's run the example in the browser. There should be no difference in the behavior and things will load as normal, without blocking our main browser thread.</p>
<!-- Maybe there should be an actual observable difference here. -->
<h2 id="step-3---rendering-in-zaplib"><a class="header" href="#step-3---rendering-in-zaplib">Step 3 - Rendering in Zaplib</a></h2>
<p>In addition to processing tasks, we can also render to the DOM directly from Rust using Zaplib. We can draw UI primitives as well as a full 3D Viewport, which will get output to a <code>canvas</code> element on our webpage.</p>
<p>For an introduction to basic rendering, take a look at <a href="./tutorial_hello_world_canvas.html">Tutorial: Hello World Canvas</a>. Just like in that tutorial, let's create a basic Zaplib application. Here is how our Rust code should look at this point:</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
struct App {
    window: Window,
    pass: Pass,
    view: View,
}

impl App {
    fn new(_cx: &amp;mut Cx) -&gt; Self {
        Self::default()
    }

    fn handle(&amp;mut self, _cx: &amp;mut Cx, _event: &amp;mut Event) {}

    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
        self.view.begin_view(cx, LayoutSize::FILL);

        cx.begin_padding_box(Padding::hv(50., 50.));
        TextIns::draw_walk(cx, &quot;Hello, World!&quot;, &amp;TextInsProps::default());
        cx.end_padding_box();

        self.view.end_view(cx);
        self.pass.end_pass(cx);
        self.window.end_window(cx);
    }
}

main_app!(App);
</code></pre>
<p>Now we just need to connect the rendering with javascript page. To do so, remove our ThreeJS render, commenting out the entirety of <code>index.js</code> and replacing it with:</p>
<pre><code class="language-js">zaplib.initialize({ filename: '/target/wasm32-unknown-unknown/debug/tutorial_3d_rendering.wasm', defaultStyles: true });
</code></pre>
<p>Note the addition of <code>defaultStyles</code>, which will style our full-screen canvas correctly and add a loading indicator.</p>
<p>Rebuild the WebAssembly binary and refresh the screen. You should see a black background and a Hello World. Congratulations, we're rendering from Rust! ⚡️</p>
<h3 id="rendering-a-3d-viewport"><a class="header" href="#rendering-a-3d-viewport">Rendering a 3D Viewport</a></h3>
<p>Let's get back to our 3D example. One of the major advantages of Zaplib is the ability to use common structs for renderable data, instead of positional TypedArrays in JavaScript. In ThreeJS, we had to provide attributes as floats, but here we can be a bit more descriptive.</p>
<h4 id="generating-geometries"><a class="header" href="#generating-geometries">Generating geometries</a></h4>
<p>Let's represent a vertex struct as the below and add it to <code>src/main.rs</code>.</p>
<pre><code class="language-rust noplayground">#[repr(C)]
struct Vertex {
    position: Vec3,
    normal: Vec3,
}
</code></pre>
<p>For each vertex of our shape, we represent each position and normal as a <code>Vec3</code>, which is a three-dimensional vector of floats. We have to add <code>#[repr(C)]</code> to indicate C struct alignment.</p>
<p>Let's also add an instance struct as the below.</p>
<pre><code class="language-rust noplayground">#[repr(C)]
struct Instance {
    offset: f32,
    color: Vec3,
}
</code></pre>
<p>Like in JavaScript, we provide a Y-axis offset and color per instance. This data is fixed, so we can provide it as a static. Note how much more readable this is than linear buffers in JavaScript.</p>
<pre><code class="language-rust noplayground">const INSTANCES: [Instance; 3] = [
    Instance { offset: -10., color: vec3(1., 1., 0.) },
    Instance { offset: 0., color: vec3(0., 1., 1.) },
    Instance { offset: 10., color: vec3(1., 0., 1.) },
];
</code></pre>
<p>Modify the <code>parse_stl</code> function now to generate a Zaplib geometry instead of float arrays. Let's take a look at the final function.</p>
<pre><code class="language-rust noplayground">fn parse_stl(cx: &amp;mut Cx, url: &amp;str) -&gt; GpuGeometry {
    let mut file = UniversalFile::open(url).unwrap();
    let mut data = vec![];
    file.read_to_end(&amp;mut data).unwrap();

    const HEADER_LENGTH: usize = 80;
    let num_triangles = get_u32_le(&amp;data, HEADER_LENGTH) as usize;

    let vertices: Vec&lt;Vertex&gt; = (0..num_triangles)
        .flat_map(|i| {
            let offset: usize = HEADER_LENGTH + 4 + i * 50;
            let normal = vec3(get_f32_le(&amp;data, offset), get_f32_le(&amp;data, offset + 4), get_f32_le(&amp;data, offset + 8));

            [
                Vertex {
                    position: vec3(
                        get_f32_le(&amp;data, offset + 12),
                        get_f32_le(&amp;data, offset + 16),
                        get_f32_le(&amp;data, offset + 20),
                    ),
                    normal,
                },
                Vertex {
                    position: vec3(
                        get_f32_le(&amp;data, offset + 24),
                        get_f32_le(&amp;data, offset + 28),
                        get_f32_le(&amp;data, offset + 32),
                    ),
                    normal,
                },
                Vertex {
                    position: vec3(
                        get_f32_le(&amp;data, offset + 36),
                        get_f32_le(&amp;data, offset + 40),
                        get_f32_le(&amp;data, offset + 44),
                    ),
                    normal,
                },
            ]
        })
        .collect();

    let indices = (0..num_triangles as u32).map(|i| [i * 3, i * 3 + 1, i * 3 + 2]).collect();
    GpuGeometry::new(cx, Geometry::new(vertices, indices))
}
</code></pre>
<p>Note:</p>
<ul>
<li>Our vertex attributes are now represented by a <code>Vec&lt;Vertex&gt;</code> instead of multiple arrays.</li>
<li>We must generate a vector of <code>indices</code> to map vertices to triangles. Our approach here is naive, but this can be very useful for reducing memory costs when many vertices are duplicated.</li>
<li>Our resulting vertices and indices are eventually passed to <code>GpuGeometry::new</code>, which registers the geometry with the framework and makes it available on our GPU.</li>
</ul>
<h4 id="generating-geometry-on-startup"><a class="header" href="#generating-geometry-on-startup">Generating geometry on startup</a></h4>
<p>We now need a way to actually call <code>parse_stl</code> and save our geometry. Our <code>handle</code> function is the main entrypoint into the application lifecycle. One of our event types is called <code>Event::Construct</code>, called once after the framework has loaded. This sounds like a good place to load geometry. Write the <code>handle</code> function as follows.</p>
<pre><code class="language-rust noplayground">fn handle(&amp;mut self, cx: &amp;mut Cx, event: &amp;mut Event) {
    if let Event::Construct = event {
        self.geometry = Some(parse_stl(cx, &quot;zaplib/examples/tutorial_3d_rendering/teapot.stl&quot;));
        cx.request_draw();
    }
}
</code></pre>
<p>and add the geometry to <code>App</code>.</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
struct App {
    window: Window,
    pass: Pass,
    main_view: View,
    geometry: Option&lt;GpuGeometry&gt;,
}
</code></pre>
<p>Note:</p>
<ul>
<li>We pattern match on <code>event</code>, which is an enum of all possible event types.</li>
<li><code>geometry</code> is saved as an <code>Option</code> type, because it will be <code>None</code> initially before loading.</li>
<li>We call <code>cx.request_draw</code> after this is done to tell our framework to draw. This function is the only way to force re-draws.</li>
</ul>
<h4 id="defining-the-shader"><a class="header" href="#defining-the-shader">Defining the shader</a></h4>
<p>We need a shader to represent how to render our geometry to screen, the same way we defined a <code>ShaderMaterial</code> in ThreeJS. Zaplib uses custom shader dialect, which looks similar to Rust code and is cross-platform compatible with web and native graphics frameworks. Define this shader above the <code>App</code> struct definition.</p>
<pre><code class="language-rust noplayground">static SHADER: Shader = Shader {
    build_geom: None,
    code_to_concatenate: &amp;[
        Cx::STD_SHADER,
        code_fragment!(
            r#&quot;
            instance offset: float;
            instance color: vec3;

            geometry position: vec3;
            geometry normal: vec3;

            fn vertex() -&gt; vec4 {
                return camera_projection * camera_view * vec4(vec3(position.x, position.y + offset, position.z), 1.);
            }

            fn pixel() -&gt; vec4 {
                let lightPosition = vec3(20.,0.,30.);
                let lightDirection = normalize(position - lightPosition);
                return vec4(clamp(dot(-lightDirection, normal), 0.0, 1.0) * color,1.0);
            }&quot;#
        ),
    ],
    ..Shader::DEFAULT
};
</code></pre>
<p>Read the above carefully, and compare it to our previous JavaScript shader, reproduced below.</p>
<pre><code class="language-js">const material = new THREE.ShaderMaterial({
    vertexShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    void main() {
        vPos = position;
        vNormal = normal;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
    `,
    fragmentShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    void main() {
        vec3 lightPosition = vec3(20.,0.,30.);
        vec3 lightDirection = normalize(vPos.xyz - lightPosition);
        gl_FragColor = vec4(vec3(clamp(dot(-lightDirection, vNormal), 0.0, 1.0)),1.0);
    }
    `,
});
</code></pre>
<p>Some key differences:</p>
<ul>
<li>Zaplib shaders take in both a default geometry and an array of shader fragments to concatenate. We pass in <code>None</code> since we are defining a custom geometry, and prepend <code>Cx::STD_SHADER</code> to get default shader properties.</li>
<li>Like in JS, we use <code>instance</code> parameters. The order here is very important and must match the alignment of the <code>Instance</code> struct, as we interpret it linearly.</li>
<li>We use the <code>geometry</code> parameter to deconstruct the values of our vertex attributes. The order here is similarly important.</li>
<li>Instance and geometry arameters are available to both fragment and vertex shaders, so we do not need to use <code>varying</code> variables to forward them.</li>
</ul>
<h4 id="drawing-a-mesh"><a class="header" href="#drawing-a-mesh">Drawing a mesh</a></h4>
<p>Now that we have both the geometry and shader defined, we can add our geometry to a Viewport3D. The Viewport, like many other UI widgets from Zaplib, is provided by the <code>zaplib_widget</code> crate. Add it as a dependency in <code>Cargo.toml</code></p>
<pre><code class="language-toml">zaplib_widget = { path = &quot;../zaplib/widget&quot; }
</code></pre>
<p>and import it at the top of <code>src/main.rs</code>.</p>
<pre><code class="language-rust noplayground">use zaplib_widget::*;
</code></pre>
<p>In our <code>draw</code> function, add the following between <code>begin_view</code> and <code>end_view</code>.</p>
<pre><code class="language-rust noplayground">        self.view.begin_view(cx, LayoutSize::FILL);
        if let Some(geometry) = &amp;self.geometry {
            self.viewport_3d.begin_draw(
                cx,
                Viewport3DProps {
                    initial_camera_position: Coordinates::Cartesian(vec3(0., -30., 30.)),
                    ..Viewport3DProps::DEFAULT
                },
            );
            cx.add_mesh_instances(&amp;SHADER, &amp;INSTANCES, geometry.clone());
            self.viewport_3d.end_draw(cx);
        }
        self.view.end_view(cx);
</code></pre>
<p>In short, this checks if we have a loaded geometry and if so, draws a viewport with an instance of it. We define an <code>initial_camera_position</code> with the same coordinates as our ThreeJS sketch.</p>
<p>Add <code>viewport_3d</code> to the application struct</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
struct App {
    window: Window,
    pass: Pass,
    view: View,
    viewport_3d: Viewport3D,
    geometry: Option&lt;GpuGeometry&gt;,
}
</code></pre>
<p>Rebuild the application and refresh your browser. Whoa, we're now fully rendering 3D geometry in Rust!</p>
<p>Lastly, let's add camera controls like ThreeJS's OrbitControls. <code>Viewport3D</code> has this out of the box, but we need to make sure our event handler forwards events to it, so call <code>viewport_3d.handle</code> at the top of your <code>handle</code> function.</p>
<pre><code class="language-rust noplayground">    fn handle(&amp;mut self, cx: &amp;mut Cx, event: &amp;mut Event) {
        self.viewport_3d.handle(cx, event);

        if let Event::Construct = event {
            self.geometry = Some(parse_stl(cx, &quot;zaplib/examples/tutorial_3d_rendering/teapot.stl&quot;));
            cx.request_draw();
        }
    }
</code></pre>
<p>Build and run the application. Pan and rotate with the mouse buttons, and enjoy your new WebAssembly rendered graphics!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-api-overview"><a class="header" href="#rendering-api-overview">Rendering API Overview</a></h1>
<ul>
<li><a href="./rendering_api_overview_model.html">Rendering model</a></li>
<li><a href="./rendering_api_overview_geometry.html">Geometry</a></li>
<li><a href="./rendering_api_shaders.html">Shaders</a></li>
<li><a href="./rendering_api_drawing.html">Drawing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-model"><a class="header" href="#rendering-model">Rendering model</a></h1>
<p>The entrypoint of an application is typically the <a href="/target/doc/zaplib/macro.main_app.html"><code>main_app!()</code></a> macro. A minimal example looks like this:</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
struct App {}

impl App {
    fn new(cx: &amp;mut Cx) -&gt; Self {
        Self::default()
    }

    fn handle(&amp;mut self, cx: &amp;mut Cx, event: &amp;mut Event) {}

    fn draw(&amp;mut self, cx: &amp;mut Cx) {}
}

main_app!(App);
</code></pre>
<p>Let's break it down a bit. The app must be a <code>struct</code> that implement three methods:</p>
<ul>
<li><code>fn new()</code> — Returns an initialized struct and any initial state we add. Gets only called once.</li>
<li><code>fn handle()</code> — An entrypoint into Zaplib's event handling system.</li>
<li><code>fn draw()</code> — Called when a draw has been requested, e.g. on startup, during resizing, or on <a href="/target/doc/zaplib/struct.Cx.html#method.request_draw"><code>cx.request_draw()</code></a>.</li>
</ul>
<h2 id="draw-tree"><a class="header" href="#draw-tree">Draw tree</a></h2>
<p>Under the hood, the core data structure is a <strong>&quot;draw tree&quot;</strong>. This contains all information that we need to tell the GPU what to draw on the screen. There are two phases of rendering:</p>
<ul>
<li><strong>Drawing</strong>: this is the process of generating a new draw tree. It might share data with the previous draw tree for caching purposes, but conceptually it's useful to think of it as producing a new draw tree.</li>
<li><strong>Painting</strong>: this is the process of informing the GPU of the new data in the draw tree. Painting always happens after drawing, but might also be done independently.</li>
</ul>
<p>Here is how the two main top-level functions interact with these two phases:</p>
<ul>
<li><code>fn handle()</code>
<ul>
<li>Called when an event is fired, such as a mouse movement.</li>
<li>Events do not trigger drawing or painting, but a redraw can be requested using <a href="/target/doc/zaplib/struct.Cx.html#method.request_draw"><code>cx.request_draw()</code></a>. This will cause <code>fn draw()</code> to get called (once <code>fn handle()</code> has finished).
<ul>
<li>You'd typically call this whenever you update application state.</li>
</ul>
</li>
<li>It is possible to directly access the draw tree here, e.g. by calling functions on <a href="/target/doc/zaplib/enum.Area.html"><code>Area</code></a> (which is a pointer into the draw tree).</li>
<li>When modifying the draw tree in place (e.g. with <a href="/target/doc/zaplib/enum.Area.html#method.get_slice_mut"><code>Area::get_slice_mut</code></a>), the modified draw tree gets painted afterwards.
<ul>
<li>Be careful with this, since your changes to the draw tree will get blown away the next we do drawing. Be sure to keep a single source of truth in both cases.</li>
<li>This can be useful for cheap, local modifications, like animations.</li>
</ul>
</li>
<li>See <a href="./rendering_api_events_overview.html">Events</a> for more details on handling events.</li>
</ul>
</li>
<li><code>fn draw()</code>
<ul>
<li>Gets called when a draw is requested, either internally by the framework or by <a href="/target/doc/zaplib/struct.Cx.html#method.request_draw"><code>cx.request_draw()</code></a>.</li>
<li>At the start, the entire draw tree is cleared out, except for some caching information.</li>
<li>Within this function, you make API calls to rebuild the draw tree again.</li>
<li>Afterwards, painting always happens.</li>
</ul>
</li>
</ul>
<p>The draw tree itself is a data structure that contains the following information:</p>
<ul>
<li>Shaders: a list of <code>Shader</code> objects, which are programs that run on the GPU.</li>
<li>Geometries: a list of <code>GpuGeometry</code> objects, which are sets of vertices (points) that together form triangles, that are stored on the GPU.</li>
<li>Windows: a list of <code>Window</code> objects, representing actual windows on the desktop. On WebAssembly there is only ever one window.</li>
<li>Passes: a list of <code>Pass</code> objects, representing a render target. Comparable to <code>&lt;canvas&gt;</code> on the web. Each <code>Window</code> has one associated <code>Pass</code>, but you can also use <code>Pass</code>es to render to <code>Texture</code>s.</li>
<li>Views: a list of <code>View</code> objects, which is mostly used as a scroll container, but is currently also required when you're not doing any scrolling. Each <code>Pass</code> has one main <code>View</code>. <code>View</code>s can also be nested.</li>
<li>DrawCalls: <code>DrawCall</code> objects, which are instructions to draw something on the GPU, given a <code>Shader</code>, a <code>GpuGeometry</code>, a <code>View</code>, and a buffer of GPU instance data.</li>
<li>Textures: <code>Texture</code> objects, which are buffers that are held on the GPU. You can write to them using a <code>Pass</code>, or read/modify them directly.</li>
</ul>
<p>There is somewhat of a tree structure to the draw tree. Here is an example:</p>
<ul>
<li><code>Window</code> (in WebAssembly there is only one window)
<ul>
<li><code>Pass</code> (each <code>Window</code> has one main <code>Pass</code>, but <code>Pass</code> can also be created stand-alone)
<ul>
<li><code>View</code> (each <code>Pass</code> has one main <code>View</code>)
<ul>
<li><code>DrawCall</code> (points to a <code>Shader</code>, optionally <code>GpuGeometry</code>, and holds an instance data buffer)</li>
<li><code>DrawCall</code></li>
<li><code>View</code> (<code>Views</code> can be nested arbitrarily deep, mostly when creating scroll containers)
<ul>
<li><code>DrawCall</code></li>
<li><code>DrawCall</code></li>
</ul>
</li>
<li><code>DrawCall</code></li>
<li><code>View</code>
<ul>
<li><code>DrawCall</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Shader</code> (mostly separate; gets referred to from <code>DrawCall</code>)</li>
<li><code>Shader</code></li>
<li><code>Shader</code></li>
<li><code>GpuGeometry</code> (mostly separate; gets referred to from <code>Shader</code> or <code>DrawCall</code>)</li>
<li><code>GpuGeometry</code></li>
<li><code>Texture</code> (can be read by a <code>DrawCall</code>, written to by a <code>Pass</code>, or read/written by Rust)</li>
<li><code>Texture</code></li>
</ul>
<p>Since at a minimum we need a <code>Window</code>, a <code>Pass</code>, and a <code>View</code>, there is a bit of boilerplate to get started with rendering. See <a href="./tutorial_hello_world_canvas.html">Tutorial: Hello World Canvas</a> for an example.</p>
<h2 id="painting"><a class="header" href="#painting">Painting</a></h2>
<p>When painting, we traverse the draw tree down, creating commands for the GPU in the process. Typically it looks something like this:</p>
<ol>
<li>Compiling shaders.</li>
<li>Computing which <code>Pass</code>es should be painted. For example, if a pass A renders a texture that is produced by pass B, and pass B has changed, then both passes will be painted. Under the hood we keep a dependency graph to figure this out.</li>
<li>For each <code>Pass</code>, render the main <code>View</code>. Rendering a <code>View</code> is a recursive process. We start off without any scrolling offsets, and no <code>zbias</code>. Then, we draw the children in order:
<ul>
<li>For each <code>DrawCall</code>, set the total scroll offset, clipping region, and <code>zbias</code> that we have accumulated so far. Then, queue up a paint command. When done, increment <code>zbias</code> by a small amount.</li>
<li>For each nested <code>View</code>, read out the local scroll position, add that to the accumulated total, and then recursively paint that <code>View</code>.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p><code>fn handle()</code> is the application entrypoint for handling events, and is passed an <a href="/target/doc/zaplib/enum.Event.html"><code>Event</code></a>. For a detailed view, you can read all of the variants of the <code>Event</code> enum. We'll outline different event scenarios below.</p>
<h2 id="structuring-the-handle-function"><a class="header" href="#structuring-the-handle-function">Structuring the <code>handle</code> function</a></h2>
<p>Usually, both the top level app and individual components will all have a <code>handle</code> function that takes in an <code>Event</code>. These functions should:</p>
<ul>
<li>use a <code>match</code> expression to handle relevant events for the component</li>
<li>pass the <code>Event</code> to all child components' <code>handle</code> functions</li>
<li>call <a href="/target/doc/zaplib/struct.Cx.html#method.request_draw"><code>cx.request_draw()</code></a> if a redraw is necessitated.</li>
<li>call <a href="/target/doc/zaplib/struct.Cx.html#method.request_frame"><code>cx.request_frame()</code></a> if it should trigger another call to the top level <code>handle</code>.</li>
</ul>
<h2 id="user-input"><a class="header" href="#user-input">User input</a></h2>
<p>Mouse and touch input are called &quot;pointers&quot; in Zaplib, represented using <a href="/target/doc/zaplib/enum.Event.html#variant.PointerUp"><code>PointerUp</code></a>, <a href="/target/doc/zaplib/enum.Event.html#variant.PointerDown"><code>PointerDown</code></a>, <a href="/target/doc/zaplib/enum.Event.html#variant.PointerMove"><code>PointerMove</code></a>, and <a href="/target/doc/zaplib/enum.Event.html#variant.PointerScroll"><code>PointerScroll</code></a>, and <a href="/target/doc/zaplib/enum.Event.html#variant.PointerHover"><code>PointerHover</code></a>.</p>
<p>For processing text input, use <a href="/target/doc/zaplib/enum.Event.html#variant.TextInput"><code>TextInput</code></a>. We also have <a href="/target/doc/zaplib/enum.Event.html#variant.KeyDown"><code>KeyDown</code></a> and <a href="/target/doc/zaplib/enum.Event.html#variant.KeyUp"><code>KeyUp</code></a>, useful for keyboard based navigation or shortcuts - but do not rely on these for capturing text input. Use <a href="/target/doc/zaplib/enum.Event.html#variant.TextCopy"><code>TextCopy</code></a> for handling clipboard requests.</p>
<p>You may have different components of your app which take keyboard input. To manage keyboard focus between them, use <a href="/target/doc/zaplib/struct.Cx.html#method.set_key_focus"><code>set_key_focus</code></a>. This uses <a href="http://localhost:4848/target/doc/zaplib/struct.ComponentId.html"><code>ComponentId</code></a> as a unique identifier, which you should assign to your component struct with <code>ComponentId::default()</code>.</p>
<p>Then, to see if a keyboard event is meant for a component, use <a href="/target/doc/zaplib/enum.Event.html#method.hits_keyboard"><code>hits_keyboard</code></a>, which will check key focus and skip irrelevant events. It also returns <a href="/target/doc/zaplib/enum.Event.html#variant.KeyFocus"><code>KeyFocus</code></a> and <a href="/target/doc/zaplib/enum.Event.html#variant.KeyFocusLost"><code>KeyFocusLost</code></a> if your component should handle focus changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry"><a class="header" href="#geometry">Geometry</a></h1>
<p>Geometries are sets of vertices (points) that together form triangles. It's the most basic rendering primitive in Zaplib. With them, we can create everything from interactive UI elements to 3D meshes.</p>
<p>A <a href="/target/doc/zaplib/struct.Geometry.html"><code>Geometry</code></a> describes the shape of a renderable item, represented as triangles. Create a <code>Geometry</code> using <a href="/target/doc/zaplib/struct.Geometry.html#method.new"><code>Geometry::new</code></a>, which takes in both vertex attributes and indices to map vertices to triangle faces.</p>
<p>For example, take a look at our internal representation of <a href="/target/doc/zaplib/struct.QuadIns.html"><code>QuadIns</code></a>. To represent the <code>Quad</code> shape, consider two right triangles both sharing a hypotenuse to form a square.</p>
<pre><code class="language-rust noplayground">    pub fn build_geom() -&gt; Geometry {
        // First, represent each corner of the quad as a vertex,
        // with each side having a length of 1.
        let vertex_attributes = vec![
            // top left vertex
            vec2(0., 0.),
            // top right vertex
            vec2(1., 0.),
            // bottom right vertex
            vec2(1., 1.),
            // bottom left vertex
            vec2(0., 1.),
        ];
        // Group the vertices into two triangles, right triangles
        // on opposing corner coming together to share a hypotenuse.
        let indices = vec![
            // top-right triangle
            [0, 1, 2],
            // bottom-left triangle
            [2, 3, 0],
        ];
        Geometry::new(vertex_attributes, indices)
    }
</code></pre>
<h3 id="gpugeometry"><a class="header" href="#gpugeometry">GpuGeometry</a></h3>
<p>A <a href="/target/doc/zaplib/struct.GpuGeometry.html"><code>GpuGeometry</code></a> is used to register a <a href="/target/doc/zaplib/struct.Geometry.html"><code>Geometry</code></a> with our application context. It is called via <code>GpuGeometry::new(cx, geometry)</code>. Under the hood, this is reference counted and can be cheaply cloned to add a new reference to the same geometry. When all references are dropped, the buffer will get reused in the next call to <code>GpuGeometry::new</code>.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>You can statically assign a <code>Geometry</code> to a <code>Shader</code>, by passing in a <a href="/target/doc/zaplib/struct.Shader.html#structfield.build_geom"><code>build_geom</code></a> when creating a <code>Shader</code>. To render such a shader, use <a href="/target/doc/zaplib/struct.Cx.html#method.add_instances"><code>add_instances</code></a>.</p>
<p>It's also possible to omit a <code>build_geom</code> when creating a <code>Shader</code>, and instead dynamically assign it a <code>GpuGeometry</code> when drawing. In that case, use <a href="/target/doc/zaplib/struct.Cx.html#method.add_mesh_instances"><code>add_mesh_instances</code></a>.</p>
<p>See <a href="./rendering_api_drawing.html">Drawing</a> for more information on different APIs for drawing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shaders"><a class="header" href="#shaders">Shaders</a></h1>
<p>A <a href="/target/doc/zaplib/struct.Shader.html"><code>Shader</code></a> represents the program sent to the GPU to render each pixel on the surface of our geometry. It can be instantiated with a base geometry and must be provided with a shader written with our custom shading language.</p>
<p>A simple shader might look something like this:</p>
<pre><code class="language-rust noplayground">static SHADER: Shader = Shader {
    build_geom: Some(build_geom),
    code_to_concatenate: &amp;[
        Cx::STD_SHADER,
        code_fragment!(
            r#&quot;
            geometry geom: vec2;
            instance color: vec4;

            fn vertex() -&gt; vec4 {
                return vec4(geom.x, geom.y, 0., 1.);
            }

            fn pixel() -&gt; vec4 {
                return color;
            }
            &quot;#
        ),
    ],
    ..Shader::DEFAULT
};
</code></pre>
<p>Shaders are statically defined, and consist of two fields:</p>
<ul>
<li><code>build_geom</code>: a function that produces a <a href="./rendering_api_overview_geometry.html"><code>Geometry</code></a>. Can be omitted if you want to dynamically assign a geometry at draw time.</li>
<li><code>code_to_concatenate</code>: an array of <a href="/target/doc/zaplib/struct.CodeFragment.html"><code>CodeFragment</code>s</a>, that get concatenated in order. Define each fragment using the <a href="/target/doc/zaplib/macro.code_fragment.html"><code>code_fragment!()</code></a> macro (this keeps track of filenames and line numbers, for better error messages).</li>
</ul>
<h2 id="passing-in-data"><a class="header" href="#passing-in-data">Passing in data</a></h2>
<p>A shader typically starts with a bunch of variable declarations. These declarations define the data that you pass into the shader, and has to exactly match the data types in Rust.</p>
<p>For example, to pass in instance data, you can define some <code>instance</code> variables in the shader:</p>
<pre><code class="language-rust noplayground">r#&quot;
instance pos: vec2;
instance color: vec4;
&quot;#
</code></pre>
<p>Which has to exactly match the corresponding &quot;instance struct&quot;:</p>
<pre><code class="language-rust noplayground">#[repr(C)]
struct MyShaderIns {
    pos: Vec2,
    color: Vec4,
}
</code></pre>
<p>Note the use of <code>#[repr(C)]</code> to ensure that the data is properly laid out in memory.</p>
<p>When calling <code>cx.add_instances(&amp;SHADER, &amp;[MyShaderIns { pos, color }])</code>, we verify that the memory size of <code>MyShaderIns</code> matches that of the <code>instance</code> variables in the shader code.</p>
<p>This is how Rust types match with shader types:</p>
<table><thead><tr><th>Rust</th><th>Shader</th></tr></thead><tbody>
<tr><td>f32</td><td>float</td></tr>
<tr><td>Vec2</td><td>vec2</td></tr>
<tr><td>Vec3</td><td>vec3</td></tr>
<tr><td>Vec4</td><td>vec4</td></tr>
<tr><td>Mat4</td><td>mat4</td></tr>
</tbody></table>
<p>Note that within a function there are <a href="/target/doc/zaplib/enum.Ty.html">more types</a> you can use.</p>
<p>These are the types of variables you can declare:</p>
<ul>
<li><code>geometry</code>: these have to match exactly the <code>vertex_attributes</code> fields in <a href="/target/doc/zaplib/struct.Geometry.html#method.new"><code>Geometry::new</code></a>.</li>
<li><code>instance</code>: these have to match exactly the <code>data</code> fields in <a href="/target/doc/zaplib/struct.Cx.html#method.add_instances"><code>Cx::add_instances</code></a>.</li>
<li><code>uniform</code>: these have to match exactly the <code>uniforms</code> fields in <a href="/target/doc/zaplib/enum.Area.html#method.write_user_uniforms"><code>Area::write_user_uniforms</code></a>.</li>
<li><code>texture</code>: can only be of type <code>texture2D</code> and gets set using <a href="/target/doc/zaplib/enum.Area.html#method.write_user_uniforms"><code>Cx::write_user_uniforms</code></a>.</li>
<li><code>varying</code>: doesn't get passed in from Rust, but can be used to pass data from <code>fn vertex()</code> to <code>fn pixel()</code>.</li>
</ul>
<h2 id="shader-language"><a class="header" href="#shader-language">Shader language</a></h2>
<p>The shader language itself is modeled after Rust itself. You can use things like <code>fn</code>, <code>struct</code>, and so on. Two functions need to be defined for a shader to work:</p>
<ul>
<li><code>fn vertex()</code> defines the vertex shader. This gets called for each vertex returned from <code>build_geom</code>. It returns <code>vec4(x, y, z, w)</code> where the values mean the following:
<ul>
<li><code>x, y</code> — coordinates on the screen (from -1 to 1).</li>
<li><code>z</code> — draw order (from 0 to 1). Draws with higher <code>z</code> will be on top.</li>
<li><code>w</code> — normalization parameter. In 2d rendering this is simply set to 1.0.</li>
</ul>
</li>
<li><code>fn pixel()</code> defines the pixel shader. It returns a color as <code>vec4(r, g, b, a)</code>.</li>
</ul>
<p>See <a href="./tutorial_2d_rendering.html">Tutorial: Rendering 2D Shapes</a> for more about the basics of drawing in a shader.</p>
<table>
<thead><tr><td>Keyword</td><td>Description</td><td>Example</td></tr></thead>
<tr><td>const</td><td>Constant values</td><td><code>const PI: float = 3.141592653589793;</code></td></tr>
<tr><td>let</td><td>Variable (mutable)</td><td><code>let circle_size = 7. - stroke_width / 2.;</code></td></tr>
<tr><td>return</td><td>Return value</td><td><code>return 0.0;</code></td></tr>
<tr><td>if</td><td>Condition</td><td><pre><code>if errored > 0. {
    df.fill(error_color);
} else if loaded > 0. {
    df.fill(active_color);
} else {
    df.fill(inactive_color);
}</code></pre></td></tr>
<tr><td>#hex</td><td>Color</td><td><pre><code>return #ff0000;
return #f00;
return #f;</code></pre></td></tr>
<tr><td>fn</td><td>Function definition</td><td><pre><code>fn pixel() -> vec4 {
    return #f00;
}</code></pre></td></tr>
<tr><td>struct</td><td>Structure definition</td><td><pre><code>struct Df {
    pos: vec2,
    result: vec4,
}</code></pre></td></tr>
<tr><td>impl</td><td>Structure implementation</td><td><pre><code>impl Df {
    fn clear(inout self, color: vec4) {
        self.write_color(color, 1.0);
    }
}</code></pre></td></tr>
<tr><td>for</td><td>Range loop</td><td><pre><code>for i from 0 to 20 step 3 {
    if float(i) >= depth {
        break;
    }
}</code></pre></td></tr>
<tr><td>?</td><td>Ternary operator</td><td><code>let pos = is_left ? start : end;</code></td></tr>
</table>
<p>The following built-in functions are available: <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/abs.xhtml">abs</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/acos.xhtml">acos</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/acos.xhtml">acos</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/all.xhtml">all</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/any.xhtml">any</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/asin.xhtml">asin</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/atan.xhtml">atan</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/ceil.xhtml">ceil</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/clamp.xhtml">clamp</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/cos.xhtml">cos</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/cross.xhtml">cross</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/degrees.xhtml">degrees</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/dFdx.xhtml">dFdx</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/dFdy.xhtml">dFdy</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/distance.xhtml">distance</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/dot.xhtml">dot</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/equal.xhtml">equal</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/exp.xhtml">exp</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/exp2.xhtml">exp2</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/faceforward.xhtml">faceforward</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/floor.xhtml">floor</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/fract.xhtml">fract</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/greaterThan.xhtml">greaterThan</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/greaterThanEqual.xhtml">greaterThanEqual</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/inversesqrt.xhtml">inversesqrt</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/inverse.xhtml">inverse</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/length.xhtml">length</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/lessThan.xhtml">lessThan</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/lessThanEqual.xhtml">lessThanEqual</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/log.xhtml">log</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/log2.xhtml">log2</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/matrixCompMult.xhtml">matrixCompMult</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/max.xhtml">max</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/min.xhtml">min</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml">mix</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mod.xhtml">mod</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/normalize.xhtml">normalize</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/not.xhtml">not</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/notEqual.xhtml">notEqual</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/pow.xhtml">pow</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/radians.xhtml">radians</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/reflect.xhtml">reflect</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml">refract</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/sample2d.xhtml">sample2d</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/sign.xhtml">sign</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/sin.xhtml">sin</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml">smoothstep</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/sqrt.xhtml">sqrt</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/step.xhtml">step</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/tan.xhtml">tan</a>, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/transpose.xhtml">transpose</a>.</p>
<p><a href="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling">Swizzling</a> is also supported, for both <code>xyzw</code> and <code>rgba</code>. So you can do things like <code>let plane: vec2 = point.xy</code> or <code>let opaque: vec3 = color.rgba</code>.</p>
<h2 id="std_shader"><a class="header" href="#std_shader">STD_SHADER</a></h2>
<p>Zaplib provides <a href="/target/doc/zaplib/struct.Cx.html#associatedconstant.STD_SHADER">STD_SHADER</a>, a collection of common functions that are useful when writing shaders. For a complete run down on the available functions, it's best to directly look at the source, but we'll discuss some highlights.</p>
<h3 id="3d-space-transforms"><a class="header" href="#3d-space-transforms">3D space transforms</a></h3>
<p>These values are useful when working in 3D space, translating an object's scene coordinates into pixel locations on the screen.</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>camera_projection</td><td>mat4</td><td>Camera projection matrix - see <a href="https://en.wikipedia.org/wiki/3D_projection">3D projection</a>.</td></tr>
<tr><td>camera_view</td><td>mat4</td><td>View matrix - see <a href="https://en.wikipedia.org/wiki/Camera_matrix">Camera matrix</a>.</td></tr>
<tr><td>inv_camera_rot</td><td>mat4</td><td>The inverse rotation matrix for a camera. Useful for working with billboards.</td></tr>
</tbody></table>
<p>As a quick example, a basic vertex shader to convert from object to screen coordinates is:</p>
<pre><code class="language-rust noplayground">fn vertex() -&gt; vec4 {
    return camera_projection * camera_view * vec4(geom_position, 1.);
}
</code></pre>
<p>These values get set by a combination of <a href="/target/doc/zaplib/struct.Pass.html#method.set_matrix_mode"><code>Pass::set_matrix_mode</code></a> and the actual computed dimensions of a <a href="/target/doc/zaplib/struct.Pass.html"><code>Pass</code></a>. See e.g. the <a href="/target/doc/zaplib_components/struct.Viewport3D.html"><code>Viewport3D</code></a> component.</p>
<h3 id="rendering-helpers"><a class="header" href="#rendering-helpers">Rendering helpers</a></h3>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>dpi_factor</td><td>float</td><td>More commonly known as the &quot;device pixel ratio&quot;; represents the ratio of the resolution in physical pixels to the resolution in GPU pixels for the current display device.</td></tr>
<tr><td>dpi_dilate</td><td>float</td><td>Some amount by which to thicken lines, depending on the <code>dpi_factor</code></td></tr>
<tr><td>draw_clip</td><td>vec4</td><td><a href="https://en.wikipedia.org/wiki/Clipping_(computer_graphics)">Clip region</a> for rendering, represented as (x1,y1,x2,y2).</td></tr>
<tr><td>draw_scroll</td><td>vec2</td><td>The total 2D scroll offset, including all its parents. This is usually only relevant for 2D UI rendering.</td></tr>
<tr><td>draw_local_scroll</td><td>vec2</td><td>The 2D scroll offset excluding parents. This is usually only relevant for 2D UI rendering.</td></tr>
<tr><td>draw_zbias</td><td>float</td><td>A small increment that you can add to the z-axis of your vertices, which is based on the position of the draw call in the draw tree.</td></tr>
</tbody></table>
<h3 id="math"><a class="header" href="#math">Math</a></h3>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Math::rotate_2d</td><td>(v: vec2, a: float) -&gt; vec2</td><td>Rotate vector <code>v</code> by radians <code>a</code></td></tr>
</tbody></table>
<h3 id="colors"><a class="header" href="#colors">Colors</a></h3>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>hsv2rgb</td><td>(c: vec4) -&gt; vec4</td><td>Convert color <code>c</code> from <a href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSV representation</a> to <a href="https://en.wikipedia.org/wiki/RGB_color_model">RGB representation</a></td></tr>
<tr><td>rgb2hsv</td><td>(c: vec4) -&gt; vec4</td><td>Convert color <code>c</code> from <a href="https://en.wikipedia.org/wiki/RGB_color_model">RGB representation</a> to <a href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSV representation</a></td></tr>
</tbody></table>
<h3 id="useful-constants"><a class="header" href="#useful-constants">Useful constants</a></h3>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>PI</td><td>float</td><td><a href="https://en.wikipedia.org/wiki/Pi">Pi (π)</a></td></tr>
<tr><td>E</td><td>float</td><td><a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">e</a></td></tr>
<tr><td>LN2</td><td>float</td><td>ln(2) - The natural log of 2</td></tr>
<tr><td>LN10</td><td>float</td><td>ln(10) - The natural log of 10</td></tr>
<tr><td>LOG2E</td><td>float</td><td>log2(e) - Base-2 log of e</td></tr>
<tr><td>LOG10E</td><td>float</td><td>log2(e) - Base-10 log of e</td></tr>
<tr><td>SQRT1_2</td><td>float</td><td>sqrt(1/2) - Square root of 1/2</td></tr>
<tr><td>TORAD</td><td>float</td><td>Conversion factor of degrees to radians. Equivalent to PI/180.</td></tr>
<tr><td>GOLDEN</td><td>float</td><td><a href="https://en.wikipedia.org/wiki/Golden_ratio">Golden ratio</a></td></tr>
</tbody></table>
<h3 id="distance-fields"><a class="header" href="#distance-fields">Distance fields</a></h3>
<p>Zaplib contains many functions for <a href="https://jasmcole.com/2019/10/03/signed-distance-fields/">Signed Distance Fields (SDFs)</a> under the <code>Df</code> namespace. SDFs are a comprehensive way to define flexible shapes on the GPU. While applicable in 2D and 3D contexts, Zaplib uses this only for 2D rendering.</p>
<p>To create a distance field, use either:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Df::viewport</td><td>(pos: vec2) -&gt; Df</td><td>Creates a distance field with the current position</td></tr>
<tr><td>Df::viewport_px</td><td>(pos: vec2) -&gt; Df</td><td>Creates a distance field with the current position, factoring in <code>dpi_factor</code></td></tr>
</tbody></table>
<p>The following methods are available on the instantiated <code>Df</code> struct.</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>df.add_field</td><td>(field: float) -&gt; void</td><td>Adds a new field value to the current distance field</td></tr>
<tr><td>df.add_clip</td><td>(d: float) -&gt; void</td><td>Adds a clip mask to the current distance field</td></tr>
<tr><td>df.antialias</td><td>(p: vec2) -&gt; float</td><td>Distance-based antialiasing</td></tr>
<tr><td>df.translate</td><td>(offset: vec2) -&gt; vec2</td><td>Translate a specified offset</td></tr>
<tr><td>df.rotate</td><td>(a: float, pivot: vec2) -&gt; void</td><td>Rotate by <code>a</code> radians around <code>pivot</code></td></tr>
<tr><td>df.scale</td><td>(f: float, pivot: vec2) -&gt; void</td><td>Uniformly scale by factor <code>f</code> around <code>pivot</code></td></tr>
<tr><td>df.clear</td><td>(src: vec4)  -&gt; void</td><td>Sets clear color. Useful for specifying background colors before rendering a path.</td></tr>
<tr><td>df.new_path</td><td>() -&gt; void</td><td>Clears path in current distance field.</td></tr>
<tr><td>df.fill</td><td>(color: vec4) -&gt; vec4</td><td>Fills the current path with <code>color</code>.</td></tr>
<tr><td>df.stroke</td><td>(color: vec4, width: float) -&gt; vec4</td><td>Strokes the current path with <code>color</code> with a pixel width of <code>width</code>.</td></tr>
<tr><td>df.glow</td><td>(color: vec4, width: float) -&gt; vec4</td><td>Updates the current path by summing colors in <code>width</code> with the provided one.</td></tr>
<tr><td>df.union</td><td>() -&gt; void</td><td>Set field to the union of the current and previous field.</td></tr>
<tr><td>df.intersect</td><td>() -&gt; void</td><td>Set field to the intersection of the current and previous field.</td></tr>
<tr><td>df.subtract</td><td>() -&gt; void</td><td>Subtract current field from previous.</td></tr>
<tr><td>df.blend</td><td>(k: float) -&gt; void</td><td>Interpolate current field and previous with factor <code>k</code>.</td></tr>
<tr><td>df.circle</td><td>(p: vec2, r: float) -&gt; void</td><td>Render a circle at <code>p</code> with radius <code>r</code>.</td></tr>
<tr><td>df.arc</td><td>(p: vec2, r: float, angle_start: float, angle_end: float) -&gt; void</td><td>Render an arc at <code>p</code> with radius <code>r</code> between angles <code>angle_start</code> and <code>angle_end</code>.</td></tr>
<tr><td>df.rect</td><td>(p: vec2, d: vec2) -&gt; void</td><td>Render a rectangle at <code>p</code> with dimensions <code>d</code>.</td></tr>
<tr><td>df.box</td><td>(p: vec2, d: vec2, r: float) -&gt; void</td><td>Render a box with rounded corners at <code>p</code> with dimensions <code>d</code>. Use <code>r</code> to indicate the corner radius - if <code>r</code> is less than 1, render a basic rectangle. If <code>r</code> is bigger than <code>min(w, h)</code>, the result will be a circle.</td></tr>
<tr><td>df.triangle</td><td>(p0: vec2, p1: vec2, p2: vec2) -&gt; void</td><td>Render a triangle between points  <code>p0</code>, <code>p1</code>, <code>p2</code>.</td></tr>
<tr><td>df.hexagon</td><td>(p: vec2, r: float) -&gt; void</td><td>Render a hexagon at p with side length <code>r</code>.</td></tr>
<tr><td>df.move_to</td><td>(p: vec2) -&gt; void</td><td>Move to <code>p</code> in current path, not drawing from current position.</td></tr>
<tr><td>df.line_to</td><td>(p: vec2) -&gt; void</td><td>Render a line to <code>p</code> from current position.</td></tr>
<tr><td>df.close_path</td><td>() -&gt; void</td><td>End the current field by rendering a line back to the start point.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing"><a class="header" href="#drawing">Drawing</a></h1>
<p>In a <code>draw()</code> function, <a href="/target/doc/zaplib/struct.Cx.html"><code>Cx</code></a> provides a few different functions to actually render to the screen.</p>
<ul>
<li>Use <a href="/target/doc/zaplib/struct.Cx.html#method.add_instances"><code>add_instances</code></a> to render with a <a href="/target/doc/zaplib/struct.Shader.html"><code>Shader</code></a> and instance data. This will use the shader's <code>build_geom</code> as the rendered geometry.</li>
<li>Use <a href="/target/doc/zaplib/struct.Cx.html#method.add_mesh_instances"><code>add_mesh_instances</code></a> to render with a custom geometry, passing in a <a href="/target/doc/zaplib/struct.GpuGeometry.html"><code>GpuGeometry</code></a>.</li>
<li>Use <a href="/target/doc/zaplib/struct.Cx.html#method.add_instances_with_scroll_sticky"><code>add_instances_with_scroll_sticky</code></a> to disable default scrolling behavior and keep items sticky on the screen. This is only relevant for 2D rendering that respects scrolling, such as UI components.</li>
</ul>
<p>When calling one of these functions, under the hood we create a new <code>DrawCall</code> object, and nest it under the current <code>View</code>. However, a <code>DrawCall</code> is fairly expensive, so when possible we merge <code>DrawCall</code>s together. This is done when calling <code>cx.add_instances</code> multiple times in a row with the same shader. In that case we append the instance data to a single buffer, instead of creating multiple <code>DrawCall</code>s. In general we try to only do <code>DrawCall</code> batching when it doesn't alter any actual behavior.</p>
<h3 id="shader-groups"><a class="header" href="#shader-groups">Shader groups</a></h3>
<p>Sometimes it's useful be able to call <code>cx.add_instances</code> in a different order than you actually want to layer your draws. For example: when drawing a button, you might have a shader for the text and one for the background. In that case the background <code>DrawCall</code> should come first, followed by the text <code>DrawCall</code> which sits on top. But you might want to actually generate the text first, since that will determine the size of the button.</p>
<p>In such a scenario, it is of course possible to generate the <code>TextIns</code> objects first, then determine the button size, create the background <code>DrawCall</code>, and finally create the text <code>DrawCall</code> using the <code>TextIns</code> objects. But this often leads to ugly abstractions.</p>
<p>To solve for this, you can call <a href="/target/doc/zaplib/struct.Cx.html#method.begin_shader_group"><code>cx.begin_shader_group</code></a>, which takes an array of <code>Shader</code>s in a certain order and will make sure the <code>DrawCall</code>s get ordered accordingly. You then close the group by calling <code>cx.end_shader_group</code>.</p>
<p>As a bonus, if you create multiple shader groups in a row with the same shaders, then we'll apply <code>DrawCall</code> batching on all the <code>DrawCall</code>s in those groups. This means that you can draw many buttons in a row, and still get batching on both the backgrounds and the texts. For big UIs this can make a substantial difference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-ui-components"><a class="header" href="#tutorial-ui-components">Tutorial: UI Components</a></h1>
<p>In this tutorial we will go through how to use some of the basic UI components provided by Zaplib:</p>
<ul>
<li><a href="tutorial_ui_components.html#step-1-button"><code>Button</code></a></li>
<li><a href="tutorial_ui_components.html#step-2-floatslider"><code>FloatSlider</code></a></li>
<li><a href="tutorial_ui_components.html#step-3-scrollview"><code>ScrollView</code></a></li>
</ul>
<h2 id="step-1-button"><a class="header" href="#step-1-button">Step 1: <code>Button</code></a></h2>
<p>Let's create button that would be simply incrementing a counter.</p>
<p>Create a <code>Cargo.toml</code> with <code>zaplib</code> and <code>zaplib_components</code> dependencies crates:</p>
<pre><code class="language-toml">[package]
name = &quot;tutorial_ui_components&quot;
version = &quot;0.0.1&quot;
edition = &quot;2021&quot;

[dependencies]
zaplib = { path=&quot;../../main&quot; }
zaplib_components = { path=&quot;../../components&quot; }
</code></pre>
<p>In <code>main.rs</code> include a library of components:</p>
<pre><code class="language-rust noplayground">use zaplib_components::*;
</code></pre>
<p>Add a button and a counter to <code>App</code> struct:</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
struct App {
    window: Window,
    pass: Pass,
    view: View,
    button: Button,
    counter: i32,
}
</code></pre>
<p>Modify the <code>draw</code> function to draw the button and the value of the counter:</p>
<pre><code class="language-rust noplayground">    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
        self.view.begin_view(cx, LayoutSize::FILL);

        cx.begin_padding_box(Padding::vh(50., 50.));
        self.button.draw(cx, &quot;Increment Counter&quot;);
        TextIns::draw_walk(cx, &amp;format!(&quot;Counter: {}&quot;, self.counter), &amp;TextInsProps::default());
        cx.end_padding_box();

        self.view.end_view(cx);
        self.pass.end_pass(cx);
        self.window.end_window(cx);
    }
</code></pre>
<ul>
<li><code>cx.begin_padding_box</code> adds the padding to application window</li>
<li><code>button.draw</code> draws the button with the given label</li>
<li><code>format!</code> creates the string with using <code>self.counter</code> value</li>
<li><code>TextIns::draw_walk</code> draws the text on the screen</li>
</ul>
<p>Modify the <code>handle</code> function to increment the counter when the button was pressed:</p>
<pre><code class="language-rust noplayground">    fn handle(&amp;mut self, cx: &amp;mut Cx, event: &amp;mut Event) {
        if let ButtonEvent::Clicked = self.button.handle(cx, event) {
            self.counter += 1;
            cx.request_draw();
        }
    }
</code></pre>
<ul>
<li><code>button.handle</code> returns enum with possible events this component could trigger. We check if the button was clicked (<code>ButtonEvent::Clicked</code>). Other options are <code>ButtonEvent::Down</code>, <code>ButtonEvent::Up</code> and <code>ButtonEvent::None</code>.</li>
<li><code>cx.request_draw()</code> is called to re-render the application window.</li>
</ul>
<p>After pressing the button for a few times we can see the counter value changing:</p>
<p><img src="./img/tutorial_ui_components_1.png" alt="" /></p>
<h2 id="step-2-floatslider"><a class="header" href="#step-2-floatslider">Step 2: <code>FloatSlider</code></a></h2>
<p>Now let's add the slider bar that would modify the same counter.</p>
<p>Add <code>FloatSlider</code> to <code>App</code> struct:</p>
<pre><code class="language-rust noplayground">struct App {
    // ...
    slider: FloatSlider,
}
</code></pre>
<p>Draw the slider inside <code>draw</code> function:</p>
<pre><code class="language-rust noplayground">        cx.begin_padding_box(Padding::vh(50., 50.));
        self.button.draw(cx, &quot;Increment Counter&quot;);
        TextIns::draw_walk(cx, &amp;format!(&quot;Counter: {}&quot;, self.counter), &amp;TextInsProps::default());

        self.slider.draw(cx, self.counter as f32, 0., 100., Some(1.0), 1.0, None);
        cx.end_padding_box();
</code></pre>
<ul>
<li><code>slider.draw</code> draws the slider with current position at <code>self.counter</code> in a <code>0.</code> to <code>100.</code> range with step increments of <code>1.0</code>.</li>
</ul>
<p>Finally, connect the slider with the main application in <code>handle</code> function:</p>
<pre><code class="language-rust noplayground">   fn handle(&amp;mut self, cx: &amp;mut Cx, event: &amp;mut Event) {
       // ...

       if let FloatSliderEvent::Change { scaled_value } = self.slider.handle(cx, event) {
           self.counter = scaled_value as i32;
           cx.request_draw();
       }
   }
</code></pre>
<p>Now we can see that counter value is controlled by both the button and the slider:</p>
<p><img src="./img/tutorial_ui_components_2.png" alt="" /></p>
<h2 id="step-3-scrollview"><a class="header" href="#step-3-scrollview">Step 3: <code>ScrollView</code></a></h2>
<p>To illustrate the usage of <code>ScrollView</code> let's draw some long text on the screen. Modify the <code>draw</code> function to draw  rows equal to <code>self.counter</code> value:</p>
<pre><code class="language-rust noplayground">        cx.begin_padding_box(Padding::vh(50., 50.));
        self.button.draw(cx, &quot;Increment Counter&quot;);
        TextIns::draw_walk(cx, &amp;format!(&quot;Counter: {}&quot;, self.counter), &amp;TextInsProps::default());

        self.slider.draw(cx, self.counter as f32, 0., 100., Some(1.0), 1.0, None);

        for value in 0..self.counter {
            TextIns::draw_walk(cx, &amp;format!(&quot;row #{}&quot;, value), &amp;TextInsProps::default());
        }

        cx.end_padding_box();
</code></pre>
<p>As we can see the rows went beyond the bounds of the application window:</p>
<p><img src="./img/tutorial_ui_components_3.png" alt="" /></p>
<p>Let's fix this by adding a <code>ScrollView</code> component.</p>
<p>Modify the <code>App</code> struct to include <code>ScrollView</code></p>
<pre><code class="language-rust noplayground">struct App {
    // ...
    scroll_view: ScrollView,
}
</code></pre>
<p>Update the <code>App::new</code> constructor:</p>
<pre><code class="language-rust noplayground">    fn new(_cx: &amp;mut Cx) -&gt; Self {
        App {
            scroll_view: ScrollView::new_standard_vh(),
            ..Self::default()
        }
    }
</code></pre>
<p>In the <code>draw</code> function add <code>begin_view</code>  and <code>end_view</code> around the text drawing block</p>
<pre><code class="language-rust noplayground">        self.scroll_view.begin_view(cx, LayoutSize::FILL);
        for value in 0..self.counter {
            TextIns::draw_walk(cx, &amp;format!(&quot;row #{}&quot;, value), &amp;TextInsProps::default());
        }
        self.scroll_view.end_view(cx);
</code></pre>
<p>Finally, update the <code>handle</code> function to enable scrolling:</p>
<pre><code class="language-rust noplayground">    fn handle(&amp;mut self, cx: &amp;mut Cx, event: &amp;mut Event) {
        // ...
        self.scroll_view.handle(cx, event);
    }
</code></pre>
<ul>
<li>We are not modifying the internal <code>App</code>'s state on scroll events, so we just ignore the return value of <code>scroll_view.handle</code> call</li>
</ul>
<p>You can run this full example with Cargo:</p>
<pre><code class="language-bash">cargo run -p tutorial_ui_components
</code></pre>
<p><img src="./img/tutorial_ui_components_4.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-ui-layout"><a class="header" href="#tutorial-ui-layout">Tutorial: UI Layout</a></h1>
<p>This tutorial builds on top of the previous <a href="./tutorial_ui_components.html">UI Components</a> tutorial, by modifying it. We will reorganize UI components on the screen using layouting system.</p>
<p>First, let's add another button to decrement the counter.</p>
<p>Update <code>App</code> struct:</p>
<pre><code class="language-rust noplayground">#[derive(Default)]
struct App {
    window: Window,
    pass: Pass,
    view: View,
    button_inc: Button,
    button_dec: Button,
    counter: i32,
    slider: FloatSlider,
    scroll_view: ScrollView,
}
</code></pre>
<p>Handle the clicks from the decrement button:</p>
<pre><code class="language-rust noplayground">    fn handle(&amp;mut self, cx: &amp;mut Cx, event: &amp;mut Event) {
        if let ButtonEvent::Clicked = self.button_inc.handle(cx, event) {
            self.counter += 1;
            cx.request_draw();
        }
        if let ButtonEvent::Clicked = self.button_dec.handle(cx, event) {
            self.counter -= 1;
            cx.request_draw();
        }

        if let FloatSliderEvent::Change { scaled_value } = self.slider.handle(cx, event) {
            self.counter = scaled_value as i32;
            cx.request_draw();
        }

        self.scroll_view.handle(cx, event);
    }
</code></pre>
<p>Update the <code>draw</code> function to draw the decrement button:</p>
<pre><code class="language-rust noplayground">        cx.begin_padding_box(Padding::vh(50., 50.));
        
        self.button_dec.draw(cx, &quot;Decrement&quot;);
        self.button_inc.draw(cx, &quot;Increment&quot;);
        self.slider.draw(cx, self.counter as f32, 0., 100., Some(1.0), 1.0, None);    

        TextIns::draw_walk(cx, &amp;format!(&quot;Counter: {}&quot;, self.counter), &amp;TextInsProps::default());
        // ...
        cx.end_padding_box();
</code></pre>
<p><img src="img/tutorial_ui_layout_1.png" alt="" /></p>
<p>Now let's move these 2 buttons and a slider on the bottom of the app. We also want the buttons to be on the other sides of slider and slider spanning all space in the middle.</p>
<pre><code class="language-rust noplayground">        cx.begin_padding_box(Padding::vh(50., 50.));

        cx.begin_bottom_box();
        cx.begin_row(Width::Fill, Height::Compute);
        {
            self.button_dec.draw(cx, &quot;Decrement&quot;);
            cx.begin_right_box();
            self.button_inc.draw(cx, &quot;Increment&quot;);
            cx.end_right_box();
            self.slider.draw(cx, self.counter as f32, 0., 100., Some(1.0), 1.0, None);    
        }
        cx.end_row();
        cx.end_bottom_box();
        // ...
        cx.end_padding_box();
</code></pre>
<ul>
<li><code>cx.begin_bottom_box</code> starts a block that would be aligned to the bottom of the screen</li>
<li><code>cx.begin_row</code> starts a container that draws components into a row. Arguments are the sizes of the container:
<ul>
<li><code>Width::Fill</code> specifies to span the entire available width</li>
<li><code>Height::Compute</code> specifies to use the height of underlying components</li>
</ul>
</li>
<li>Note we use curly braces to visually distinguish nested block of components</li>
<li><code>cx.begin_right_box</code> starts a block that would be aligned to the right of the screen</li>
<li><code>cx.end_right_box</code> ends corresponding right-aligned block</li>
<li><code>cx.end_row</code> ends corresponding row</li>
<li><code>cd.end_bottom_box</code> ends corresponding bottom-aligned block</li>
</ul>
<p>The application now looks like this:</p>
<p><img src="img/tutorial_ui_layout_2.png" alt="" /></p>
<p>Now let's divide the text area into 2 parts and draw the text in each of them.</p>
<p>Add <code>Splitter</code> to <code>App</code> struct:</p>
<pre><code class="language-rust noplayground">struct App {
    // ...
    splitter: Splitter,
}
</code></pre>
<p>Set the initial state for <code>Splitter</code> inside <code>new</code> function:</p>
<pre><code class="language-rust noplayground">    fn new(_cx: &amp;mut Cx) -&gt; Self {
        let mut splitter = Splitter::default();
        splitter.set_splitter_state(SplitterAlign::First, 300., Axis::Vertical);
        App { scroll_view: ScrollView::new_standard_vh(), splitter, ..Self::default() }
    }
</code></pre>
<ul>
<li><code>Axis::Vertical</code> specifies that the orientation for divider</li>
<li><code>300.</code> is the initial offset in pixels for divider</li>
</ul>
<p>Update the <code>handle</code> function:</p>
<pre><code class="language-rust noplayground">    fn handle(&amp;mut self, cx: &amp;mut Cx, event: &amp;mut Event) {
        // ...        
        self.splitter.handle(cx, event);
    }
</code></pre>
<p>Update the <code>draw</code> function to use the splitter:</p>
<pre><code class="language-rust noplayground">        cx.begin_row(Width::Fill, Height::Fill);
        {
            self.splitter.begin_draw(cx);
            {
                self.scroll_view.begin_view(cx, LayoutSize::FILL);
                cx.begin_column(Width::Compute, Height::Compute);

                for value in 0..self.counter {
                    TextIns::draw_walk(cx, &amp;format!(&quot;row #{}&quot;, value), &amp;TextInsProps::default());
                }
                cx.end_column();
                self.scroll_view.end_view(cx);
            }
            self.splitter.mid_draw(cx);
            {
                TextIns::draw_walk(cx, &amp;format!(&quot;Counter: {}&quot;, self.counter), &amp;TextInsProps::default());
            }
            self.splitter.end_draw(cx);
        }
        cx.end_row();
</code></pre>
<ul>
<li>We need to enclose the splitter into <code>begin_row</code> as we want it to be drawn as a row</li>
<li><code>splitter.begin_draw</code> starts the splitter block that would be drawn first</li>
<li><code>splitter.mid_draw</code> start the splitter block that be drawn second</li>
<li><code>splitter.end_draw</code> ends the splitter component</li>
</ul>
<p>You can run this full example with Cargo:</p>
<pre><code class="language-bash">cargo run -p tutorial_ui_layout
</code></pre>
<p><img src="./img/tutorial_ui_layout_3.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-overview-2"><a class="header" href="#api-overview-2">API Overview</a></h1>
<ul>
<li><a href="./ui_api_overview_components.html">UI Components</a></li>
<li><a href="./ui_api_overview_layout.html">Layout</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui-components"><a class="header" href="#ui-components">UI Components</a></h1>
<table><thead><tr><th>Component</th><th>Description</th><th></th></tr></thead><tbody>
<tr><td><a href="/target/doc/zaplib_components/struct.Background.html"><code>Background</code></a></td><td>Draws background of specified color</td><td></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.Button.html"><code>Button</code></a></td><td>Allows the user to take actions by clicking on it</td><td><a href="ui_api_overview_components.html#button">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.Chart.html"><code>Chart</code></a></td><td>Draws charts with tooltips</td><td><a href="ui_api_overview_components.html#chart">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.Checkbox.html"><code>Checkbox</code></a></td><td>Allows the user to select/unselect specific items</td><td><a href="ui_api_overview_components.html#checkbox">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.DesktopWindow.html"><code>DesktopWindow</code></a></td><td>Adds menu/top bar in a desktop application</td><td></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.Dock.html"><code>Dock</code></a></td><td>Provides a dock with tabs. Tabs could be dragged around or to split the screen</td><td><a href="ui_api_overview_components.html#dock">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.FloatSlider.html"><code>FloatSlider</code></a></td><td>Allows the user to make selection from a range of values</td><td><a href="ui_api_overview_components.html#floatslider">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.FoldCaption.html"><code>FoldCaption</code></a></td><td>Shows foldable content with a custom caption</td><td><a href="ui_api_overview_components.html#foldcaption">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.FpsCounter.html"><code>FpsCounter</code></a></td><td>Displays the current frame rate</td><td><a href="ui_api_overview_components.html#fpscounter">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.Popover.html"><code>Popover</code></a></td><td>Shows an overlay with custom content</td><td><a href="ui_api_overview_components.html#popover">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.ScrollView.html"><code>ScrollView</code></a></td><td>Adds horizontal and/or vertical scroll for content that doesn't fit on the screen</td><td></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.Splitter.html"><code>Splitter</code></a></td><td>Splits the screen horizontally or vertically with draggable divider in between</td><td><a href="ui_api_overview_components.html#splitter">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.TextEditor.html"><code>TextEditor</code></a></td><td>Displays editable multi-line text with line numbers and syntax highlighting</td><td><a href="ui_api_overview_components.html#texteditor">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.TextInput.html"><code>TextInput</code></a></td><td>Allows the user to enter and edit text</td><td><a href="ui_api_overview_components.html#textinput">View</a></td></tr>
<tr><td><a href="/target/doc/zaplib_components/struct.Viewport3D.html"><code>Viewport3D</code></a></td><td>Shows 3D rendered scene that could be moved and rotated</td><td><a href="ui_api_overview_components.html#viewport3d">View</a></td></tr>
</tbody></table>
<h2 id="gallery"><a class="header" href="#gallery">Gallery</a></h2>
<h3 id="button"><a class="header" href="#button">Button</a></h3>
<p><img src="./img/overview_ui_button.apng" alt="" /></p>
<h3 id="chart"><a class="header" href="#chart">Chart</a></h3>
<p><img src="./img/overview_ui_chart.gif" alt="" /></p>
<h3 id="checkbox"><a class="header" href="#checkbox">Checkbox</a></h3>
<p><img src="./img/overview_ui_checkbox.apng" alt="" /></p>
<h3 id="dock"><a class="header" href="#dock">Dock</a></h3>
<p><img src="./img/overview_ui_dock.gif" alt="" /></p>
<h3 id="floatslider"><a class="header" href="#floatslider">FloatSlider</a></h3>
<p><img src="./img/overview_ui_floatslider.apng" alt="" /></p>
<h3 id="foldcaption"><a class="header" href="#foldcaption">FoldCaption</a></h3>
<p><img src="./img/overview_ui_foldcaption.apng" alt="" /></p>
<h3 id="fpscounter"><a class="header" href="#fpscounter">FpsCounter</a></h3>
<p><img src="./img/overview_ui_fpscounter.apng" alt="" /></p>
<h3 id="popover"><a class="header" href="#popover">Popover</a></h3>
<p><img src="./img/overview_ui_popover.apng" alt="" /></p>
<h3 id="splitter"><a class="header" href="#splitter">Splitter</a></h3>
<p><img src="./img/overview_ui_splitter.apng" alt="" /></p>
<h3 id="texteditor"><a class="header" href="#texteditor">TextEditor</a></h3>
<p><img src="./img/overview_ui_texteditor.png" alt="" /></p>
<h3 id="textinput"><a class="header" href="#textinput">TextInput</a></h3>
<p><img src="./img/overview_ui_textinput.apng" alt="" /></p>
<h3 id="viewport3d"><a class="header" href="#viewport3d">Viewport3D</a></h3>
<p><img src="./img/overview_ui_viewport3d.apng" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">Layout</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Layouting is a mechanism in Zaplib to position components on the screen.</p>
<p>A core philosophy of the Zaplib layouting model is its simplicity and speed, by having only a single pass
to do layouting. Contrast this with systems like <a href="https://en.wikipedia.org/wiki/CSS_Flexible_Box_Layout">CSS Flexbox</a>,
which use a constraint satisfaction system to lay out your widgets. Instead, we make a single
pass, but do sometimes shift over individual elements after the fact. When doing this we can regard it as a &quot;1.5-pass&quot; rendering. </p>
<ul>
<li>The core concept is a &quot;box&quot; - entity having a current draw position and a &quot;sandbox&quot; where it can draw in.</li>
<li>Boxes can be nested, so we have a stack of boxes. </li>
<li>The boxes are defined imperatively: new boxes are pushed to the stack using various <code>begin_*</code> methods and popped using corresponding <code>end_*</code> methods. </li>
<li>The last box in the stack is the &quot;active&quot; one and all rendering calls are added to that box's sandbox. </li>
<li>When the active box is ended it's sandbox content is pushed into its parent's sandbox (potentially shifted when using alignments) and then parent draw position is moved accordingly. </li>
</ul>
<p>For the examples on how to use the Layout API, follow the <a href="./tutorial_ui_layout.html">UI Layout</a> tutorial.</p>
<h2 id="api-overview-3"><a class="header" href="#api-overview-3">API Overview</a></h2>
<!-- Define styles that would be used in example below -->
<style>
.box {
  background-color: rgba(0,0,255,.2);
  border: 3px solid #00f;
  margin: 2px;
}

.content_box {
  background-color: #fff;
  border: 3px solid #00f;
}

.outer {
  border: 3px solid #000;
  padding: 5px;
  display: flex;
}
.caption {
  border: 0px;
  margin: 2px;
}
.row {
  display: flex;
  margin: 5px;
}
</style>
<h3 id="begin_row--end_row"><a class="header" href="#begin_row--end_row"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_row"><code>begin_row</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_row"><code>end_row</code></a></a></h3>
<p>Defines a box that has its nested elements layed out horizontally (as a row).</p>
<div class="outer" style="flex-direction: row; width: 250px">
  <div class="box" style="width: 75px; height: 75px">Box 1</div>
  <div class="box" style="width: 100px; height: 100px">Box 2</div>
  <div class="box" style="width: 50px; height: 50px">Box 3</div>
</div>
<h3 id="begin_column--end_column"><a class="header" href="#begin_column--end_column"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_column"><code>begin_column</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_column"><code>end_column</code></a></a></h3>
<p>Defines a box that has it nested elements layed out vertically (as a column).</p>
<div class="outer" style="flex-direction: column; width: 110px">
  <div class="box" style="width: 75px; height: 75px">Box 1</div>
  <div class="box" style="width: 100px; height: 100px">Box 2</div>
  <div class="box" style="width: 50px; height: 50px">Box 3</div>
</div>
<h3 id="begin_absolute_box--end_absolute_box"><a class="header" href="#begin_absolute_box--end_absolute_box"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_absolute_box"><code>begin_absolute_box</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_absolute_box"><code>end_absolute_box</code></a></a></h3>
<p>Defines a box that is absolutely positioned starting at (0, 0) coordinate. Normally the new box starts at the current draw position of the active box. This method allows to bypass that and use absolute coordinates on the screen.</p>
<h3 id="begin_padding_box--end_padding_box"><a class="header" href="#begin_padding_box--end_padding_box"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_padding_box"><code>begin_padding_box</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_padding_box"><code>end_padding_box</code></a></a></h3>
<p>Defines a box that has padding inside. </p>
<div class="outer" style="flex-direction: column; width: 250px; height: 160px">
    <div class="row" style="flex-direction: row; width: 250px; height: 30px">
        <div  style="width: 70px; height: 30px"></div>
        <div cstyle="width: 100px; height: 30px">Top Padding</div>
    </div>
    <div class="row" style="flex-direction: row; width: 250px; height: 50px">
        <div  style="width: 70px; height: 50px"> Left Padding</div>
        <div class="box" style="width: 100px; height: 50px">Content</div>
        <div  style="width: 50px; height: 50px"> Right Padding</div>
    </div>
    <div class="row" style="flex-direction: row; width: 250px; height: 50px">
        <div style="width: 70px; height: 50px"> </div>
        <div style="width: 100px; height: 50px">Bottom Padding</div>
    </div>
</div>
<h3 id="begin_wrapping_box--end_wrapping_box"><a class="header" href="#begin_wrapping_box--end_wrapping_box"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_wrapping_box"><code>begin_wrapping_box</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_wrapping_box"><code>end_wrapping_box</code></a></a></h3>
<p>Defines a box that is wrapping its content inside. This is only supported for horizontal direction. This is defined in terms of child boxes, meaning that if any of the immediately nested boxes goes beyond the bounds, it would be wrapped to new line). Text has its own wrapping mechanism via <a href="/target/doc/zaplib/struct.TextInsProps.html#structfield.wrapping"><code>TextInsProps::wrapping</code></a>.</p>
<h3 id="begin_right_box--end_right_box"><a class="header" href="#begin_right_box--end_right_box"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_right_box"><code>begin_right_box</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_right_box"><code>end_right_box</code></a></a></h3>
<p>Defines a box that will be aligned to the right by x axis within last box.</p>
<div class="outer" style="flex-direction: row-reverse; width: 250px">
  <div class="box" style="width: 50px; height: 50px">Right Box</div>
</div>
<h3 id="begin_bottom_box--end_bottom_box"><a class="header" href="#begin_bottom_box--end_bottom_box"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_bottom_box"><code>begin_bottom_box</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_bottom_box"><code>end_bottom_box</code></a></a></h3>
<p>Defines a box that will be aligned to the bottom by y axis within last box.</p>
<div class="outer" style="flex-direction: column-reverse; width: 70px; height: 250px">
  <div class="box" style="width: 60px; height: 60px">Bottom Box</div>
</div>
<h3 id="begin_center_x_align--end_center_x_align"><a class="header" href="#begin_center_x_align--end_center_x_align"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_center_x_align"><code>begin_center_x_align</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_center_x_align"><code>end_center_x_align</code></a></a></h3>
<p>Defines a box that fills up all remaining space by x axis and will be aligned to center by x axis within last box.</p>
<div class="outer" style="flex-direction: row; justify-content: center; width: 150px; height: 150px">
  <div class="box" style="width: 50px; height: 50px">Box</div>
</div>
<h3 id="begin_center_y_align--end_center_y_align"><a class="header" href="#begin_center_y_align--end_center_y_align"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_center_y_align"><code>begin_center_y_align</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_center_y_align"><code>end_center_y_align</code></a></a></h3>
<p>Defines a box that fills up all remaining space by y axis and will be aligned to center by y axis within last box.</p>
<div class="outer" style="flex-direction: column; justify-content: center; width: 150px; height: 150px">
  <div class="box" style="width: 50px; height: 50px">Box</div>
</div>
<h3 id="begin_center_x_and_y_align--end_center_x_and_y_align"><a class="header" href="#begin_center_x_and_y_align--end_center_x_and_y_align"><a href="/target/doc/zaplib/struct.Cx.html#method.begin_center_x_and_y_align"><code>begin_center_x_and_y_align</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.end_center_x_and_y_align"><code>end_center_x_and_y_align</code></a></a></h3>
<p>Defines a box that fills up all remaining space by x and y axises and will be aligned to center by both x and y axises within last box.</p>
<div class="outer" style="flex-direction: column; align-items: center; justify-content: center; width: 150px; height: 150px">
  <div class="box" style="width: 50px; height: 50px">Box</div>
</div>
<h3 id="get_box_rect"><a class="header" href="#get_box_rect"><a href="/target/doc/zaplib/struct.Cx.html#method.get_box_rect"><code>get_box_rect</code></a></a></h3>
<p>Returns the full rect corresponding to current box. It counts all available_width/height plus padding.</p>
<h3 id="get_width_left--get_height_left"><a class="header" href="#get_width_left--get_height_left"><a href="/target/doc/zaplib/struct.Cx.html#method.get_width_left"><code>get_width_left</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.get_height_left"><code>get_height_left</code></a></a></h3>
<p>Returns the amount of width / height left within the current box. </p>
<h3 id="get_width_total--get_height_total"><a class="header" href="#get_width_total--get_height_total"><a href="/target/doc/zaplib/struct.Cx.html#method.get_width_total"><code>get_width_total</code></a> / <a href="/target/doc/zaplib/struct.Cx.html#method.get_height_total"><code>get_height_total</code></a></a></h3>
<p>Get some notion of the total width / height of the active box. If the width/ height is well defined, then we return it. If it's computed, then we return the bound (including padding) of how much we've drawn so far. And if we haven't drawn anything, we return 0.</p>
<h3 id="get_box_bounds"><a class="header" href="#get_box_bounds"><a href="/target/doc/zaplib/struct.Cx.html#method.get_box_bounds"><code>get_box_bounds</code></a></a></h3>
<p>Get the bounds of what the box has actually drawn, including any padding that the layout of the active box specifies.</p>
<h3 id="get_box_origin"><a class="header" href="#get_box_origin"><a href="/target/doc/zaplib/struct.Cx.html#method.get_box_origin"><code>get_box_origin</code></a></a></h3>
<p>Returns the starting position of the active box in absolute coordinates.</p>
<h3 id="get_draw_pos"><a class="header" href="#get_draw_pos"><a href="/target/doc/zaplib/struct.Cx.html#method.get_draw_pos"><code>get_draw_pos</code></a></a></h3>
<p>Returns the current draw position of the active box in absolute coordinates.</p>
<h3 id="add_box"><a class="header" href="#add_box"><a href="/target/doc/zaplib/struct.Cx.html#method.add_box"><code>add_box</code></a></a></h3>
<p>Moves the current draw position of the active box as if the new box with provided dimensions was drawn inside.</p>
<h3 id="move_draw_pos"><a class="header" href="#move_draw_pos"><a href="/target/doc/zaplib/struct.Cx.html#method.move_draw_pos"><code>move_draw_pos</code></a></a></h3>
<p>Manually move the current draw position of the active box. Warning! Does not update bounds like <code>add_box</code> does; might result in unexpected behavior.</p>
<h3 id="set_draw_pos"><a class="header" href="#set_draw_pos"><a href="/target/doc/zaplib/struct.Cx.html#method.set_draw_pos"><code>set_draw_pos</code></a></a></h3>
<p>Manually set the current draw position of the active box. Warning! Does not update bounds like <code>add_box</code> does; might result in unexpected behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h1>
<p>Zaplib is still in its early days, and there are quite a few things to stabilize. Here are some of the known issues.</p>
<p><strong>Overall</strong></p>
<ul>
<li>Few automated tests yet (except for JS&lt;=&gt;Wasm bridge and some font stuff).</li>
</ul>
<p><strong>Wasm runtime</strong></p>
<ul>
<li><code>test_multithread</code> deadlocks in Chrome after a while (not sure about other browsers).</li>
<li>Safari 15.2 <code>test_multithread</code> doesn't work well at all (even after <a href="https://bugs.webkit.org/show_bug.cgi?id=234833">this bugfix</a>).</li>
<li>Touch is not super well tested/supported yet.</li>
<li>Memory initialization in Mobile Safari is not working well (often doesn't allocate enough memory); see also <a href="https://github.com/WebAssembly/design/issues/1397">this thread</a>.</li>
<li>Threads leak memory since we never deallocate the TLS/shadow stack (see also <a href="https://github.com/rust-lang/rust/issues/77839">this issue</a>).</li>
<li>Error handling is confusing; a panic can cause the console to get flooded with unrelated errors afterwards.</li>
</ul>
<p><strong>JS&lt;=&gt;Wasm bridge</strong></p>
<ul>
<li>Issues with capturing/preventing mouse events (e.g. right click).</li>
<li>No enforcement of buffer constraints (e.g. read-only; no use after moving ownership back to Rust).</li>
</ul>
<p><strong>Rendering</strong></p>
<ul>
<li>Some memory leakage / wastage of CPU/GPU buffers.</li>
<li>Resizing the window can be janky/laggy.</li>
<li>Layouts can be confusing/buggy.</li>
<li>2d rendering API doesn't fully match HTML 2d canvas behavior (though we have to decide what level of discrepancy we're okay with).</li>
</ul>
<p><strong>OSX native</strong></p>
<ul>
<li>Redrawing seems to leak a lot of memory.</li>
</ul>
<p><strong>OSX CEF</strong></p>
<ul>
<li>Stuck on old version (because we only got single process working on an old version).</li>
<li>Missing APIs compared to JS&lt;=&gt;Wasm bridge.</li>
<li>Too many memory copies.</li>
<li>Missing support for layering Rust rendering behind web rendering (only on top is supported).</li>
</ul>
<p><strong>Win/Linux</strong></p>
<ul>
<li>Bunch of missing APIs.</li>
<li>Not well-tested.</li>
<li>Windows is currently broken altogether.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
