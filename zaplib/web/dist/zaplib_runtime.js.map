{"version":3,"file":"zaplib_runtime.js","mappings":"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","sources":["webpack://zaplib/webpack/universalModuleDefinition","webpack://zaplib/./zaplib.css","webpack://zaplib/./node_modules/css-loader/dist/runtime/api.js","webpack://zaplib/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack://zaplib/./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack://zaplib/./common.ts","webpack://zaplib/./test_helpers.ts","webpack://zaplib/./type_of_runtime.ts","webpack://zaplib/./types.ts","webpack://zaplib/./zap_buffer.ts","webpack://zaplib/./zerde.ts","webpack://zaplib/./node_modules/worker-loader/dist/runtime/inline.js","webpack://zaplib/webpack/bootstrap","webpack://zaplib/webpack/runtime/compat get default export","webpack://zaplib/webpack/runtime/define property getters","webpack://zaplib/webpack/runtime/hasOwnProperty shorthand","webpack://zaplib/webpack/runtime/make namespace object","webpack://zaplib/./main_worker.ts","webpack://zaplib/./async_worker.ts","webpack://zaplib/./task_worker.ts","webpack://zaplib/./make_rpc_event.ts","webpack://zaplib/./rpc_types.ts","webpack://zaplib/./make_textarea.ts","webpack://zaplib/./webgl_renderer.ts","webpack://zaplib/./default_styles.ts","webpack://zaplib/./wasm_runtime.ts","webpack://zaplib/./loading_indicator.ts","webpack://zaplib/./cursor_map.ts","webpack://zaplib/./zerde_keyboard_handlers.ts","webpack://zaplib/./cef_runtime.ts","webpack://zaplib/./zaplib.css?4485","webpack://zaplib/./zaplib_runtime.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"zaplib\"] = factory();\n\telse\n\t\troot[\"zaplib\"] = factory();\n})(self, function() {\nreturn ","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"./node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"./node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".zaplib_canvas {\\n    position: absolute; /* For z-index */\\n    top: 0;\\n    left: 0;\\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\\n    z-index: 2147483647;\\n    width: 100%;\\n    height: 100%;\\n    pointer-events: none;\\n    user-select: none;\\n    touch-action: pan-x pan-y; /* Mobile Safari doesn't support \\\"none\\\" */\\n}\\n\\ntextarea.zaplib_textarea {\\n    z-index: 1000;\\n    position: absolute;\\n    opacity: 0;\\n    border-radius: 4px;\\n    color:white;\\n    font-size: 6;\\n    background: gray;\\n    -moz-appearance: none;\\n    appearance:none;\\n    border:none;\\n    resize: none;\\n    outline: none;\\n    overflow: hidden;\\n    text-indent: 0px;\\n    padding: 0 0px;\\n    margin: 0 -1px;\\n    text-indent: 0px;\\n    -ms-user-select: text;\\n    -moz-user-select: text;\\n    -webkit-user-select: text;\\n    user-select: text;\\n    white-space: pre!important;\\n}\\ntextarea:focus.zaplib_textarea {\\n    outline: 0px !important;\\n    -webkit-appearance: none;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./zaplib.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,kBAAkB,EAAE,gBAAgB;IACpC,MAAM;IACN,OAAO;IACP,uHAAuH;IACvH,mBAAmB;IACnB,WAAW;IACX,YAAY;IACZ,oBAAoB;IACpB,iBAAiB;IACjB,yBAAyB,EAAE,yCAAyC;AACxE;;AAEA;IACI,aAAa;IACb,kBAAkB;IAClB,UAAU;IACV,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,gBAAgB;IAChB,qBAAqB;IACrB,eAAe;IACf,WAAW;IACX,YAAY;IACZ,aAAa;IACb,gBAAgB;IAChB,gBAAgB;IAChB,cAAc;IACd,cAAc;IACd,gBAAgB;IAChB,qBAAqB;IACrB,sBAAsB;IACtB,yBAAyB;IACzB,iBAAiB;IACjB,0BAA0B;AAC9B;AACA;IACI,uBAAuB;IACvB,wBAAwB;AAC5B\",\"sourcesContent\":[\".zaplib_canvas {\\n    position: absolute; /* For z-index */\\n    top: 0;\\n    left: 0;\\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\\n    z-index: 2147483647;\\n    width: 100%;\\n    height: 100%;\\n    pointer-events: none;\\n    user-select: none;\\n    touch-action: pan-x pan-y; /* Mobile Safari doesn't support \\\"none\\\" */\\n}\\n\\ntextarea.zaplib_textarea {\\n    z-index: 1000;\\n    position: absolute;\\n    opacity: 0;\\n    border-radius: 4px;\\n    color:white;\\n    font-size: 6;\\n    background: gray;\\n    -moz-appearance: none;\\n    appearance:none;\\n    border:none;\\n    resize: none;\\n    outline: none;\\n    overflow: hidden;\\n    text-indent: 0px;\\n    padding: 0 0px;\\n    margin: 0 -1px;\\n    text-indent: 0px;\\n    -ms-user-select: text;\\n    -moz-user-select: text;\\n    -webkit-user-select: text;\\n    user-select: text;\\n    white-space: pre!important;\\n}\\ntextarea:focus.zaplib_textarea {\\n    outline: 0px !important;\\n    -webkit-appearance: none;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","\"use strict\";\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","\"use strict\";\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;","// This file should only be imported by WebWorkers\n/// <reference lib=\"WebWorker\" />\nimport { ZapParamType, } from \"./types\";\nimport { getCachedZapBuffer, getZapBufferWasm } from \"./zap_buffer\";\nimport { ZerdeBuilder } from \"./zerde\";\nconst RESPONSE = \"$$RESPONSE\";\nconst ERROR = \"$$ERROR\";\n// helper function to create linked channels for testing\nfunction _createLinkedChannels() {\n    const local = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (remote.onmessage) {\n                remote.onmessage(ev);\n            }\n        },\n    };\n    const remote = {\n        onmessage,\n        postMessage(data, _transfer) {\n            const ev = new MessageEvent(\"message\", { data });\n            if (local.onmessage) {\n                local.onmessage(ev);\n            }\n        },\n    };\n    return { local, remote };\n}\n// This class allows you to hook up bi-directional async calls across web-worker\n// boundaries where a single call to or from a worker can 'wait' on the response.\n// Errors in receivers are propigated back to the caller as a rejection.\n// It also supports returning transferrables over the web-worker postMessage api,\n// which was the main shortcomming with the worker-rpc npm module.\n// To attach rpc to an instance of a worker in the main thread:\n//   const rpc = new Rpc(workerInstace);\n// To attach rpc within an a web worker:\n//   const rpc = new Rpc(global);\n// Check out the tests for more examples.\n// See `rpc_types.ts` for descriptions of how to set up typed interactions.\nexport class Rpc {\n    constructor(channel) {\n        this._messageId = 0;\n        this._pendingCallbacks = {};\n        this._receivers = new Map();\n        this._onChannelMessage = (ev) => {\n            const { id, topic, data } = ev.data;\n            if (topic === RESPONSE) {\n                this._pendingCallbacks[id](ev.data);\n                delete this._pendingCallbacks[id];\n                return;\n            }\n            // invoke the receive handler in a promise so if it throws synchronously we can reject\n            new Promise((resolve) => {\n                const handler = this._receivers.get(topic);\n                if (!handler) {\n                    throw new Error(`no receiver registered for ${topic}`);\n                }\n                // This works both when `handler` returns a value or a Promise.\n                resolve(handler(data));\n            })\n                .then((result) => {\n                if (!result) {\n                    this.postMessage({ topic: RESPONSE, id }, []);\n                    return;\n                }\n                const transferrables = result[Rpc.transferrables];\n                delete result[Rpc.transferrables];\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: result,\n                };\n                this.postMessage(message, transferrables);\n            })\n                .catch((err) => {\n                const message = {\n                    topic: RESPONSE,\n                    id,\n                    data: {\n                        [ERROR]: true,\n                        name: err.name,\n                        message: err.message,\n                        stack: err.stack,\n                    },\n                };\n                this.postMessage(message, []);\n            });\n        };\n        this._channel = channel;\n        if (this._channel.onmessage) {\n            throw new Error(\"channel.onmessage is already set. Can only use one Rpc instance per channel.\");\n        }\n        this._channel.onmessage = this._onChannelMessage;\n    }\n    // send a message across the rpc boundary to a receiver on the other side\n    // this returns a promise for the receiver's response.  If there is no registered\n    // receiver for the given topic, this method throws\n    send(topic, data, transfer) {\n        const id = this._messageId++;\n        const message = { topic, id, data };\n        const result = new Promise((resolve, reject) => {\n            this._pendingCallbacks[id] = (info) => {\n                if (info.data && info.data[ERROR]) {\n                    const error = new Error(info.data.message);\n                    error.name = info.data.name;\n                    error.stack = info.data.stack;\n                    reject(error);\n                }\n                else {\n                    resolve(info.data);\n                }\n            };\n        });\n        this.postMessage(message, transfer);\n        return result;\n    }\n    // register a receiver for a given message on a topic\n    // only one receiver can be registered per topic and currently\n    // 'deregistering' a receiver is not supported since this is not common\n    receive(topic, handler) {\n        if (this._receivers.has(topic)) {\n            throw new Error(`Receiver already registered for topic: ${topic}`);\n        }\n        this._receivers.set(topic, handler);\n    }\n    postMessage(message, transfer) {\n        try {\n            this._channel.postMessage(message, transfer);\n        }\n        catch (e) {\n            console.error(\"Rpc postMessage call itself failed: \", e);\n        }\n    }\n}\nRpc.transferrables = \"$$TRANSFERRABLES\";\n////////////////////////////////////////////////////////////////\n// Mutex\n////////////////////////////////////////////////////////////////\nconst MUTEX_UNLOCKED = 0;\nconst MUTEX_LOCKED = 1;\nexport const mutexLock = (sabi32, offset) => {\n    // This needs to be in a loop, because between the `wait` and `compareExchange` another thread might\n    // take the Mutex.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (Atomics.compareExchange(sabi32, offset, MUTEX_UNLOCKED, MUTEX_LOCKED) ==\n            MUTEX_UNLOCKED) {\n            return;\n        }\n        Atomics.wait(sabi32, offset, MUTEX_LOCKED);\n    }\n};\nexport const mutexUnlock = (sabi32, offset) => {\n    if (Atomics.compareExchange(sabi32, offset, MUTEX_LOCKED, MUTEX_UNLOCKED) !=\n        MUTEX_LOCKED) {\n        throw new Error(\"Called mutex_unlock on an already unlocked mutex\");\n    }\n    Atomics.notify(sabi32, offset, 1);\n};\n////////////////////////////////////////////////////////////////\n// Task worker\n////////////////////////////////////////////////////////////////\nexport const TW_SAB_MUTEX_PTR = 0;\nexport const TW_SAB_MESSAGE_COUNT_PTR = 1;\n// Initialize a SharedArrayBuffer used to communicate with task_worker.ts. This\n// is a one-way communication channel; use pointers into `memory` for communicating\n// information back.\n//\n// We use this because we typically can't use `postMessage`; see task_worker.ts\n// for more details.\n//\n// Format:\n// * i32 (4 bytes)         - read/write mutex\n// * i32 (4 bytes)         - number of messages in queue (notify on this to wake up the task worker - it will\n//                           read this before taking a mutex, but then reread it after taking the mutex)\n// * n * u32 (n * 4 bytes) - pointers to messages serialized with `ZerdeBuilder`\nexport const initTaskWorkerSab = () => {\n    const bufferSizeBytes = 10000;\n    const taskWorkerSab = new SharedArrayBuffer(bufferSizeBytes);\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    taskWorkerSabi32[TW_SAB_MUTEX_PTR] = MUTEX_UNLOCKED;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = 0;\n    return taskWorkerSab;\n};\n// Append a new message pointer to the SharedArrayBuffer used by task_worker.ts,\n// and wake it up so it can process this new message (unless it's currently in polling\n// mode, in that case the `Atomics.notify` will just not do anything).\nconst sendTaskWorkerMessage = (taskWorkerSab, twMessagePtr) => {\n    const taskWorkerSabi32 = new Int32Array(taskWorkerSab);\n    mutexLock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    const currentNumberOfMessages = taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR];\n    // Use unsigned numbers for the actual pointer, since they can be >2GB.\n    new Uint32Array(taskWorkerSab)[currentNumberOfMessages + 2] = twMessagePtr;\n    taskWorkerSabi32[TW_SAB_MESSAGE_COUNT_PTR] = currentNumberOfMessages + 1;\n    mutexUnlock(taskWorkerSabi32, TW_SAB_MUTEX_PTR);\n    Atomics.notify(taskWorkerSabi32, 1);\n};\n////////////////////////////////////////////////////////////////\n// Wasm Thread initialization\n////////////////////////////////////////////////////////////////\n// Threads in WebAssembly! They are.. fun! Here's what happens.\n//\n// The first Wasm instance we start is in the main worker. It does the following:\n// - It initializes static memory using `__wasm_init_memory`, which is automatically set\n//   by LLVM as the special \"start\" function.\n// - It already has memory allocated for the \"shadow stack\". This is like any stack in a\n//   native program, but in WebAssembly it's called the \"shadow stack\" because WebAssembly\n//   itself also has a notion of a stack built-in. It is however not suitable for all\n//   kinds of data, which is why we need another separate stack.\n// - We allocate Thread Local Storage (TLS) by allocating some memory on the heap (an\n//   operation which by itself should not require TLS; otherwise we'd have a Catch-22\n//   situation..), and calling `initThreadLocalStorageMainWorker` with it.\n//\n// Then, when we make any other WebAssembly threads (e.g. in our own WebWorkers, or in\n// the WebWorkers of users), we do the following:\n// - `__wasm_init_memory` is again called automatically, but will be skipped, since an\n//   (atomic) flag has been set not to initialize static memory again.\n// - We need to initialize memory for both the shadow stack and the Thread Local\n//   Storage (TLS), using `makeThreadLocalStorageAndStackDataOnExistingThread`. We do this\n//   by allocating memory on the heap on an already initialized thread, since allocating memory DOES\n//   require the shadow stack to be initialized.\n// - We then use this memory for both the TLS (on the lower side) and the shadow stack\n//   (on the upper side, since it moves downward), using `initThreadLocalStorageAndStackOtherWorkers`.\n//\n// TODO(JP): This currently leaks memory since we never deallocate the TLS/shadow stack!\n//\n// TODO(JP): Even if we do deallocate the memory, there is currently no way to call TLS\n// destructors; so we'd still leak memory. See https://github.com/rust-lang/rust/issues/77839\n// The \"shadow stack\" size for new threads. Note that the main thread will\n// keep using its own shadow stack size.\nconst WASM_STACK_SIZE_BYTES = 2 * 1024 * 1024; // 2 MB\n// For the main worker, we only need to initialize Thread Local Storage (TLS).\nexport const initThreadLocalStorageMainWorker = (wasmExports) => {\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(wasmExports.__tls_size.value));\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    wasmExports.__wasm_init_tls(Number(ptr));\n};\n// For non-main workers, we need to allocate enough data for Thread Local Storage (TLS)\n// and the \"shadow stack\". We allocate this data in the main worker, and then send the\n// pointer + size to other workers.\n//\n// This is easier than trying to allocate the appropriate amount of data in the other\n// itself, which is possible (e.g. using memory.grow) but kind of cumbersome.\nexport const makeThreadLocalStorageAndStackDataOnExistingThread = (wasmExports) => {\n    // Align size to 64 bits / 8 bytes.\n    const size = Math.ceil((wasmExports.__tls_size.value + WASM_STACK_SIZE_BYTES) / 8) * 8;\n    // Note that allocWasmMessage always aligns to 64 bits / 8 bytes.\n    const ptr = wasmExports.allocWasmMessage(BigInt(size));\n    return { ptr, size };\n};\n// Set the shadow stack pointer and initialize thet Thread Local Storage (TLS).\n//\n// Note that the TLS sits on the lower side of the memory, wheras the shadow stack\n// starts on the upper side of the memory and grows downwards.\n//\n// TODO(JP): __wasm_init_tls takes a Number, which might not work when it is >2GB.\nexport const initThreadLocalStorageAndStackOtherWorkers = (wasmExports, tlsAndStackData) => {\n    // Start the shadow stack pointer on the upper side of the memory, though subtract\n    // 8 so we don't overwrite the byte right after the memory, while still keeping it\n    // 64-bit aligned. TODO(JP): Is the 64-bit alignment necessary for the shadow stack?\n    wasmExports.__stack_pointer.value =\n        Number(tlsAndStackData.ptr) + tlsAndStackData.size - 8;\n    wasmExports.__wasm_init_tls(\n    // TODO(JP): Cast to Number can cause trouble >2GB.\n    Number(tlsAndStackData.ptr));\n};\n////////////////////////////////////////////////////////////////\n// Common wasm functions\n////////////////////////////////////////////////////////////////\nexport const copyArrayToRustBuffer = (inputBuffer, outputBuffer, outputPtr) => {\n    // should be the same type as inputBuffer\n    // @ts-ignore: constructor is getting typed as Function instead of a constructor\n    new inputBuffer.constructor(outputBuffer, outputPtr, inputBuffer.length).set(inputBuffer);\n};\nexport const getZapParamType = (array, readonly) => {\n    if (array instanceof Uint8Array) {\n        return readonly ? ZapParamType.ReadOnlyU8Buffer : ZapParamType.U8Buffer;\n    }\n    else if (array instanceof Float32Array) {\n        return readonly ? ZapParamType.ReadOnlyF32Buffer : ZapParamType.F32Buffer;\n    }\n    else {\n        throw new Error(\"Invalid array type\");\n    }\n};\nexport const createWasmBuffer = (memory, exports, data) => {\n    const vecPtr = Number(exports.allocWasmVec(BigInt(data.byteLength)));\n    copyArrayToRustBuffer(data, memory.buffer, vecPtr);\n    return vecPtr;\n};\nexport const makeZerdeBuilder = (memory, wasmExports) => {\n    const slots = 1024;\n    // We have get memory.buffer *after* calling `allocWasmMessage`, because\n    // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n    const byteOffset = Number(wasmExports.allocWasmMessage(BigInt(slots * 4)));\n    return new ZerdeBuilder({\n        buffer: memory.buffer,\n        byteOffset: byteOffset,\n        slots,\n        growCallback: (_buffer, oldByteOffset, newBytes) => {\n            const newByteOffset = Number(wasmExports.reallocWasmMessage(BigInt(oldByteOffset), BigInt(newBytes)));\n            // We have get memory.buffer *after* calling `reallocWasmMessage`, because\n            // there's a good chance it'll get swapped out (if it needed to grow the buffer).\n            return { buffer: memory.buffer, byteOffset: newByteOffset };\n        },\n    });\n};\nexport const getWasmEnv = ({ getExports, memory, taskWorkerSab, fileHandles, sendEventFromAnyThread, threadSpawn, baseUri, }) => {\n    const fileReaderSync = new FileReaderSync();\n    const parseString = (ptr, len) => {\n        let out = \"\";\n        // Can't use TextDecoder here since it doesn't work with SharedArrayBuffer.\n        // TODO(JP): If it becomes important enough, we can see if making a copy to a regular\n        // ArrayBuffer and then using TextDecoder is faster than what we do here.\n        const array = new Uint32Array(memory.buffer, ptr, len);\n        for (let i = 0; i < len; i++) {\n            out += String.fromCharCode(array[i]);\n        }\n        return out;\n    };\n    return {\n        memory,\n        _consoleLog: (charsPtr, len, error) => {\n            const out = parseString(parseInt(charsPtr), parseInt(len));\n            if (error) {\n                console.error(out);\n            }\n            else {\n                console.log(out);\n            }\n        },\n        readUserFileRange: (userFileId, bufPtr, bufLen, fileOffset) => {\n            const file = fileHandles[userFileId];\n            const start = Number(fileOffset);\n            const end = start + Number(bufLen);\n            if (file.lastReadStart <= start && start < file.lastReadEnd) {\n                console.warn(`Read start (${start}) fell in the range of the last read (${file.lastReadStart}-${file.lastReadEnd}); ` +\n                    \"this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.\");\n            }\n            file.lastReadStart = start;\n            file.lastReadEnd = end;\n            // TODO(JP): This creates a new buffer instead of reading directly into the wasm memory.\n            // Maybe we can avoid this by using a stream with a ReadableStreamBYOBReader, but that is\n            // asynchronous, so we'd have to do a dance with another thread and atomics and all that,\n            // and I don't know if that overhead would be worth it..\n            const buffer = fileReaderSync.readAsArrayBuffer(file.file.slice(start, end));\n            copyArrayToRustBuffer(new Uint8Array(buffer), memory.buffer, Number(bufPtr));\n            return BigInt(buffer.byteLength);\n        },\n        performanceNow: () => {\n            return performance.now();\n        },\n        threadSpawn: (ctxPtr) => {\n            threadSpawn(ctxPtr);\n        },\n        _sendEventFromAnyThread: (eventPtr) => {\n            sendEventFromAnyThread(eventPtr);\n        },\n        readUrlSync: (urlPtr, urlLen, bufPtrOut, bufLenOut) => {\n            const url = parseString(urlPtr, urlLen);\n            const request = new XMLHttpRequest();\n            request.responseType = \"arraybuffer\";\n            request.open(\"GET\", new URL(url, baseUri).href, false /* synchronous */);\n            request.send(null);\n            if (request.status === 200) {\n                const exports = getExports();\n                const outputBufPtr = createWasmBuffer(memory, exports, new Uint8Array(request.response));\n                new Uint32Array(memory.buffer, bufPtrOut, 1)[0] = outputBufPtr;\n                new Uint32Array(memory.buffer, bufLenOut, 1)[0] =\n                    request.response.byteLength;\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        },\n        randomU64: () => new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],\n        sendTaskWorkerMessage: (twMessagePtr) => {\n            sendTaskWorkerMessage(taskWorkerSab, parseInt(twMessagePtr));\n        },\n    };\n};\nexport function transformParamsFromRustImpl(memory, destructor, mutableDestructor, params) {\n    return params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else {\n            const zapBuffer = getZapBufferWasm(memory, param, destructor, mutableDestructor);\n            if (param.paramType === ZapParamType.String) {\n                throw new Error(\"ZapParam buffer type called with string paramType\");\n            }\n            // These are actually ZapArray types, since we overwrite TypedArrays in overwriteTypedArraysWithZapArrays()\n            const ArrayConstructor = {\n                [ZapParamType.U8Buffer]: Uint8Array,\n                [ZapParamType.ReadOnlyU8Buffer]: Uint8Array,\n                [ZapParamType.F32Buffer]: Float32Array,\n                [ZapParamType.ReadOnlyF32Buffer]: Float32Array,\n            }[param.paramType];\n            return getCachedZapBuffer(zapBuffer, new ArrayConstructor(zapBuffer, param.bufferPtr, param.bufferLen / ArrayConstructor.BYTES_PER_ELEMENT));\n        }\n    });\n}\nexport function assertNotNull(value, objectName = \"Value\") {\n    if (value === null || value === undefined) {\n        throw new Error(`Assertion failed: ${objectName} is null`);\n    }\n    return value;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { jsRuntime } from \"./type_of_runtime\";\nimport { allocatedArcs, allocatedVecs } from \"./zap_buffer\";\nexport const expect = (actual, expected) => {\n    if (expected === actual) {\n        console.debug(`Success: Got ${actual}, Expected ${expected}`);\n    }\n    else {\n        throw new Error(`Failure: Got ${actual}, Expected ${expected}`);\n    }\n};\n// TODO(Paras): Would be nice to combine the two functions below at some point.\nexport const expectThrow = (f, expectedMessage) => {\n    let error;\n    try {\n        f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n};\nexport const expectThrowAsync = (f, expectedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n    let error;\n    try {\n        yield f();\n    }\n    catch (e) {\n        error = e;\n    }\n    expect(!!error, true);\n    if (error && expectedMessage) {\n        expect(error.message, expectedMessage);\n    }\n});\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst checkConditionTimeout = (condition, timeout) => __awaiter(void 0, void 0, void 0, function* () {\n    const startTime = performance.now();\n    while (!condition() && performance.now() < startTime + timeout) {\n        yield sleep(10);\n    }\n    return condition();\n});\n// Generate some dummy data and then delete it. This usually triggers the garbage collector.\nconst generateGarbage = () => {\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        self[\"garbage_\" + i] = { i };\n    }\n    for (let i = 0; i < 10000; i++) {\n        // @ts-ignore\n        delete self[\"garbage_\" + i];\n    }\n};\nconst arcAllocated = (callRust, buffer) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!buffer.__zaplibBufferData.readonly)\n        throw new Error(\"arcAllocated called on mutable buffer\");\n    const arcPtr = buffer.__zaplibBufferData.arcPtr;\n    // We still have the buffer here! So it should still be allocated.\n    expect(allocatedArcs[arcPtr], true);\n    const [result] = yield callRust(\"check_arc_count\", [`${BigInt(arcPtr)}`]);\n    const [countBeforeDeallocation] = result;\n    expect(countBeforeDeallocation, 1);\n    return arcPtr;\n});\nconst arcDeallocated = (arcPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // From here on out we don't refer to `buffer` anymore, so it should get\n    // deallocated, if the garbage collector is any good.\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return allocatedArcs[arcPtr] === false;\n    }, 20000), true);\n});\nconst vecDeallocated = (bufferPtr) => __awaiter(void 0, void 0, void 0, function* () {\n    // Even though we have the buffer, it might have already been unregistered\n    // when passed to Rust. We shouldn't read/write to it anymore. If this is the\n    // case, let's just bail.\n    if (!allocatedVecs[bufferPtr])\n        return;\n    expect(yield checkConditionTimeout(() => {\n        generateGarbage();\n        return allocatedVecs[bufferPtr] === false;\n    }, 20000), true);\n});\n// Test that ZapBuffers were deallocated at some point in the next 20 seconds.\n// This is a bit brittle given that there are no guarantees for garbage collection during this time,\n// but observationally this ends up being enough time. The caller must also ensure that the buffer will go out of scope\n// shortly after calling this.\n// We have to pass in `callRust` because we can call this function from a variety of runtimes.\n// Note that assertions on garbage collection are extremely sensitive to exactly how these functions are written,\n// and can easily break if you restucture the function, use a different/newer browser, etc!\nexport const expectDeallocationOrUnregister = (callRust, zapArray) => {\n    // Deallocation code is only run in WASM for now.\n    if (jsRuntime === \"cef\")\n        return Promise.resolve();\n    const buffer = zapArray.buffer;\n    return buffer.readonly\n        ? arcAllocated(callRust, buffer).then((arcPtr) => arcDeallocated(arcPtr))\n        : vecDeallocated(buffer.__zaplibBufferData.bufferPtr);\n};\nexport let inTest = false;\n// Set this to true to enable testing code\nexport const setInTest = (v) => {\n    inTest = v;\n};\n","// We only define `cefCallRust` if in CEF, so we can use this for environment detection.\n// This should only be used at the top level `zaplib_runtime` file or in test, since we want to keep\n// CEF and WASM code separate for bundle size.\nexport const jsRuntime = \"cefCallRust\" in self ? \"cef\" : \"wasm\";\n// Whether or not we're in a WebWorker.\n// From https://stackoverflow.com/a/23619712\nexport const inWorker = typeof importScripts === \"function\";\n","// Keep in sync with `param.rs`\nexport var ZapParamType;\n(function (ZapParamType) {\n    ZapParamType[ZapParamType[\"String\"] = 0] = \"String\";\n    ZapParamType[ZapParamType[\"ReadOnlyU8Buffer\"] = 1] = \"ReadOnlyU8Buffer\";\n    ZapParamType[ZapParamType[\"U8Buffer\"] = 2] = \"U8Buffer\";\n    ZapParamType[ZapParamType[\"F32Buffer\"] = 3] = \"F32Buffer\";\n    ZapParamType[ZapParamType[\"ReadOnlyF32Buffer\"] = 4] = \"ReadOnlyF32Buffer\";\n})(ZapParamType || (ZapParamType = {}));\n","// Wrapper around SharedArrayBuffer to encapsulate ownership of particular segments of it\nimport { getZapParamType } from \"./common\";\nimport { ZapParamType } from \"./types\";\nimport { inTest } from \"./test_helpers\";\n// TODO(Paras) - Make sure we monkeypatch on web workers as well\nexport class ZapBuffer extends SharedArrayBuffer {\n    constructor(buffer, bufferData) {\n        super(0);\n        this.__zaplibWasmBuffer = buffer;\n        this.__zaplibBufferData = bufferData;\n    }\n    // TODO(Paras): Actually enforce this flag and prevent mutation of ZapArrays marked as readonly.\n    // Potentially, we can do this by hashing read only buffer data and periodically checking in debug\n    // builds if they have been modified/raising errors.\n    get readonly() {\n        return this.__zaplibBufferData.readonly;\n    }\n    // The only 2 methods on SharedArrayBuffer class to override:\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#instance_properties\n    get byteLength() {\n        return this.__zaplibWasmBuffer.byteLength;\n    }\n    slice(...args) {\n        return this.__zaplibWasmBuffer.slice(...args);\n    }\n}\n// This class is a drop-in replacement for all typed arrays\n// It uses ZapBuffer as a handle for underlying buffer as the object that keeps underlying data around\n// Requirements:\n//  * The underlying typed array behaves like it was created over the original view\n//  * When the new typed array (potentially with different class name) is created from the buffer of the original one,\n//  they share the same handle\n//\n// The Rust side assumes that underlying data buffer is immutable,\n// however it still could be accidentally modified on JS side leading to weird behavior\n// TODO(Dmitry): Throw an error if there is mutation of the data\nfunction zapBufferExtends(cls) {\n    return class ZapTypedArray extends cls {\n        constructor(...args) {\n            const buffer = args[0];\n            if (typeof buffer === \"object\" && buffer instanceof ZapBuffer) {\n                // Fill in byteOffset if that's omitted.\n                if (args.length < 2) {\n                    args[1] = buffer.__zaplibBufferData.bufferPtr;\n                }\n                // Fill in length (in elements, not in bytes) if that's omitted.\n                if (args.length < 3) {\n                    args[2] = Math.floor((buffer.__zaplibBufferData.bufferPtr +\n                        buffer.__zaplibBufferData.bufferLen -\n                        args[1]) /\n                        cls.BYTES_PER_ELEMENT);\n                }\n                if (args[1] < buffer.__zaplibBufferData.bufferPtr) {\n                    throw new Error(`Byte_offset ${args[1]} is out of bounds`);\n                }\n                if (args[1] + args[2] * cls.BYTES_PER_ELEMENT >\n                    buffer.__zaplibBufferData.bufferPtr +\n                        buffer.__zaplibBufferData.bufferLen) {\n                    throw new Error(`Byte_offset ${args[1]} + length ${args[2]} is out of bounds`);\n                }\n                // Whenever we create ZapUintArray using ZapBuffer as first argument\n                // pass the underlying full wasm_buffer further\n                args[0] = buffer.__zaplibWasmBuffer;\n                super(...args);\n                this.__zaplibBuffer = buffer;\n            }\n            else {\n                super(...args);\n            }\n        }\n        get buffer() {\n            return this.__zaplibBuffer || super.buffer;\n        }\n        subarray(begin = 0, end = this.length) {\n            if (begin < 0) {\n                begin = this.length + begin;\n            }\n            if (end < 0) {\n                end = this.length + end;\n            }\n            if (end < begin) {\n                end = begin;\n            }\n            return new ZapTypedArray(this.buffer, this.byteOffset + begin * this.BYTES_PER_ELEMENT, end - begin);\n        }\n    };\n}\n// Extending all typed arrays\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#indexed_collections\nexport const classesToExtend = {\n    Int8Array: \"ZapInt8Array\",\n    Uint8Array: \"ZapUint8Array\",\n    Uint8ClampedArray: \"ZapUint8ClampedArray\",\n    Int16Array: \"ZapInt16Array\",\n    Uint16Array: \"ZapUint16Array\",\n    Uint16ClampedArray: \"ZapUint16ClampedArray\",\n    Int32Array: \"ZapInt32Array\",\n    Uint32Array: \"ZapUint32Array\",\n    Float32Array: \"ZapFloat32Array\",\n    Float64Array: \"ZapFloat64Array\",\n    BigInt64Array: \"ZapBigInt64Array\",\n    BigUint64Array: \"ZapBigUint64Array\",\n    DataView: \"ZapDataView\",\n};\nfor (const [cls, zapCls] of Object.entries(classesToExtend)) {\n    // Get a new type name by prefixing old one with \"Zaplib\".\n    // e.g. Uint8Array is extended by ZapUint8Array, etc\n    if (cls in self) {\n        // @ts-ignore\n        self[zapCls] = zapBufferExtends(self[cls]);\n    }\n}\n// Checks if the given object itself or recursively contains ZapBuffers.\n// Exported for tests.\nexport function containsZapBuffer(object) {\n    if (typeof object != \"object\" || object === null) {\n        return false;\n    }\n    if (Object.prototype.hasOwnProperty.call(object, \"__zaplibBuffer\")) {\n        return true;\n    }\n    // Only supporting nesting for arrays, plain objects, maps and sets similar to StructuredClone algorithm\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types\n    if (Array.isArray(object) || object instanceof Set || object instanceof Map) {\n        for (const entry of object) {\n            if (containsZapBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    else if (Object.getPrototypeOf(object) === Object.getPrototypeOf({})) {\n        for (const entry of Object.entries(object)) {\n            if (containsZapBuffer(entry)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction patchPostMessage(cls) {\n    const origPostMessage = cls.postMessage;\n    // Explicitly NOT a fat arrow (=>) since we want to keep the original `this`.\n    cls.postMessage = function (...args) {\n        if (containsZapBuffer(args[0])) {\n            // TODO(Dmitry): add a better error message showing the exact location of typed arrays\n            throw new Error(\"Sending ZapBuffers to/from workers is not supported - \" +\n                \"use .slice() on typed array instead to make an explicit copy\");\n        }\n        origPostMessage.apply(this, args);\n    };\n}\nexport function overwriteTypedArraysWithZapArrays() {\n    for (const [cls, zapCls] of Object.entries(classesToExtend)) {\n        if (cls in self) {\n            // @ts-ignore\n            self[cls] = self[zapCls];\n        }\n    }\n    patchPostMessage(self);\n    patchPostMessage(self.Worker);\n    patchPostMessage(self.MessagePort);\n}\nconst zapBufferCache = new WeakMap();\nexport function getCachedZapBuffer(zapBuffer, fallbackArray) {\n    var _a;\n    if (!(\n    // Overwrite the cached value if we return a pointer to a buffer of a different type\n    // For example, Rust code may cast a float to an u8 and return the same buffer pointer.\n    (((_a = zapBufferCache.get(zapBuffer)) === null || _a === void 0 ? void 0 : _a.BYTES_PER_ELEMENT) ===\n        fallbackArray.BYTES_PER_ELEMENT))) {\n        zapBufferCache.set(zapBuffer, fallbackArray);\n    }\n    return zapBufferCache.get(zapBuffer);\n}\nexport function isZapBuffer(potentialZapBuffer) {\n    return (typeof potentialZapBuffer === \"object\" &&\n        potentialZapBuffer instanceof ZapBuffer);\n}\nexport function checkValidZapArray(zapArray) {\n    if (!isZapBuffer(zapArray.buffer)) {\n        throw new Error(\"zapArray.buffer is not a ZapBuffer in checkValidZapArray\");\n    }\n    const buffer = zapArray.buffer;\n    const bufferCoversZapBuffer = zapArray.byteOffset === buffer.__zaplibBufferData.bufferPtr &&\n        zapArray.byteLength === buffer.__zaplibBufferData.bufferLen;\n    if (!bufferCoversZapBuffer) {\n        throw new Error(\"Called Rust with a buffer that does not span the entire underlying ZapBuffer\");\n    }\n    const paramType = getZapParamType(zapArray, buffer.readonly);\n    if (paramType !== buffer.__zaplibBufferData.paramType) {\n        throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${ZapParamType[buffer.__zaplibBufferData.paramType]} but got ${ZapParamType[paramType]}`);\n    }\n}\n// Cache ZapBuffers so that we have a stable identity for ZapBuffers pointing to the same\n// Arc. This is useful for any downstream caches in user code.\nconst bufferCache = {};\nexport const allocatedArcs = {};\nexport const allocatedVecs = {};\nconst bufferRegistry = new FinalizationRegistry(({ arcPtr, destructor, }) => {\n    if (inTest) {\n        if (allocatedArcs[arcPtr] === false) {\n            throw new Error(`Deallocating an already deallocated arcPtr ${arcPtr}`);\n        }\n        else if (allocatedArcs[arcPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated arcPtr ${arcPtr}`);\n        }\n        allocatedArcs[arcPtr] = false;\n    }\n    delete bufferCache[arcPtr];\n    if (destructor)\n        destructor(arcPtr);\n});\nconst mutableZapBufferRegistry = new FinalizationRegistry(({ bufferData, destructor, }) => {\n    if (inTest) {\n        const { bufferPtr } = bufferData;\n        if (allocatedVecs[bufferPtr] === false) {\n            throw new Error(`Deallocating an already deallocated bufferPtr ${bufferPtr}`);\n        }\n        else if (allocatedVecs[bufferPtr] === undefined) {\n            throw new Error(`Deallocating an unallocated bufferPtr ${bufferPtr}`);\n        }\n        allocatedVecs[bufferPtr] = false;\n    }\n    destructor(bufferData);\n});\n// Return a buffer with a stable identity based on arcPtr.\n// Register callbacks so we de-allocate the buffer when it goes out of scope.\nexport const getZapBufferWasm = (wasmMemory, bufferData, destructor, mutableDestructor) => {\n    var _a;\n    if (bufferData.readonly) {\n        if (!((_a = bufferCache[bufferData.arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            if (inTest) {\n                allocatedArcs[bufferData.arcPtr] = true;\n            }\n            const zapBuffer = new ZapBuffer(wasmMemory.buffer, bufferData);\n            bufferRegistry.register(zapBuffer, {\n                arcPtr: bufferData.arcPtr,\n                destructor,\n                /* no unregisterToken here since we never need to unregister */\n            });\n            bufferCache[bufferData.arcPtr] = new WeakRef(zapBuffer);\n        }\n        else {\n            // If we already hold a reference, decrement the Arc we were just given;\n            // otherwise we leak memory.\n            destructor(bufferData.arcPtr);\n        }\n        return bufferCache[bufferData.arcPtr].deref();\n    }\n    else {\n        if (inTest) {\n            allocatedVecs[bufferData.bufferPtr] = true;\n        }\n        const zapBuffer = new ZapBuffer(wasmMemory.buffer, bufferData);\n        mutableZapBufferRegistry.register(zapBuffer, {\n            bufferData,\n            destructor: mutableDestructor,\n        }, zapBuffer);\n        return zapBuffer;\n    }\n};\n// Remove mutable ZapBuffers without running destructors. This is useful\n// when transferring ownership of buffers to Rust without deallocating data.\nexport const unregisterMutableBuffer = (zapBuffer) => {\n    if (zapBuffer.readonly) {\n        throw new Error(\"`unregisterMutableBuffer` should only be called on mutable ZapBuffers\");\n    }\n    mutableZapBufferRegistry.unregister(zapBuffer);\n    if (inTest) {\n        allocatedVecs[zapBuffer.__zaplibBufferData.bufferPtr] = false;\n    }\n};\n// Return a buffer with a stable identity based on arcPtr\nexport const getZapBufferCef = (buffer, arcPtr, paramType) => {\n    var _a;\n    if (arcPtr) {\n        if (!((_a = bufferCache[arcPtr]) === null || _a === void 0 ? void 0 : _a.deref())) {\n            const zapBuffer = new ZapBuffer(buffer, {\n                bufferPtr: 0,\n                bufferLen: buffer.byteLength,\n                readonly: true,\n                paramType,\n                // TODO(Paras): These fields below do not apply to CEF\n                arcPtr: -1,\n            });\n            bufferRegistry.register(zapBuffer, { arcPtr });\n            bufferCache[arcPtr] = new WeakRef(zapBuffer);\n        }\n        return bufferCache[arcPtr].deref();\n    }\n    else {\n        return new ZapBuffer(buffer, {\n            bufferPtr: 0,\n            bufferLen: buffer.byteLength,\n            bufferCap: buffer.byteLength,\n            paramType,\n            readonly: false,\n        });\n    }\n};\n","// Zerde is our lightweight manual serialization/deserialization system.\n//\n// Keep in sync with zerde.rs, and see there for more information.\nimport { ZapParamType } from \"./types\";\n// Construct a buffer that can be read in Rust, using the corresponding `ZerderParser` struct in Rust.\nexport class ZerdeBuilder {\n    constructor({ buffer, byteOffset, slots, growCallback, }) {\n        this._buffer = buffer;\n        this._byteOffset = byteOffset;\n        this._slots = slots;\n        this._growCallback = growCallback;\n        this._used = 2; // Skip 8 byte header which contains the size.\n        this._updateRefs();\n    }\n    _updateRefs() {\n        this._f32 = new Float32Array(this._buffer, this._byteOffset, this._slots);\n        this._u32 = new Uint32Array(this._buffer, this._byteOffset, this._slots);\n        this._f64 = new Float64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64 = new BigUint64Array(this._buffer, this._byteOffset, this._slots >> 1);\n        this._u64[0] = BigInt(this._slots) * BigInt(4); // Write size to header.\n    }\n    _fit(slots) {\n        if (this._used + slots > this._slots) {\n            let newSlots = Math.max(this._used + slots, this._slots * 2); // Exponential growth\n            if (newSlots & 1)\n                newSlots++; // 64-bit align it\n            const newBytes = newSlots * 4;\n            const { buffer, byteOffset } = this._growCallback(this._buffer, this._byteOffset, newBytes);\n            this._buffer = buffer;\n            this._byteOffset = byteOffset;\n            this._slots = newSlots;\n            this._updateRefs();\n        }\n        const pos = this._used;\n        this._used += slots;\n        return pos;\n    }\n    sendF32(value) {\n        const pos = this._fit(1);\n        this._f32[pos] = value;\n    }\n    sendU32(value) {\n        const pos = this._fit(1);\n        this._u32[pos] = value;\n    }\n    sendF64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._f64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._f64[pos >> 1] = value;\n        }\n    }\n    sendU64(value) {\n        if (this._used & 1) {\n            // 64-bit alignment.\n            const pos = this._fit(3) + 1;\n            this._u64[pos >> 1] = value;\n        }\n        else {\n            const pos = this._fit(2);\n            this._u64[pos >> 1] = value;\n        }\n    }\n    sendString(str) {\n        let pos = this._fit(str.length + 1);\n        this._u32[pos++] = str.length;\n        for (let i = 0; i < str.length; i++) {\n            this._u32[pos++] = str.charCodeAt(i);\n        }\n    }\n    getData() {\n        return { buffer: this._buffer, byteOffset: this._byteOffset };\n    }\n}\nexport class ZerdeParser {\n    constructor(memory, zerdePtr) {\n        this._memory = memory;\n        // set up local shortcuts to the zerde memory chunk for faster parsing\n        this._usedSlots = 2; // skip the 8 byte header\n        this._f32 = new Float32Array(this._memory.buffer, zerdePtr);\n        this._u32 = new Uint32Array(this._memory.buffer, zerdePtr);\n        this._f64 = new Float64Array(this._memory.buffer, zerdePtr);\n        this._u64 = new BigUint64Array(this._memory.buffer, zerdePtr);\n    }\n    parseU32() {\n        return this._u32[this._usedSlots++];\n    }\n    parseF32() {\n        return this._f32[this._usedSlots++];\n    }\n    parseF64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._f64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseU64() {\n        if (this._usedSlots & 1) {\n            // 64-bit alignment.\n            this._usedSlots++;\n        }\n        const ret = this._u64[this._usedSlots >> 1];\n        this._usedSlots += 2;\n        return ret;\n    }\n    parseString() {\n        let str = \"\";\n        const len = this.parseU32();\n        for (let i = 0; i < len; i++) {\n            const c = this.parseU32();\n            if (c != 0)\n                str += String.fromCharCode(c);\n        }\n        return str;\n    }\n    parseU8Slice() {\n        const u8Len = this.parseU32();\n        const len = u8Len >> 2;\n        const data = new Uint8Array(u8Len);\n        const spare = u8Len & 3;\n        for (let i = 0; i < len; i++) {\n            const u8Pos = i << 2;\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n            data[u8Pos + 3] = (u32 >> 24) & 0xff;\n        }\n        const u8Pos = len << 2;\n        if (spare == 1) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n        }\n        else if (spare == 2) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n        }\n        else if (spare == 3) {\n            const u32 = this.parseU32();\n            data[u8Pos + 0] = u32 & 0xff;\n            data[u8Pos + 1] = (u32 >> 8) & 0xff;\n            data[u8Pos + 2] = (u32 >> 16) & 0xff;\n        }\n        return data;\n    }\n    parseZapParams() {\n        const len = this.parseU32();\n        const params = [];\n        for (let i = 0; i < len; ++i) {\n            const paramType = this.parseU32();\n            if (paramType === ZapParamType.String) {\n                params.push(this.parseString());\n            }\n            else if (paramType === ZapParamType.ReadOnlyU8Buffer ||\n                paramType === ZapParamType.ReadOnlyF32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const arcPtr = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    arcPtr,\n                    readonly: true,\n                });\n            }\n            else if (paramType === ZapParamType.U8Buffer ||\n                paramType === ZapParamType.F32Buffer) {\n                const bufferPtr = this.parseU32();\n                const bufferLen = this.parseU32();\n                const bufferCap = this.parseU32();\n                params.push({\n                    paramType,\n                    bufferPtr,\n                    bufferLen,\n                    bufferCap,\n                    readonly: false,\n                });\n            }\n            else {\n                throw new Error(`Unknown ZapParam type: ${paramType}`);\n            }\n        }\n        return params;\n    }\n}\n","\"use strict\";\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";const e=[\\\"none\\\",\\\"default\\\",\\\"crosshair\\\",\\\"pointer\\\",\\\"default\\\",\\\"move\\\",\\\"text\\\",\\\"wait\\\",\\\"help\\\",\\\"not-allowed\\\",\\\"n-resize\\\",\\\"ne-resize\\\",\\\"e-resize\\\",\\\"se-resize\\\",\\\"s-resize\\\",\\\"sw-resize\\\",\\\"w-resize\\\",\\\"nw-resize\\\",\\\"ns-resize\\\",\\\"nesw-resize\\\",\\\"ew-resize\\\",\\\"nwse-resize\\\",\\\"col-resize\\\",\\\"row-resize\\\"];var t,r;(r=t||(t={}))[r.String=0]=\\\"String\\\",r[r.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",r[r.U8Buffer=2]=\\\"U8Buffer\\\",r[r.F32Buffer=3]=\\\"F32Buffer\\\",r[r.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\",self;class s extends SharedArrayBuffer{constructor(e,t){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=t}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class t extends e{constructor(...t){const r=t[0];if(\\\"object\\\"==typeof r&&r instanceof s){if(t.length<2&&(t[1]=r.__zaplibBufferData.bufferPtr),t.length<3&&(t[2]=Math.floor((r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen-t[1])/e.BYTES_PER_ELEMENT)),t[1]<r.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${t[1]} is out of bounds`);if(t[1]+t[2]*e.BYTES_PER_ELEMENT>r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${t[1]} + length ${t[2]} is out of bounds`);t[0]=r.__zaplibWasmBuffer,super(...t),this.__zaplibBuffer=r}else super(...t)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,r=this.length){return e<0&&(e=this.length+e),r<0&&(r=this.length+r),r<e&&(r=e),new t(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,r-e)}}}const i={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,t]of Object.entries(i))e in self&&(self[t]=n(self[e]));new WeakMap;const a={};new FinalizationRegistry((({arcPtr:e,destructor:t})=>{delete a[e],t&&t(e)})),new FinalizationRegistry((({bufferData:e,destructor:t})=>{t(e)}));class o{constructor({buffer:e,byteOffset:t,slots:r,growCallback:s}){this._buffer=e,this._byteOffset=t,this._slots=r,this._growCallback=s,this._used=2,this._updateRefs()}_updateRefs(){this._f32=new Float32Array(this._buffer,this._byteOffset,this._slots),this._u32=new Uint32Array(this._buffer,this._byteOffset,this._slots),this._f64=new Float64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64=new BigUint64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64[0]=BigInt(this._slots)*BigInt(4)}_fit(e){if(this._used+e>this._slots){let t=Math.max(this._used+e,2*this._slots);1&t&&t++;const r=4*t,{buffer:s,byteOffset:n}=this._growCallback(this._buffer,this._byteOffset,r);this._buffer=s,this._byteOffset=n,this._slots=t,this._updateRefs()}const t=this._used;return this._used+=e,t}sendF32(e){const t=this._fit(1);this._f32[t]=e}sendU32(e){const t=this._fit(1);this._u32[t]=e}sendF64(e){if(1&this._used){const t=this._fit(3)+1;this._f64[t>>1]=e}else{const t=this._fit(2);this._f64[t>>1]=e}}sendU64(e){if(1&this._used){const t=this._fit(3)+1;this._u64[t>>1]=e}else{const t=this._fit(2);this._u64[t>>1]=e}}sendString(e){let t=this._fit(e.length+1);this._u32[t++]=e.length;for(let r=0;r<e.length;r++)this._u32[t++]=e.charCodeAt(r)}getData(){return{buffer:this._buffer,byteOffset:this._byteOffset}}}class d{constructor(e,t){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,t),this._u32=new Uint32Array(this._memory.buffer,t),this._f64=new Float64Array(this._memory.buffer,t),this._u64=new BigUint64Array(this._memory.buffer,t)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e=\\\"\\\";const t=this.parseU32();for(let r=0;r<t;r++){const t=this.parseU32();0!=t&&(e+=String.fromCharCode(t))}return e}parseU8Slice(){const e=this.parseU32(),t=e>>2,r=new Uint8Array(e),s=3&e;for(let e=0;e<t;e++){const t=e<<2,s=this.parseU32();r[t+0]=255&s,r[t+1]=s>>8&255,r[t+2]=s>>16&255,r[t+3]=s>>24&255}const n=t<<2;if(1==s){const e=this.parseU32();r[n+0]=255&e}else if(2==s){const e=this.parseU32();r[n+0]=255&e,r[n+1]=e>>8&255}else if(3==s){const e=this.parseU32();r[n+0]=255&e,r[n+1]=e>>8&255,r[n+2]=e>>16&255}return r}parseZapParams(){const e=this.parseU32(),r=[];for(let s=0;s<e;++s){const e=this.parseU32();if(e===t.String)r.push(this.parseString());else if(e===t.ReadOnlyU8Buffer||e===t.ReadOnlyF32Buffer){const t=this.parseU32(),s=this.parseU32(),n=this.parseU32();r.push({paramType:e,bufferPtr:t,bufferLen:s,arcPtr:n,readonly:!0})}else{if(e!==t.U8Buffer&&e!==t.F32Buffer)throw new Error(`Unknown ZapParam type: ${e}`);{const t=this.parseU32(),s=this.parseU32(),n=this.parseU32();r.push({paramType:e,bufferPtr:t,bufferLen:s,bufferCap:n,readonly:!1})}}}return r}}const l=\\\"$$RESPONSE\\\",h=\\\"$$ERROR\\\";class c{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:t,topic:r,data:s}=e.data;if(r===l)return this._pendingCallbacks[t](e.data),void delete this._pendingCallbacks[t];new Promise((e=>{const t=this._receivers.get(r);if(!t)throw new Error(`no receiver registered for ${r}`);e(t(s))})).then((e=>{if(!e)return void this.postMessage({topic:l,id:t},[]);const r=e[c.transferrables];delete e[c.transferrables];const s={topic:l,id:t,data:e};this.postMessage(s,r)})).catch((e=>{const r={topic:l,id:t,data:{[h]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(r,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,t,r){const s=this._messageId++,n={topic:e,id:s,data:t},i=new Promise(((e,t)=>{this._pendingCallbacks[s]=r=>{if(r.data&&r.data[h]){const e=new Error(r.data.message);e.name=r.data.name,e.stack=r.data.stack,t(e)}else e(r.data)}}));return this.postMessage(n,r),i}receive(e,t){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,t)}postMessage(e,t){try{this._channel.postMessage(e,t)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}c.transferrables=\\\"$$TRANSFERRABLES\\\";const u=e=>{const t=8*Math.ceil((e.__tls_size.value+2097152)/8);return{ptr:e.allocWasmMessage(BigInt(t)),size:t}},f=(e,t,r)=>{new e.constructor(t,r,e.length).set(e)},p=(e,r)=>{if(e instanceof Uint8Array)return r?t.ReadOnlyU8Buffer:t.U8Buffer;if(e instanceof Float32Array)return r?t.ReadOnlyF32Buffer:t.F32Buffer;throw new Error(\\\"Invalid array type\\\")},g=(e,t,r)=>{const s=Number(t.allocWasmVec(BigInt(r.byteLength)));return f(r,e.buffer,s),s};function m(e,t=\\\"Value\\\"){if(null==e)throw new Error(`Assertion failed: ${t} is null`);return e}function _(e){return(e.shiftKey?1:0)|(e.ctrlKey?2:0)|(e.altKey?4:0)|(e.metaKey?8:0)}const E={keyDown(e,t){e.sendU32(12),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(_(t.event)),e.sendF64(performance.now()/1e3)},keyUp(e,t){e.sendU32(13),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(_(t.event)),e.sendF64(performance.now()/1e3)},textInput(e,t){e.sendU32(14),e.sendU32(t.wasPaste?1:0),e.sendU32(t.replaceLast?1:0),e.sendString(t.input)},textCopy(e){e.sendU32(17)}};class b{constructor(e){this._wasmApp=e,this._zerdeBuilder=((e,t)=>{const r=Number(t.allocWasmMessage(BigInt(4096)));return new o({buffer:e.buffer,byteOffset:r,slots:1024,growCallback:(r,s,n)=>{const i=Number(t.reallocWasmMessage(BigInt(s),BigInt(n)));return{buffer:e.buffer,byteOffset:i}}})})(e.memory,e.exports),this._zerdeBuilder.sendF64(0)}getWasmApp(){return this._wasmApp}createWasmBuffer(e){return g(this._wasmApp.memory,this._wasmApp.exports,e)}createArcVec(e,t){return Number(this._wasmApp.exports.createArcVec(BigInt(e),BigInt(t.length),BigInt(p(t,!0))))}init(e){this._zerdeBuilder.sendU32(1),this._zerdeBuilder.sendF32(e.width),this._zerdeBuilder.sendF32(e.height),this._zerdeBuilder.sendF32(e.dpiFactor),this._zerdeBuilder.sendU32(e.xrCanPresent?1:0),this._zerdeBuilder.sendU32(e.canFullscreen?1:0)}resize(e){this._zerdeBuilder.sendU32(4),this._zerdeBuilder.sendF32(e.width),this._zerdeBuilder.sendF32(e.height),this._zerdeBuilder.sendF32(e.dpiFactor),this._zerdeBuilder.sendU32(e.xrIsPresenting?1:0),this._zerdeBuilder.sendU32(e.xrCanPresent?1:0),this._zerdeBuilder.sendU32(e.isFullscreen?1:0)}animationFrame(){this._zerdeBuilder.sendU32(5)}pointerDown(e){this._zerdeBuilder.sendU32(6),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.button),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerUp(e){this._zerdeBuilder.sendU32(7),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.button),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerMove(e){this._zerdeBuilder.sendU32(8),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerHover(e){this._zerdeBuilder.sendU32(9),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerScroll(e){this._zerdeBuilder.sendU32(10),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendF32(e.scrollX),this._zerdeBuilder.sendF32(e.scrollY),this._zerdeBuilder.sendU32(e.isWheel?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerOut(e){this._zerdeBuilder.sendU32(11),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}keyDown(e){E.keyDown(this._zerdeBuilder,e)}keyUp(e){E.keyUp(this._zerdeBuilder,e)}textInput(e){E.textInput(this._zerdeBuilder,e)}textCopy(){E.textCopy(this._zerdeBuilder)}timerFired(e){this._zerdeBuilder.sendU32(18),this._zerdeBuilder.sendF64(e)}windowFocus(e){this._zerdeBuilder.sendU32(19),this._zerdeBuilder.sendU32(e?1:0)}xrUpdateHead(e,t){}xrUpdateInputs(e,t,r,s,n){}paintDirty(e,t){this._zerdeBuilder.sendU32(21)}httpSendResponse(e,t){this._zerdeBuilder.sendU32(22),this._zerdeBuilder.sendU32(e),this._zerdeBuilder.sendU32(t)}sendEventFromAnyThread(e){this._zerdeBuilder.sendU32(26),this._zerdeBuilder.sendU64(e)}websocketMessage(e,t){const r=t.byteLength,s=this.createWasmBuffer(new Uint8Array(t));this._zerdeBuilder.sendU32(23),this._zerdeBuilder.sendU32(s),this._zerdeBuilder.sendU32(r),this._zerdeBuilder.sendString(e)}websocketError(e,t){this._zerdeBuilder.sendU32(24),this._zerdeBuilder.sendString(e),this._zerdeBuilder.sendString(t)}appOpenFiles(e){this._zerdeBuilder.sendU32(25),this._zerdeBuilder.sendU32(e.length);for(const t of e)this._zerdeBuilder.sendU32(t.id),this._zerdeBuilder.sendU64(BigInt(t.file.size)),this._zerdeBuilder.sendString(t.basename)}dragenter(){this._zerdeBuilder.sendU32(27)}dragleave(){this._zerdeBuilder.sendU32(28)}dragover(e,t){this._zerdeBuilder.sendU32(29),this._zerdeBuilder.sendU32(e),this._zerdeBuilder.sendU32(t)}callRust(e,r,s){this._zerdeBuilder.sendU32(30),this._zerdeBuilder.sendString(e),this._zerdeBuilder.sendU32(r.length);for(const e of r)if(\\\"string\\\"==typeof e)this._zerdeBuilder.sendU32(t.String),this._zerdeBuilder.sendString(e);else if(\\\"bufferData\\\"in e)this._zerdeBuilder.sendU32(e.bufferData.paramType),e.bufferData.readonly?this._zerdeBuilder.sendU32(e.bufferData.arcPtr):(this._zerdeBuilder.sendU32(e.bufferData.bufferPtr),this._zerdeBuilder.sendU32(e.bufferData.bufferLen),this._zerdeBuilder.sendU32(e.bufferData.bufferCap));else{const t=e.byteLength,r=this.createWasmBuffer(e);this._zerdeBuilder.sendU32(p(e,!1)),this._zerdeBuilder.sendU32(r),this._zerdeBuilder.sendU32(t),this._zerdeBuilder.sendU32(t)}this._zerdeBuilder.sendU32(s)}end(){this._zerdeBuilder.sendU32(0);const{buffer:e,byteOffset:t}=this._zerdeBuilder.getData();return new Float64Array(e,t,2)[1]=performance.now()/1e3,t}}class v{constructor(e,t,r,s){this.uniformFnTable={float:function(e,t,r){const s=r>>2;e.gl.uniform1f(t,e.basef32[s])},vec2:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform2f(t,n[s],n[s+1])},vec3:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform3f(t,n[s],n[s+1],n[s+2])},vec4:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform4f(t,n[s],n[s+1],n[s+2],n[s+3])},mat2:function(e,t,r){e.gl.uniformMatrix2fv(t,!1,new Float32Array(e.memory.buffer,r,4))},mat3:function(e,t,r){e.gl.uniformMatrix3fv(t,!1,new Float32Array(e.memory.buffer,r,9))},mat4:function(e,t,r){const s=new Float32Array(e.memory.buffer,r,16);e.gl.uniformMatrix4fv(t,!1,s)}},this.sendFnTable=[function(e){return!0},function(e){function t(){const t=e.zerdeParser.parseU32(),r=[];for(let s=0;s<t;s++)r.push({ty:e.zerdeParser.parseString(),name:e.zerdeParser.parseString()});return r}const r={shaderId:e.zerdeParser.parseU32(),fragment:e.zerdeParser.parseString(),vertex:e.zerdeParser.parseString(),geometrySlots:e.zerdeParser.parseU32(),instanceSlots:e.zerdeParser.parseU32(),passUniforms:t(),viewUniforms:t(),drawUniforms:t(),userUniforms:t(),textureSlots:t()};e.compileWebGLShader(r)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=new Float32Array(e.memory.buffer,s,r);e.allocArrayBuffer(t,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=new Uint32Array(e.memory.buffer,s,r);e.allocIndexBuffer(t,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),i=e.zerdeParser.parseU32();e.allocVao(t,r,s,n,i)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),i=e.zerdeParser.parseU32(),a=e.zerdeParser.parseU32(),o=e.zerdeParser.parseU32();e.drawCall(t,r,s,n,i,a,o)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32();e.allocTexture(t,r,s,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32();e.beginRenderTargets(t,r,s)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseF32(),n=e.zerdeParser.parseF32(),i=e.zerdeParser.parseF32(),a=e.zerdeParser.parseF32();e.addColorTarget(t,r,s,n,i,a)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseF32();e.setDepthTarget(t,r,s)},function(e){e.endRenderTargets()},function(e){e.setDefaultDepthAndBlendMode()},function(e){const t=e.zerdeParser.parseF32(),r=e.zerdeParser.parseF32(),s=e.zerdeParser.parseF32(),n=e.zerdeParser.parseF32(),i=e.zerdeParser.parseF32();e.beginMainCanvas(t,r,s,n,i)}],this.canvas=e,this.memory=t,this.sizingData=r,this.shaders=[],this.indexBuffers=[],this.arrayBuffers=[],this.vaos=[],this.textures=[],this.framebuffers=[],this.targetWidth=0,this.targetHeight=0,this.clearFlags=0,this.clearR=0,this.clearG=0,this.clearB=0,this.clearA=0,this.clearDepth=0;const n={preferLowPowerToHighPerformance:!0};this.gl=e.getContext(\\\"webgl\\\",n)||e.getContext(\\\"webgl-experimental\\\",n)||e.getContext(\\\"experimental-webgl\\\",n),this.gl?(this.OESVertexArrayObject=m(this.gl.getExtension(\\\"OES_vertex_array_object\\\")),this.ANGLEInstancedArrays=m(this.gl.getExtension(\\\"ANGLE_instanced_arrays\\\")),this.gl.getExtension(\\\"OES_standard_derivatives\\\"),this.gl.getExtension(\\\"OES_element_index_uint\\\"),this.resize(r)):s()}processMessages(e){for(this.zerdeParser=new d(this.memory,e),this.basef32=new Float32Array(this.memory.buffer),this.baseu32=new Uint32Array(this.memory.buffer);;){const e=this.zerdeParser.parseU32();if(this.sendFnTable[e](this))break}}resize(e){this.sizingData=e,this.canvas.width=e.width*e.dpiFactor,this.canvas.height=e.height*e.dpiFactor}getAttribLocations(e,t,r){const s=this.gl,n=[];let i=r>>2;0!=(3&r)&&i++;for(let a=0;a<i;a++){let i=r-4*a;i>4&&(i=4),n.push({loc:s.getAttribLocation(e,t+a),offset:16*a,size:i,stride:4*r})}return n}getUniformLocations(e,t){const r=this.gl,s=[];let n=0;for(let i=0;i<t.length;i++){const a=t[i],o=z[a.ty];0!=(3&n)&&(3&n)+o>4&&(n+=4-(3&n)),s.push({name:a.name,offset:n<<2,ty:a.ty,loc:r.getUniformLocation(e,a.name),fn:this.uniformFnTable[a.ty]}),n+=o}return s}compileWebGLShader(e){const t=this.gl,r=m(t.createShader(t.VERTEX_SHADER));t.shaderSource(r,e.vertex),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(r),U(e.vertex));const s=m(t.createShader(t.FRAGMENT_SHADER));t.shaderSource(s,e.fragment),t.compileShader(s),t.getShaderParameter(s,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(s),U(e.fragment));const n=m(t.createProgram());t.attachShader(n,r),t.attachShader(n,s),t.linkProgram(n),t.getProgramParameter(n,t.LINK_STATUS)||console.log(t.getProgramInfoLog(n),U(e.vertex),U(e.fragment)),this.shaders[e.shaderId]={geomAttribs:this.getAttribLocations(n,\\\"mpsc_packed_geometry_\\\",e.geometrySlots),instAttribs:this.getAttribLocations(n,\\\"mpsc_packed_instance_\\\",e.instanceSlots),passUniforms:this.getUniformLocations(n,e.passUniforms),viewUniforms:this.getUniformLocations(n,e.viewUniforms),drawUniforms:this.getUniformLocations(n,e.drawUniforms),userUniforms:this.getUniformLocations(n,e.userUniforms),textureSlots:this.getUniformLocations(n,e.textureSlots),instanceSlots:e.instanceSlots,program:n,ash:e}}allocArrayBuffer(e,t){const r=this.gl;let s=this.arrayBuffers[e];void 0===s?s=this.arrayBuffers[e]={glBuf:m(r.createBuffer()),length:t.length}:s.length=t.length,r.bindBuffer(r.ARRAY_BUFFER,s.glBuf),r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,null)}allocIndexBuffer(e,t){const r=this.gl;let s=this.indexBuffers[e];void 0===s?s=this.indexBuffers[e]={glBuf:m(r.createBuffer()),length:t.length}:s.length=t.length,r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,s.glBuf),r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null)}allocVao(e,t,r,s,n){const i=this.gl,a=this.vaos[e];a&&this.OESVertexArrayObject.deleteVertexArrayOES(a.glVao);const o=m(this.OESVertexArrayObject.createVertexArrayOES()),d=this.vaos[e]={glVao:o,geomIbId:r,geomVbId:s,instVbId:n};this.OESVertexArrayObject.bindVertexArrayOES(d.glVao),i.bindBuffer(i.ARRAY_BUFFER,this.arrayBuffers[s].glBuf);const l=this.shaders[t];for(let e=0;e<l.geomAttribs.length;e++){const t=l.geomAttribs[e];t.loc<0||(i.vertexAttribPointer(t.loc,t.size,i.FLOAT,!1,t.stride,t.offset),i.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,0))}i.bindBuffer(i.ARRAY_BUFFER,this.arrayBuffers[n].glBuf);for(let e=0;e<l.instAttribs.length;e++){const t=l.instAttribs[e];t.loc<0||(i.vertexAttribPointer(t.loc,t.size,i.FLOAT,!1,t.stride,t.offset),i.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,1))}i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,this.indexBuffers[r].glBuf),this.OESVertexArrayObject.bindVertexArrayOES(null)}drawCall(e,t,r,s,n,i,a){const o=this.gl,d=this.shaders[e];o.useProgram(d.program);const l=this.vaos[t];this.OESVertexArrayObject.bindVertexArrayOES(l.glVao);const h=this.indexBuffers[l.geomIbId],c=this.arrayBuffers[l.instVbId],u=d.passUniforms,f=d.viewUniforms;for(let e=0;e<f.length;e++){const t=f[e];t.fn(this,t.loc,t.offset+s)}const p=d.drawUniforms;for(let e=0;e<p.length;e++){const t=p[e];t.fn(this,t.loc,t.offset+n)}const g=d.userUniforms;for(let e=0;e<g.length;e++){const t=g[e];t.fn(this,t.loc,t.offset+i)}const m=d.textureSlots;for(let e=0;e<m.length;e++){const t=m[e],r=this.baseu32[(a>>2)+e],s=this.textures[r];o.activeTexture(o.TEXTURE0+e),o.bindTexture(o.TEXTURE_2D,s),o.uniform1i(t.loc,e)}const _=h.length,E=c.length/d.instanceSlots;for(let e=0;e<u.length;e++){const t=u[e];t.fn(this,t.loc,t.offset+r)}this.ANGLEInstancedArrays.drawElementsInstancedANGLE(o.TRIANGLES,_,o.UNSIGNED_INT,0,E),this.OESVertexArrayObject.bindVertexArrayOES(null)}allocTexture(e,t,r,s){const n=this.gl,i=this.textures[e]||n.createTexture();n.bindTexture(n.TEXTURE_2D,i),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);const a=new Uint8Array(this.memory.buffer,s,t*r*4);n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t,r,0,n.RGBA,n.UNSIGNED_BYTE,a),this.textures[e]=i}beginRenderTargets(e,t,r){const s=this.gl;this.targetWidth=t,this.targetHeight=r,this.clearFlags=0;const n=this.framebuffers[e]||(this.framebuffers[e]=m(s.createFramebuffer()));s.bindFramebuffer(s.FRAMEBUFFER,n)}addColorTarget(e,t,r,s,n,i){this.clearR=r,this.clearG=s,this.clearB=n,this.clearA=i;const a=this.gl,o=this.textures[e]||(this.textures[e]=a.createTexture());o.mpWidth!=this.targetWidth||o.mpHeight!=this.targetHeight?(a.bindTexture(a.TEXTURE_2D,o),this.clearFlags|=a.COLOR_BUFFER_BIT,o.mpWidth=this.targetWidth,o.mpHeight=this.targetHeight,a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,o.mpWidth,o.mpHeight,0,a.RGBA,a.UNSIGNED_BYTE,null)):t||(this.clearFlags|=a.COLOR_BUFFER_BIT),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,o,0)}setDepthTarget(e,t,r){const s=this.gl;this.clearDepth=r;const n=this.textures[e]||(this.textures[e]=s.createRenderbuffer());n.mpWidth!=this.targetWidth||n.mpHeight!=this.targetHeight?(s.bindRenderbuffer(s.RENDERBUFFER,n),this.clearFlags|=s.DEPTH_BUFFER_BIT,n.mpWidth=this.targetWidth,n.mpHeight=this.targetHeight,s.renderbufferStorage(s.RENDERBUFFER,s.DEPTH_COMPONENT16,this.targetWidth,this.targetHeight)):t||(this.clearFlags|=s.DEPTH_BUFFER_BIT),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.RENDERBUFFER,n)}endRenderTargets(){const e=this.gl;e.viewport(0,0,this.targetWidth,this.targetHeight),this.clearFlags&&(e.clearColor(this.clearR,this.clearG,this.clearB,this.clearA),e.clearDepth(this.clearDepth),e.clear(this.clearFlags))}setDefaultDepthAndBlendMode(){const e=this.gl;e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.blendEquationSeparate(e.FUNC_ADD,e.FUNC_ADD),e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA),e.enable(e.BLEND)}beginMainCanvas(e,t,r,s,n){const i=this.gl;i.bindFramebuffer(i.FRAMEBUFFER,null),i.viewport(0,0,this.sizingData.width*this.sizingData.dpiFactor,this.sizingData.height*this.sizingData.dpiFactor),i.clearColor(e,t,r,s),i.clearDepth(n),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT)}}const z={float:1,vec2:2,vec3:3,vec4:4,mat2:4,mat3:9,mat4:16};function U(e){const t=e.split(\\\"\\\\n\\\");let r=\\\"\\\";for(let e=0;e<t.length;e++)r+=e+1+\\\": \\\"+t[e]+\\\"\\\\n\\\";return r}var B,y,A,w;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\"}(B||(B={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(y||(y={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(A||(A={})),function(e){e.Init=\\\"MainWorkerChannelEvent.Init\\\",e.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",e.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",e.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\"}(w||(w={}));var F=function(e,t,r,s){return new(r||(r=Promise))((function(n,i){function a(e){try{d(s.next(e))}catch(e){i(e)}}function o(e){try{d(s.throw(e))}catch(e){i(e)}}function d(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,o)}d((s=s.apply(e,t||[])).next())}))};const T=new c(self),R=self.navigator.userAgent.toLowerCase().indexOf(\\\"firefox\\\")>-1;class S{constructor({offscreenCanvas:e,wasmModule:t,wasmExports:r,memory:s,sizingData:n,baseUri:i,fileHandles:a,taskWorkerSab:o}){this.xrCanPresent=!1,this.xrIsPresenting=!1,this.sendFnTable=[function(e){return!0},function(e){const t=e.zerdeParser.parseU64();e.webglRenderer?(e.webglRenderer.processMessages(Number(t)),e.exports.deallocWasmMessage(t)):e.runWebGLPromise=T.send(B.RunWebGL,Number(t)).then((()=>{e.exports.deallocWasmMessage(t),e.runWebGLPromise=void 0}))},function(e){console.log(e.zerdeParser.parseString())},function(e){e.requestAnimationFrame()},function(e){e.setDocumentTitle(e.zerdeParser.parseString())},function(e){e.setMouseCursor(e.zerdeParser.parseU32())},function(e){const t=e.zerdeParser.parseF32(),r=e.zerdeParser.parseF32();T.send(B.ShowTextIME,{x:t,y:r})},function(e){},function(e){const t=e.zerdeParser.parseString();T.send(B.TextCopyResponse,t)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseF64(),s=e.zerdeParser.parseF64();e.startTimer(r,s,t)},function(e){const t=e.zerdeParser.parseF64();e.stopTimer(t)},function(e){e.xrStartPresenting()},function(e){e.xrStopPresenting()},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseString(),n=e.zerdeParser.parseString(),i=e.zerdeParser.parseString(),a=e.zerdeParser.parseString(),o=e.zerdeParser.parseString(),d=e.zerdeParser.parseU8Slice();e.httpSend(s,n,i,a,t,o,d,r)},function(e){T.send(B.Fullscreen)},function(e){T.send(B.Normalscreen)},function(e){const t=e.zerdeParser.parseString(),r=e.zerdeParser.parseU8Slice();e.websocketSend(t,r)},function(e){e.enableGlobalFileDropTarget()},function(e){const t=e.zerdeParser.parseString(),r=e.zerdeParser.parseZapParams();if(\\\"_zaplibReturnParams\\\"===t){const t=JSON.parse(r[0]);e.callRustPendingCallbacks[t](r.slice(1)),delete e.callRustPendingCallbacks[t]}else T.send(B.CallJs,{fnName:t,params:r})}],this.module=t,this.exports=r,this.memory=s,this.baseUri=i,this.sizingData=n,this.timers=[],this.hasRequestedAnimationFrame=!1,this.websockets={},this.fileHandles=a,this.callRustNewCallbackId=0,this.callRustPendingCallbacks={},e&&(this.webglRenderer=new v(e,this.memory,this.sizingData,(()=>{T.send(B.ShowIncompatibleBrowserNotification)}))),T.receive(B.ScreenResize,(e=>{this.sizingData=e,this.webglRenderer&&this.webglRenderer.resize(this.sizingData),this.zerdeEventloopEvents.resize({width:this.sizingData.width,height:this.sizingData.height,dpiFactor:this.sizingData.dpiFactor,xrIsPresenting:this.xrIsPresenting,xrCanPresent:this.xrCanPresent,isFullscreen:this.sizingData.isFullscreen}),this.requestAnimationFrame()})),this.bindMouseAndTouch(),this.bindKeyboard(),this.appPtr=this.exports.createWasmApp(),T.receive(B.WindowFocus,(()=>{this.zerdeEventloopEvents.windowFocus(!0),this.doWasmIo()})),T.receive(B.WindowBlur,(()=>{this.zerdeEventloopEvents.windowFocus(!1),this.doWasmIo()}));const d=({name:e,params:t})=>{const r=this.callRustNewCallbackId++,s=new Promise(((e,t)=>{this.callRustPendingCallbacks[r]=t=>{e(t)}}));return this.zerdeEventloopEvents.callRust(e,t,r),this.doWasmIo(),s};T.receive(B.CallRust,d),T.receive(B.CreateBuffer,(e=>this.zerdeEventloopEvents.createWasmBuffer(e))),T.receive(B.CreateReadOnlyBuffer,(e=>{const t=this.zerdeEventloopEvents.createWasmBuffer(e);return{bufferPtr:t,arcPtr:this.zerdeEventloopEvents.createArcVec(t,e)}})),T.receive(B.IncrementArc,(e=>{this.exports.incrementArc(BigInt(e))})),T.receive(B.DecrementArc,(e=>{this.exports.decrementArc(BigInt(e))})),T.receive(B.DeallocVec,(({bufferPtr:e,bufferLen:t,bufferCap:r})=>{this.exports.deallocVec(BigInt(e),BigInt(t),BigInt(r))}));const l=e=>{const t=new c(e);t.receive(w.Init,(()=>({wasmModule:this.module,memory:this.memory,taskWorkerSab:o,appPtr:this.appPtr,baseUri:i,tlsAndStackData:u(this.exports)}))),t.receive(w.BindMainWorkerPort,(e=>{l(e)})),t.receive(w.CallRust,d),t.receive(w.SendEventFromAnyThread,(e=>{this.sendEventFromAnyThread(e)}))};T.receive(B.BindMainWorkerPort,(e=>{l(e)})),this.zerdeEventloopEvents=new b(this),this.initApp()}initApp(){this.zerdeEventloopEvents.init({width:this.sizingData.width,height:this.sizingData.height,dpiFactor:this.sizingData.dpiFactor,xrCanPresent:this.xrCanPresent,canFullscreen:this.sizingData.canFullscreen,xrIsPresenting:!1}),this.doWasmIo(),T.send(B.RemoveLoadingIndicators)}doWasmIo(){if(this.doWasmBlock)return;const e=this.zerdeEventloopEvents.end(),t=Number(this.exports.processWasmEvents(this.appPtr,BigInt(e)));for(this.zerdeEventloopEvents=new b(this),this.zerdeParser=new d(this.memory,t);;){const e=this.zerdeParser.parseU32();if(this.sendFnTable[e](this))break}this.exports.deallocWasmMessage(BigInt(t))}setDocumentTitle(e){T.send(B.SetDocumentTitle,e)}bindMouseAndTouch(){let e;const t=[];function r(e){const r=t[e.button]||(t[e.button]={});return r.x=e.pageX,r.y=e.pageY,r.button=e.button,r.digit=e.button,r.time=performance.now()/1e3,r.modifiers=_(e),r.touch=!1,r}const s=[];T.receive(B.CanvasMouseDown,(e=>{s[e.button]=!0,this.zerdeEventloopEvents.pointerDown(r(e)),this.doWasmIo()})),T.receive(B.WindowMouseUp,(e=>{s[e.button]=!1,this.zerdeEventloopEvents.pointerUp(r(e)),this.doWasmIo()})),T.receive(B.WindowMouseMove,(t=>{for(let e=0;e<s.length;e++)if(s[e]){const s=r(t);s.digit=e,this.zerdeEventloopEvents.pointerMove(s)}e=r(t),this.zerdeEventloopEvents.pointerHover(e),this.doWasmIo()})),T.receive(B.WindowMouseOut,(e=>{this.zerdeEventloopEvents.pointerOut(r(e)),this.doWasmIo()}));const n=[];let i,a;T.receive(B.WindowTouchStart,(e=>{for(const t of e.changedTouches){let r=n.indexOf(void 0);-1===r&&(r=n.length),n[r]=t.identifier,this.zerdeEventloopEvents.pointerDown({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0})}this.doWasmIo()})),T.receive(B.WindowTouchMove,(e=>{for(const t of e.changedTouches){const r=n.indexOf(t.identifier);-1!=r?this.zerdeEventloopEvents.pointerMove({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0}):console.error(\\\"Unrecognized digit in WorkerEvent.WindowTouchMove\\\")}this.doWasmIo()})),T.receive(B.WindowTouchEndCancelLeave,(e=>{for(const t of e.changedTouches){const r=n.indexOf(t.identifier);-1!=r?(n[r]=void 0,this.zerdeEventloopEvents.pointerUp({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0})):console.error(\\\"Unrecognized digit in WorkerEvent.WindowTouchMove\\\")}this.doWasmIo()})),T.receive(B.CanvasWheel,(e=>{const t=r(e),s=e.timeStamp-i;i=e.timeStamp,a=R?1==e.deltaMode:!(Math.abs(Math.abs(e.deltaY/e.wheelDeltaY)-1/3)<1e-5||!a&&s<250);let n=1;1===e.deltaMode?n=40:2===e.deltaMode&&(n=800);const o=Object.assign(Object.assign({},t),{scrollX:e.deltaX*n,scrollY:e.deltaY*n,isWheel:a});this.zerdeEventloopEvents.pointerScroll(o),this.doWasmIo()}))}bindKeyboard(){T.receive(B.TextInput,(e=>{this.zerdeEventloopEvents.textInput(e),this.doWasmIo()})),T.receive(B.TextCopy,(()=>{this.zerdeEventloopEvents.textCopy(),this.doWasmIo()})),T.receive(B.KeyDown,(e=>{this.zerdeEventloopEvents.keyDown(e),this.doWasmIo()})),T.receive(B.KeyUp,(e=>{this.zerdeEventloopEvents.keyUp(e),this.doWasmIo()}))}setMouseCursor(t){T.send(B.SetMouseCursor,e[t]||\\\"default\\\")}startTimer(e,t,r){for(let t=0;t<this.timers.length;t++)if(this.timers[t].id==e)return void console.log(\\\"Timer ID collision!\\\");const s=0!==r?self.setInterval((()=>{this.zerdeEventloopEvents.timerFired(e),this.doWasmIo()}),1e3*t):self.setTimeout((()=>{for(let t=0;t<this.timers.length;t++)if(this.timers[t].id==e){this.timers.splice(t,1);break}this.zerdeEventloopEvents.timerFired(e),this.doWasmIo()}),1e3*t);this.timers.push({id:e,repeats:r,sysId:s})}stopTimer(e){for(let t=0;t<this.timers.length;t++){const r=this.timers[t];if(r.id==e)return r.repeats?self.clearInterval(r.sysId):self.clearTimeout(r.sysId),void this.timers.splice(t,1)}}httpSend(e,t,r,s,n,i,a,o){const d=new XMLHttpRequest;d.addEventListener(\\\"error\\\",(e=>{this.zerdeEventloopEvents.httpSendResponse(o,2),this.doWasmIo()})),d.addEventListener(\\\"load\\\",(e=>{200!==d.status?this.zerdeEventloopEvents.httpSendResponse(o,2):this.zerdeEventloopEvents.httpSendResponse(o,1),this.doWasmIo()})),d.open(e,r+\\\"://\\\"+s+\\\":\\\"+n+t,!0),console.log(e,r+\\\"://\\\"+s+\\\":\\\"+n+t,a),d.send(a.buffer)}websocketSend(e,t){const r=this.websockets[e];if(r)r.sendStack?r.sendStack.push(t):r.send(t);else{const r=new WebSocket(e);this.websockets[e]=r,r.sendStack=[t],r.addEventListener(\\\"close\\\",(()=>{this.websockets[e]=null})),r.addEventListener(\\\"error\\\",(t=>{this.websockets[e]=null,this.zerdeEventloopEvents.websocketError(e,\\\"\\\"+t),this.doWasmIo()})),r.addEventListener(\\\"message\\\",(t=>{t.data.arrayBuffer().then((t=>{this.zerdeEventloopEvents.websocketMessage(e,t),this.doWasmIo()}))})),r.addEventListener(\\\"open\\\",(()=>{const e=r.sendStack;for(t of(r.sendStack=null,e))r.send(t)}))}}enableGlobalFileDropTarget(){T.send(B.EnableGlobalFileDropTarget),T.receive(B.DragEnter,(()=>{this.zerdeEventloopEvents.dragenter(),this.doWasmIo()})),T.receive(B.DragOver,(({x:e,y:t})=>{this.zerdeEventloopEvents.dragover(e,t),this.doWasmIo()})),T.receive(B.DragLeave,(()=>{this.zerdeEventloopEvents.dragleave(),this.doWasmIo()})),T.receive(B.Drop,(({fileHandles:e,fileHandlesToSend:t})=>{this.fileHandles.splice(0,this.fileHandles.length),this.fileHandles.push(...e),this.zerdeEventloopEvents.appOpenFiles(t),this.doWasmIo()}))}requestAnimationFrame(){return F(this,void 0,void 0,(function*(){this.xrIsPresenting||this.hasRequestedAnimationFrame||(this.hasRequestedAnimationFrame=!0,this.runWebGLPromise&&(yield this.runWebGLPromise),(self.requestAnimationFrame||self.setTimeout)((()=>F(this,void 0,void 0,(function*(){this.runWebGLPromise&&(yield this.runWebGLPromise),this.hasRequestedAnimationFrame=!1,this.xrIsPresenting||(this.zerdeEventloopEvents.animationFrame(),this.doWasmIo())})))))}))}xrStartPresenting(){}xrStopPresenting(){}sendEventFromAnyThread(e){setTimeout((()=>{this.zerdeEventloopEvents.sendEventFromAnyThread(e),this.doWasmIo()}))}}T.receive(B.Init,(({wasmModule:e,offscreenCanvas:t,sizingData:r,baseUri:s,memory:n,taskWorkerSab:i})=>{let a;return new Promise(((o,d)=>{const l=[],h=(({getExports:e,memory:t,taskWorkerSab:r,fileHandles:s,sendEventFromAnyThread:n,threadSpawn:i,baseUri:a})=>{const o=new FileReaderSync,d=(e,r)=>{let s=\\\"\\\";const n=new Uint32Array(t.buffer,e,r);for(let e=0;e<r;e++)s+=String.fromCharCode(n[e]);return s};return{memory:t,_consoleLog:(e,t,r)=>{const s=d(parseInt(e),parseInt(t));r?console.error(s):console.log(s)},readUserFileRange:(e,r,n,i)=>{const a=s[e],d=Number(i),l=d+Number(n);a.lastReadStart<=d&&d<a.lastReadEnd&&console.warn(`Read start (${d}) fell in the range of the last read (${a.lastReadStart}-${a.lastReadEnd}); this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.`),a.lastReadStart=d,a.lastReadEnd=l;const h=o.readAsArrayBuffer(a.file.slice(d,l));return f(new Uint8Array(h),t.buffer,Number(r)),BigInt(h.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{i(e)},_sendEventFromAnyThread:e=>{n(e)},readUrlSync:(r,s,n,i)=>{const o=d(r,s),l=new XMLHttpRequest;if(l.responseType=\\\"arraybuffer\\\",l.open(\\\"GET\\\",new URL(o,a).href,!1),l.send(null),200===l.status){const r=e(),s=g(t,r,new Uint8Array(l.response));return new Uint32Array(t.buffer,n,1)[0]=s,new Uint32Array(t.buffer,i,1)[0]=l.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,t)=>{const r=new Int32Array(e);((e,t)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(r);const s=r[1];new Uint32Array(e)[s+2]=t,r[1]=s+1,((e,t)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,0,1)})(r),Atomics.notify(r,1)})(r,parseInt(e))}}})({getExports:()=>a.exports,memory:n,taskWorkerSab:i,fileHandles:l,sendEventFromAnyThread:e=>{a.sendEventFromAnyThread(e)},threadSpawn:e=>{T.send(B.ThreadSpawn,{ctxPtr:e,tlsAndStackData:u(a.exports)})},baseUri:s});WebAssembly.instantiate(e,{env:h}).then((d=>{const h=d.exports;(e=>{const t=e.allocWasmMessage(BigInt(e.__tls_size.value));e.__wasm_init_tls(Number(t))})(h),a=new S({offscreenCanvas:t,wasmModule:e,wasmExports:h,memory:n,sizingData:r,baseUri:s,fileHandles:l,taskWorkerSab:i}),o()}),d)}))}))})();\\n\", \"Worker\", undefined, undefined);\n}\n","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";var e,r;(r=e||(e={}))[r.String=0]=\\\"String\\\",r[r.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",r[r.U8Buffer=2]=\\\"U8Buffer\\\",r[r.F32Buffer=3]=\\\"F32Buffer\\\",r[r.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\",self;class t extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class r extends e{constructor(...r){const n=r[0];if(\\\"object\\\"==typeof n&&n instanceof t){if(r.length<2&&(r[1]=n.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<n.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=n.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=n}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const a={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,r]of Object.entries(a))e in self&&(self[r]=n(self[e]));new WeakMap;const o={};new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete o[e],r&&r(e)})),new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)}));const s=\\\"$$RESPONSE\\\",i=\\\"$$ERROR\\\";class l{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===s)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:s,id:r},[]);const t=e[l.transferrables];delete e[l.transferrables];const n={topic:s,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:s,id:r,data:{[i]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,a={topic:e,id:n,data:r},o=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[i]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(a,t),o}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}l.transferrables=\\\"$$TRANSFERRABLES\\\";const c=e=>{const r=8*Math.ceil((e.__tls_size.value+2097152)/8);return{ptr:e.allocWasmMessage(BigInt(r)),size:r}},f=(e,r,t)=>{new e.constructor(r,t,e.length).set(e)},u=({getExports:e,memory:r,taskWorkerSab:t,fileHandles:n,sendEventFromAnyThread:a,threadSpawn:o,baseUri:s})=>{const i=new FileReaderSync,l=(e,t)=>{let n=\\\"\\\";const a=new Uint32Array(r.buffer,e,t);for(let e=0;e<t;e++)n+=String.fromCharCode(a[e]);return n};return{memory:r,_consoleLog:(e,r,t)=>{const n=l(parseInt(e),parseInt(r));t?console.error(n):console.log(n)},readUserFileRange:(e,t,a,o)=>{const s=n[e],l=Number(o),c=l+Number(a);s.lastReadStart<=l&&l<s.lastReadEnd&&console.warn(`Read start (${l}) fell in the range of the last read (${s.lastReadStart}-${s.lastReadEnd}); this usually happens if you don't use BufReader or if you don't use BufReader.seek_relative.`),s.lastReadStart=l,s.lastReadEnd=c;const u=i.readAsArrayBuffer(s.file.slice(l,c));return f(new Uint8Array(u),r.buffer,Number(t)),BigInt(u.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{o(e)},_sendEventFromAnyThread:e=>{a(e)},readUrlSync:(t,n,a,o)=>{const i=l(t,n),c=new XMLHttpRequest;if(c.responseType=\\\"arraybuffer\\\",c.open(\\\"GET\\\",new URL(i,s).href,!1),c.send(null),200===c.status){const t=e(),n=((e,r,t)=>{const n=Number(r.allocWasmVec(BigInt(t.byteLength)));return f(t,e.buffer,n),n})(r,t,new Uint8Array(c.response));return new Uint32Array(r.buffer,a,1)[0]=n,new Uint32Array(r.buffer,o,1)[0]=c.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,r)=>{const t=new Int32Array(e);((e,r)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(t);const n=t[1];new Uint32Array(e)[n+2]=r,t[1]=n+1,((e,r)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,0,1)})(t),Atomics.notify(t,1)})(t,parseInt(e))}}};var d,p,h,E;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\"}(d||(d={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(p||(p={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(h||(h={})),function(e){e.Init=\\\"MainWorkerChannelEvent.Init\\\",e.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",e.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",e.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\"}(E||(E={}));const y=new l(self);y.receive(h.Run,(({wasmModule:e,memory:r,taskWorkerSab:t,ctxPtr:n,fileHandles:a,baseUri:o,tlsAndStackData:s,mainWorkerPort:i})=>{let f;const d=new l(i),p=u({getExports:()=>f,memory:r,taskWorkerSab:t,fileHandles:a,sendEventFromAnyThread:e=>{d.send(E.SendEventFromAnyThread,e)},threadSpawn:e=>{y.send(h.ThreadSpawn,{ctxPtr:e,tlsAndStackData:c(f)})},baseUri:o});return new Promise(((r,t)=>{WebAssembly.instantiate(e,{env:p}).then((e=>{f=e.exports,((e,r)=>{e.__stack_pointer.value=Number(r.ptr)+r.size-8,e.__wasm_init_tls(Number(r.ptr))})(f,s),f.runFunctionPointer(n),r()}),t)}))}))})();\\n\", \"Worker\", undefined, undefined);\n}\n","\nimport worker from \"!!./node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"(()=>{\\\"use strict\\\";var e,r;(r=e||(e={}))[r.String=0]=\\\"String\\\",r[r.ReadOnlyU8Buffer=1]=\\\"ReadOnlyU8Buffer\\\",r[r.U8Buffer=2]=\\\"U8Buffer\\\",r[r.F32Buffer=3]=\\\"F32Buffer\\\",r[r.ReadOnlyF32Buffer=4]=\\\"ReadOnlyF32Buffer\\\",self;class t extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class r extends e{constructor(...r){const n=r[0];if(\\\"object\\\"==typeof n&&n instanceof t){if(r.length<2&&(r[1]=n.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<n.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=n.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=n}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const s={Int8Array:\\\"ZapInt8Array\\\",Uint8Array:\\\"ZapUint8Array\\\",Uint8ClampedArray:\\\"ZapUint8ClampedArray\\\",Int16Array:\\\"ZapInt16Array\\\",Uint16Array:\\\"ZapUint16Array\\\",Uint16ClampedArray:\\\"ZapUint16ClampedArray\\\",Int32Array:\\\"ZapInt32Array\\\",Uint32Array:\\\"ZapUint32Array\\\",Float32Array:\\\"ZapFloat32Array\\\",Float64Array:\\\"ZapFloat64Array\\\",BigInt64Array:\\\"ZapBigInt64Array\\\",BigUint64Array:\\\"ZapBigUint64Array\\\",DataView:\\\"ZapDataView\\\"};for(const[e,r]of Object.entries(s))e in self&&(self[r]=n(self[e]));new WeakMap;const a={};new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete a[e],r&&r(e)})),new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)}));class o{constructor(e,r){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,r),this._u32=new Uint32Array(this._memory.buffer,r),this._f64=new Float64Array(this._memory.buffer,r),this._u64=new BigUint64Array(this._memory.buffer,r)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e=\\\"\\\";const r=this.parseU32();for(let t=0;t<r;t++){const r=this.parseU32();0!=r&&(e+=String.fromCharCode(r))}return e}parseU8Slice(){const e=this.parseU32(),r=e>>2,t=new Uint8Array(e),n=3&e;for(let e=0;e<r;e++){const r=e<<2,n=this.parseU32();t[r+0]=255&n,t[r+1]=n>>8&255,t[r+2]=n>>16&255,t[r+3]=n>>24&255}const s=r<<2;if(1==n){const e=this.parseU32();t[s+0]=255&e}else if(2==n){const e=this.parseU32();t[s+0]=255&e,t[s+1]=e>>8&255}else if(3==n){const e=this.parseU32();t[s+0]=255&e,t[s+1]=e>>8&255,t[s+2]=e>>16&255}return t}parseZapParams(){const r=this.parseU32(),t=[];for(let n=0;n<r;++n){const r=this.parseU32();if(r===e.String)t.push(this.parseString());else if(r===e.ReadOnlyU8Buffer||r===e.ReadOnlyF32Buffer){const e=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,arcPtr:s,readonly:!0})}else{if(r!==e.U8Buffer&&r!==e.F32Buffer)throw new Error(`Unknown ZapParam type: ${r}`);{const e=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,bufferCap:s,readonly:!1})}}}return t}}const i=\\\"$$RESPONSE\\\",f=\\\"$$ERROR\\\";class u{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===i)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:i,id:r},[]);const t=e[u.transferrables];delete e[u.transferrables];const n={topic:i,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:i,id:r,data:{[f]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error(\\\"channel.onmessage is already set. Can only use one Rpc instance per channel.\\\");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,s={topic:e,id:n,data:r},a=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[f]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(s,t),a}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error(\\\"Rpc postMessage call itself failed: \\\",e)}}}u.transferrables=\\\"$$TRANSFERRABLES\\\";const l=(e,r)=>{for(;;){if(0==Atomics.compareExchange(e,r,0,1))return;Atomics.wait(e,r,1)}},c=(e,r)=>{if(1!=Atomics.compareExchange(e,r,1,0))throw new Error(\\\"Called mutex_unlock on an already unlocked mutex\\\");Atomics.notify(e,r,1)};function h(e,r=\\\"Value\\\"){if(null==e)throw new Error(`Assertion failed: ${r} is null`);return e}var d,p,y,v;!function(e){e.CallRust=\\\"WorkerEvent.CallRust\\\",e.CreateBuffer=\\\"WorkerEvent.CreateBuffer\\\",e.CreateReadOnlyBuffer=\\\"WorkerEvent.CreateReadOnlyBuffer\\\",e.BindMainWorkerPort=\\\"WorkerEvent.BindMainWorkerPort\\\",e.DecrementArc=\\\"WorkerEvent.DecrementArc\\\",e.DeallocVec=\\\"WorkerEvent.DeallocVec\\\",e.IncrementArc=\\\"WorkerEvent.IncrementArc\\\",e.DragEnter=\\\"WorkerEvent.DragEnter\\\",e.DragOver=\\\"WorkerEvent.DragOver\\\",e.DragLeave=\\\"WorkerEvent.DragLeave\\\",e.Drop=\\\"WorkerEvent.Drop\\\",e.WindowMouseUp=\\\"WorkerEvent.WindowMouseUp\\\",e.CanvasMouseDown=\\\"WorkerEvent.CanvasMouseDown\\\",e.WindowMouseMove=\\\"WorkerEvent.WindowMouseMove\\\",e.WindowMouseOut=\\\"WorkerEvent.WindowMouseOut\\\",e.WindowFocus=\\\"WorkerEvent.WindowFocus\\\",e.WindowBlur=\\\"WorkerEvent.WindowBlur\\\",e.ScreenResize=\\\"WorkerEvent.ScreenResize\\\",e.CanvasWheel=\\\"WorkerEvent.CanvasWheel\\\",e.ShowIncompatibleBrowserNotification=\\\"WorkerEvent.ShowIncompatibleBrowserNotification\\\",e.RemoveLoadingIndicators=\\\"WorkerEvent.RemoveLoadingIndicators\\\",e.SetDocumentTitle=\\\"WorkerEvent.SetDocumentTitle\\\",e.SetMouseCursor=\\\"WorkerEvent.SetMouseCursor\\\",e.Fullscreen=\\\"WorkerEvent.Fullscreen\\\",e.Normalscreen=\\\"WorkerEvent.Normalscreen\\\",e.TextCopyResponse=\\\"WorkerEvent.TextCopyResponse\\\",e.EnableGlobalFileDropTarget=\\\"WorkerEvent.EnableGlobalFileDropTarget\\\",e.CallJs=\\\"WorkerEvent.CallJs\\\",e.ShowTextIME=\\\"WorkerEvent.ShowTextIME\\\",e.TextInput=\\\"WorkerEvent.TextInput\\\",e.TextCopy=\\\"WorkerEvent.TextCopy\\\",e.KeyDown=\\\"WorkerEvent.KeyDown\\\",e.KeyUp=\\\"WorkerEvent.KeyUp\\\",e.Init=\\\"WorkerEvent.Init\\\",e.RunWebGL=\\\"WorkerEvent.RunWebGL\\\",e.ThreadSpawn=\\\"WorkerEvent.ThreadSpawn\\\",e.WindowTouchStart=\\\"WorkerEvent.WindowTouchStart\\\",e.WindowTouchMove=\\\"WorkerEvent.WindowTouchMove\\\",e.WindowTouchEndCancelLeave=\\\"WorkerEvent.WindowTouchEndCancelLeave\\\"}(d||(d={})),function(e){e.Init=\\\"TaskWorkerEvent.Init\\\"}(p||(p={})),function(e){e.Run=\\\"AsyncWorkerEvent.Run\\\",e.ThreadSpawn=\\\"AsyncWorkerEvent.ThreadSpawn\\\"}(y||(y={})),function(e){e.Init=\\\"MainWorkerChannelEvent.Init\\\",e.BindMainWorkerPort=\\\"MainWorkerChannelEvent.BindMainWorkerPort\\\",e.CallRust=\\\"MainWorkerChannelEvent.CallRust\\\",e.SendEventFromAnyThread=\\\"MainWorkerChannelEvent.SendEventFromAnyThread\\\"}(v||(v={})),new u(self).receive(p.Init,(({taskWorkerSab:e,wasmMemory:r})=>{const t=new Int32Array(e);let n=0,s=1;const a={};function i(e,t){const n=new Int32Array(r.buffer,e,1);if(n[0]===t)throw new Error(\\\"Have to set the return value to something different than the initial value, otherwise Atomics.notify won't do anything\\\");n[0]=t,Atomics.notify(n,0)}function f(e){const r=a[e];n++,r.reader.read().then((t=>{n--,t.done?r.done=!0:(r.values.push(t.value),f(e)),u(e)})).catch((t=>{n--,console.error(\\\"fetch read error\\\",t),r.error=!0,u(e)}))}function u(e){const t=a[e];if(!t.currentTwMessage)return;if(t.error)return i(t.currentTwMessage.bytesReadReturnValPtr,-2),void(t.currentTwMessage=void 0);if(0===t.values.length)return void(t.done&&(i(t.currentTwMessage.bytesReadReturnValPtr,0),t.currentTwMessage=void 0));let n=0;for(;t.values.length>0&&n<t.currentTwMessage.bufLen;){const e=t.values[0],s=t.currentTwMessage.bufLen-n,a=Math.min(e.byteLength,s),o=new Uint8Array(e.buffer,e.byteOffset,a);new Uint8Array(r.buffer,t.currentTwMessage.bufPtr+n,a).set(o),a<e.byteLength?t.values[0]=new Uint8Array(e.buffer,e.byteOffset+a,e.byteLength-a):t.values.shift(),n+=a}i(t.currentTwMessage.bytesReadReturnValPtr,n),t.currentTwMessage=void 0}function d(e){const r=e.parseU32();if(1==r){const r=e.parseU32(),t=e.parseString(),o=e.parseString(),u=e.parseU8Slice(),l=e.parseU32(),c={};for(let r=0;r<l;r++)c[e.parseString()]=e.parseString();n++,fetch(t,{method:o,body:u,headers:c}).then((e=>{if(n--,e.ok){const t=s++;a[t]={reader:h(e.body).getReader(),values:[],done:!1,error:!1,currentTwMessage:void 0},f(t),i(r,t)}else i(r,-2)})).catch((e=>{n--,console.error(\\\"fetch create error\\\",e),i(r,-2)}))}else if(2==r){const r={bytesReadReturnValPtr:e.parseU32(),streamId:e.parseU32(),bufPtr:e.parseU32(),bufLen:e.parseU32()};if(a[r.streamId].currentTwMessage)return console.error(\\\"Got multiple http_stream_read messages in a row\\\"),void i(r.bytesReadReturnValPtr,-2);a[r.streamId].currentTwMessage=r,u(r.streamId)}}setTimeout((function s(){for(;;){if(Atomics.load(t,1)>0){l(t,0);const n=t[1];for(let t=0;t<n;t++){const n=new Uint32Array(e)[t+2];d(new o(r,n))}t[1]=0,c(t,0)}if(n>0){setTimeout(s,1);break}Atomics.wait(t,1,0)}}),0)}))})();\\n\", \"Worker\", undefined, undefined);\n}\n","export const makeRpcMouseEvent = (event) => {\n    return {\n        pageX: event.pageX,\n        pageY: event.pageY,\n        button: event.button,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\nexport const makeRpcTouchEvent = (event) => {\n    return {\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n        changedTouches: Array.from(event.changedTouches).map((touch) => ({\n            pageX: touch.pageX,\n            pageY: touch.pageY,\n            identifier: touch.identifier,\n        })),\n    };\n};\nexport const makeRpcWheelEvent = (event) => {\n    return {\n        pageX: event.pageX,\n        pageY: event.pageY,\n        button: event.button,\n        timeStamp: event.timeStamp,\n        deltaMode: event.deltaMode,\n        deltaX: event.deltaX,\n        deltaY: event.deltaY,\n        // @ts-ignore - the wheelDeltaY API is non-standard\n        wheelDeltaY: event.wheelDeltaY,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\nexport const makeRpcKeyboardEvent = (event) => {\n    return {\n        keyCode: event.keyCode,\n        repeat: event.repeat,\n        shiftKey: event.shiftKey,\n        ctrlKey: event.ctrlKey,\n        metaKey: event.metaKey,\n        altKey: event.altKey,\n    };\n};\n","export var WorkerEvent;\n(function (WorkerEvent) {\n    WorkerEvent[\"CallRust\"] = \"WorkerEvent.CallRust\";\n    WorkerEvent[\"CreateBuffer\"] = \"WorkerEvent.CreateBuffer\";\n    WorkerEvent[\"CreateReadOnlyBuffer\"] = \"WorkerEvent.CreateReadOnlyBuffer\";\n    WorkerEvent[\"BindMainWorkerPort\"] = \"WorkerEvent.BindMainWorkerPort\";\n    WorkerEvent[\"DecrementArc\"] = \"WorkerEvent.DecrementArc\";\n    WorkerEvent[\"DeallocVec\"] = \"WorkerEvent.DeallocVec\";\n    WorkerEvent[\"IncrementArc\"] = \"WorkerEvent.IncrementArc\";\n    WorkerEvent[\"DragEnter\"] = \"WorkerEvent.DragEnter\";\n    WorkerEvent[\"DragOver\"] = \"WorkerEvent.DragOver\";\n    WorkerEvent[\"DragLeave\"] = \"WorkerEvent.DragLeave\";\n    WorkerEvent[\"Drop\"] = \"WorkerEvent.Drop\";\n    WorkerEvent[\"WindowMouseUp\"] = \"WorkerEvent.WindowMouseUp\";\n    WorkerEvent[\"CanvasMouseDown\"] = \"WorkerEvent.CanvasMouseDown\";\n    WorkerEvent[\"WindowMouseMove\"] = \"WorkerEvent.WindowMouseMove\";\n    WorkerEvent[\"WindowMouseOut\"] = \"WorkerEvent.WindowMouseOut\";\n    WorkerEvent[\"WindowFocus\"] = \"WorkerEvent.WindowFocus\";\n    WorkerEvent[\"WindowBlur\"] = \"WorkerEvent.WindowBlur\";\n    WorkerEvent[\"ScreenResize\"] = \"WorkerEvent.ScreenResize\";\n    WorkerEvent[\"CanvasWheel\"] = \"WorkerEvent.CanvasWheel\";\n    WorkerEvent[\"ShowIncompatibleBrowserNotification\"] = \"WorkerEvent.ShowIncompatibleBrowserNotification\";\n    WorkerEvent[\"RemoveLoadingIndicators\"] = \"WorkerEvent.RemoveLoadingIndicators\";\n    WorkerEvent[\"SetDocumentTitle\"] = \"WorkerEvent.SetDocumentTitle\";\n    WorkerEvent[\"SetMouseCursor\"] = \"WorkerEvent.SetMouseCursor\";\n    WorkerEvent[\"Fullscreen\"] = \"WorkerEvent.Fullscreen\";\n    WorkerEvent[\"Normalscreen\"] = \"WorkerEvent.Normalscreen\";\n    WorkerEvent[\"TextCopyResponse\"] = \"WorkerEvent.TextCopyResponse\";\n    WorkerEvent[\"EnableGlobalFileDropTarget\"] = \"WorkerEvent.EnableGlobalFileDropTarget\";\n    WorkerEvent[\"CallJs\"] = \"WorkerEvent.CallJs\";\n    WorkerEvent[\"ShowTextIME\"] = \"WorkerEvent.ShowTextIME\";\n    WorkerEvent[\"TextInput\"] = \"WorkerEvent.TextInput\";\n    WorkerEvent[\"TextCopy\"] = \"WorkerEvent.TextCopy\";\n    WorkerEvent[\"KeyDown\"] = \"WorkerEvent.KeyDown\";\n    WorkerEvent[\"KeyUp\"] = \"WorkerEvent.KeyUp\";\n    WorkerEvent[\"Init\"] = \"WorkerEvent.Init\";\n    WorkerEvent[\"RunWebGL\"] = \"WorkerEvent.RunWebGL\";\n    WorkerEvent[\"ThreadSpawn\"] = \"WorkerEvent.ThreadSpawn\";\n    WorkerEvent[\"WindowTouchStart\"] = \"WorkerEvent.WindowTouchStart\";\n    WorkerEvent[\"WindowTouchMove\"] = \"WorkerEvent.WindowTouchMove\";\n    WorkerEvent[\"WindowTouchEndCancelLeave\"] = \"WorkerEvent.WindowTouchEndCancelLeave\";\n})(WorkerEvent || (WorkerEvent = {}));\nexport var TaskWorkerEvent;\n(function (TaskWorkerEvent) {\n    TaskWorkerEvent[\"Init\"] = \"TaskWorkerEvent.Init\";\n})(TaskWorkerEvent || (TaskWorkerEvent = {}));\nexport var AsyncWorkerEvent;\n(function (AsyncWorkerEvent) {\n    AsyncWorkerEvent[\"Run\"] = \"AsyncWorkerEvent.Run\";\n    AsyncWorkerEvent[\"ThreadSpawn\"] = \"AsyncWorkerEvent.ThreadSpawn\";\n})(AsyncWorkerEvent || (AsyncWorkerEvent = {}));\nexport var MainWorkerChannelEvent;\n(function (MainWorkerChannelEvent) {\n    MainWorkerChannelEvent[\"Init\"] = \"MainWorkerChannelEvent.Init\";\n    MainWorkerChannelEvent[\"BindMainWorkerPort\"] = \"MainWorkerChannelEvent.BindMainWorkerPort\";\n    MainWorkerChannelEvent[\"CallRust\"] = \"MainWorkerChannelEvent.CallRust\";\n    MainWorkerChannelEvent[\"SendEventFromAnyThread\"] = \"MainWorkerChannelEvent.SendEventFromAnyThread\";\n})(MainWorkerChannelEvent || (MainWorkerChannelEvent = {}));\n","import { makeRpcKeyboardEvent } from \"./make_rpc_event\";\nimport { WorkerEvent } from \"./rpc_types\";\n// Create a hidden textarea which is purely used for text input into Rust.\nexport function makeTextarea(callback) {\n    let ta;\n    // NOTE(JP): This looks a bit convoluted, but it's the most reliable method I could find to return the focus to the textarea!\n    function fixFocus() {\n        setTimeout(() => {\n            var _a;\n            if (ta &&\n                document.activeElement !== ta &&\n                !((_a = document\n                    .getElementById(\"zaplib_js_root\")) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement))) {\n                ta.focus();\n            }\n        });\n    }\n    document.addEventListener(\"mousedown\", fixFocus, true);\n    document.addEventListener(\"mouseup\", fixFocus, true);\n    document.addEventListener(\"focus\", fixFocus, true);\n    document.addEventListener(\"blur\", fixFocus, true);\n    let textAreaPos;\n    const updateTextAreaPos = () => {\n        if (!textAreaPos) {\n            ta.style.left = -100 + \"px\";\n            ta.style.top = -100 + \"px\";\n        }\n        else {\n            ta.style.left = Math.round(textAreaPos.x) - 4 + \"px\";\n            ta.style.top = Math.round(textAreaPos.y) + \"px\";\n        }\n    };\n    function showTextIME({ x, y }) {\n        textAreaPos = { x, y };\n        updateTextAreaPos();\n    }\n    let wasPaste = false;\n    let lastLen = 0;\n    let uglyIMEHack = false;\n    const recreateTextarea = function () {\n        if (ta)\n            document.body.removeChild(ta);\n        ta = document.createElement(\"textarea\");\n        ta.className = \"zaplib_textarea\";\n        ta.setAttribute(\"autocomplete\", \"off\");\n        ta.setAttribute(\"autocorrect\", \"off\");\n        ta.setAttribute(\"autocapitalize\", \"off\");\n        ta.setAttribute(\"spellcheck\", \"false\");\n        ta.style.left = -100 + \"px\";\n        ta.style.top = -100 + \"px\";\n        ta.style.height = 1 + \"px\";\n        ta.style.width = 1 + \"px\";\n        ta.addEventListener(\"contextmenu\", (event) => {\n            event.preventDefault();\n            return false;\n        });\n        document.body.appendChild(ta);\n        ta.focus();\n        updateTextAreaPos();\n        ta.addEventListener(\"cut\", () => {\n            setTimeout(() => {\n                ta.value = \"\";\n                lastLen = 0;\n            });\n        });\n        ta.addEventListener(\"copy\", () => {\n            setTimeout(() => {\n                ta.value = \"\";\n                lastLen = 0;\n            });\n        });\n        ta.addEventListener(\"paste\", () => {\n            wasPaste = true;\n        });\n        ta.addEventListener(\"input\", () => {\n            if (ta.value.length > 0) {\n                if (wasPaste) {\n                    wasPaste = false;\n                    const input = ta.value.substring(lastLen);\n                    ta.value = \"\";\n                    callback({\n                        type: WorkerEvent.TextInput,\n                        wasPaste: true,\n                        input,\n                        replaceLast: false,\n                    });\n                }\n                else {\n                    let replaceLast = false;\n                    let textValue = ta.value;\n                    if (ta.value.length >= 2) {\n                        // we want the second char\n                        textValue = ta.value.substring(1, 2);\n                        ta.value = textValue;\n                    }\n                    else if (ta.value.length == 1 && lastLen == ta.value.length) {\n                        // its an IME replace\n                        replaceLast = true;\n                    }\n                    // we should send a replace last\n                    if (replaceLast || textValue != \"\\n\") {\n                        callback({\n                            type: WorkerEvent.TextInput,\n                            wasPaste: false,\n                            input: textValue,\n                            replaceLast: replaceLast,\n                        });\n                    }\n                }\n            }\n            lastLen = ta.value.length;\n        });\n        ta.addEventListener(\"keydown\", (event) => {\n            const code = event.keyCode;\n            if (code == 18 || code == 17 || code == 16)\n                event.preventDefault(); // alt\n            if (code === 8 || code === 9)\n                event.preventDefault(); // backspace/tab\n            if (code === 89 && (event.metaKey || event.ctrlKey))\n                event.preventDefault(); // all (select all)\n            if (code === 83 && (event.metaKey || event.ctrlKey))\n                event.preventDefault(); // ctrl s\n            if (code >= 33 && code <= 40) {\n                // if we are using arrow keys, home or end\n                ta.value = \"\";\n                lastLen = ta.value.length;\n            }\n            if ((code === 88 || code == 67) && (event.metaKey || event.ctrlKey)) {\n                // copy or cut\n                // we need to request the clipboard\n                callback({ type: WorkerEvent.TextCopy });\n                event.preventDefault();\n            }\n            if (code === 90 && (event.metaKey || event.ctrlKey)) {\n                // ctrl/cmd + z\n                updateTextAreaPos();\n                ta.value = \"\";\n                uglyIMEHack = true;\n                ta.readOnly = true;\n                event.preventDefault();\n            }\n            callback({\n                type: WorkerEvent.KeyDown,\n                event: makeRpcKeyboardEvent(event),\n            });\n        });\n        ta.addEventListener(\"keyup\", (event) => {\n            const code = event.keyCode;\n            if (code == 18 || code == 17 || code == 16)\n                event.preventDefault(); // alt\n            if (code == 91)\n                event.preventDefault(); // left window key\n            if (uglyIMEHack) {\n                uglyIMEHack = false;\n                recreateTextarea();\n            }\n            callback({\n                type: WorkerEvent.KeyUp,\n                event: makeRpcKeyboardEvent(event),\n            });\n        });\n    };\n    recreateTextarea();\n    function textareaHasFocus() {\n        return document.activeElement == ta;\n    }\n    return { showTextIME, textareaHasFocus };\n}\n","import { assertNotNull } from \"./common\";\nimport { ZerdeParser } from \"./zerde\";\nexport class WebGLRenderer {\n    constructor(canvas, memory, sizingData, incompatibleBrowserCallback) {\n        this.uniformFnTable = {\n            float: function setFloat(self, loc, off) {\n                const slot = off >> 2;\n                self.gl.uniform1f(loc, self.basef32[slot]);\n            },\n            vec2: function setVec2(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform2f(loc, basef32[slot], basef32[slot + 1]);\n            },\n            vec3: function setVec3(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform3f(loc, basef32[slot], basef32[slot + 1], basef32[slot + 2]);\n            },\n            vec4: function setVec4(self, loc, off) {\n                const slot = off >> 2;\n                const basef32 = self.basef32;\n                self.gl.uniform4f(loc, basef32[slot], basef32[slot + 1], basef32[slot + 2], basef32[slot + 3]);\n            },\n            mat2: function setMat2(self, loc, off) {\n                self.gl.uniformMatrix2fv(loc, false, new Float32Array(self.memory.buffer, off, 4));\n            },\n            mat3: function setMat3(self, loc, off) {\n                self.gl.uniformMatrix3fv(loc, false, new Float32Array(self.memory.buffer, off, 9));\n            },\n            mat4: function setMat4(self, loc, off) {\n                const mat4 = new Float32Array(self.memory.buffer, off, 16);\n                self.gl.uniformMatrix4fv(loc, false, mat4);\n            },\n        };\n        // Array of function id's wasm can call on us; `self` is pointer to WebGLRenderer.\n        // Function names are suffixed with the index in the array, and annotated with\n        // their name in cx_webgl.rs, for easier matching.\n        this.sendFnTable = [\n            // end\n            function end0(_self) {\n                return true;\n            },\n            // compile_webgl_shader\n            function compileWebGLShader1(self) {\n                function parseShvarvec() {\n                    const len = self.zerdeParser.parseU32();\n                    const vars = [];\n                    for (let i = 0; i < len; i++) {\n                        vars.push({\n                            ty: self.zerdeParser.parseString(),\n                            name: self.zerdeParser.parseString(),\n                        });\n                    }\n                    return vars;\n                }\n                const ash = {\n                    shaderId: self.zerdeParser.parseU32(),\n                    fragment: self.zerdeParser.parseString(),\n                    vertex: self.zerdeParser.parseString(),\n                    geometrySlots: self.zerdeParser.parseU32(),\n                    instanceSlots: self.zerdeParser.parseU32(),\n                    passUniforms: parseShvarvec(),\n                    viewUniforms: parseShvarvec(),\n                    drawUniforms: parseShvarvec(),\n                    userUniforms: parseShvarvec(),\n                    textureSlots: parseShvarvec(),\n                };\n                self.compileWebGLShader(ash);\n            },\n            // alloc_array_buffer\n            function allocArrayBuffer2(self) {\n                const arrayBufferId = self.zerdeParser.parseU32();\n                const len = self.zerdeParser.parseU32();\n                const pointer = self.zerdeParser.parseU32();\n                const array = new Float32Array(self.memory.buffer, pointer, len);\n                self.allocArrayBuffer(arrayBufferId, array);\n            },\n            // alloc_index_buffer\n            function allocIndexBuffer3(self) {\n                const indexBufferId = self.zerdeParser.parseU32();\n                const len = self.zerdeParser.parseU32();\n                const pointer = self.zerdeParser.parseU32();\n                const array = new Uint32Array(self.memory.buffer, pointer, len);\n                self.allocIndexBuffer(indexBufferId, array);\n            },\n            // alloc_vao\n            function allocVao4(self) {\n                const vaoId = self.zerdeParser.parseU32();\n                const shaderId = self.zerdeParser.parseU32();\n                const geomIbId = self.zerdeParser.parseU32();\n                const geomVbId = self.zerdeParser.parseU32();\n                const instVbId = self.zerdeParser.parseU32();\n                self.allocVao(vaoId, shaderId, geomIbId, geomVbId, instVbId);\n            },\n            // draw_call\n            function drawCall5(self) {\n                const shaderId = self.zerdeParser.parseU32();\n                const vaoId = self.zerdeParser.parseU32();\n                const uniformsPassPtr = self.zerdeParser.parseU32();\n                const uniformsViewPtr = self.zerdeParser.parseU32();\n                const uniformsDrawPtr = self.zerdeParser.parseU32();\n                const uniformsUserPtr = self.zerdeParser.parseU32();\n                const textures = self.zerdeParser.parseU32();\n                self.drawCall(shaderId, vaoId, uniformsPassPtr, uniformsViewPtr, uniformsDrawPtr, uniformsUserPtr, textures);\n            },\n            // update_texture_image2d\n            function allocTexture6(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const width = self.zerdeParser.parseU32();\n                const height = self.zerdeParser.parseU32();\n                const dataPtr = self.zerdeParser.parseU32();\n                self.allocTexture(textureId, width, height, dataPtr);\n            },\n            // begin_render_targets\n            function beginRenderTargets7(self) {\n                const passId = self.zerdeParser.parseU32();\n                const width = self.zerdeParser.parseU32();\n                const height = self.zerdeParser.parseU32();\n                self.beginRenderTargets(passId, width, height);\n            },\n            // add_color_target\n            function addColorTarget8(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const initOnly = self.zerdeParser.parseU32();\n                const r = self.zerdeParser.parseF32();\n                const g = self.zerdeParser.parseF32();\n                const b = self.zerdeParser.parseF32();\n                const a = self.zerdeParser.parseF32();\n                self.addColorTarget(textureId, initOnly, r, g, b, a);\n            },\n            // set_depth_target\n            function setDepthTarget9(self) {\n                const textureId = self.zerdeParser.parseU32();\n                const initOnly = self.zerdeParser.parseU32();\n                const depth = self.zerdeParser.parseF32();\n                self.setDepthTarget(textureId, initOnly, depth);\n            },\n            // end_render_targets\n            function endRenderTargets10(self) {\n                self.endRenderTargets();\n            },\n            // set_default_depth_and_blend_mode\n            function setDefaultDepthAndBlendMode11(self) {\n                self.setDefaultDepthAndBlendMode();\n            },\n            // begin_main_canvas\n            function beginMainCanvas12(self) {\n                const r = self.zerdeParser.parseF32();\n                const g = self.zerdeParser.parseF32();\n                const b = self.zerdeParser.parseF32();\n                const a = self.zerdeParser.parseF32();\n                const depth = self.zerdeParser.parseF32();\n                self.beginMainCanvas(r, g, b, a, depth);\n            },\n        ];\n        this.canvas = canvas;\n        this.memory = memory;\n        this.sizingData = sizingData;\n        this.shaders = [];\n        this.indexBuffers = [];\n        this.arrayBuffers = [];\n        this.vaos = [];\n        this.textures = [];\n        this.framebuffers = [];\n        this.targetWidth = 0;\n        this.targetHeight = 0;\n        this.clearFlags = 0;\n        this.clearR = 0;\n        this.clearG = 0;\n        this.clearB = 0;\n        this.clearA = 0;\n        this.clearDepth = 0;\n        // this.isMainCanvas = false;\n        const options = {\n            preferLowPowerToHighPerformance: true,\n            // xrCompatible: true // TODO(JP): Bring back some day?\n        };\n        // @ts-ignore - TODO(Paras): Get proper support for OffscreenCanvas\n        this.gl =\n            // @ts-ignore\n            canvas.getContext(\"webgl\", options) ||\n                // @ts-ignore\n                canvas.getContext(\"webgl-experimental\", options) ||\n                // @ts-ignore\n                canvas.getContext(\"experimental-webgl\", options);\n        if (!this.gl) {\n            incompatibleBrowserCallback();\n            return;\n        }\n        this.OESVertexArrayObject = assertNotNull(this.gl.getExtension(\"OES_vertex_array_object\"));\n        this.ANGLEInstancedArrays = assertNotNull(this.gl.getExtension(\"ANGLE_instanced_arrays\"));\n        this.gl.getExtension(\"OES_standard_derivatives\");\n        this.gl.getExtension(\"OES_element_index_uint\");\n        this.resize(sizingData);\n    }\n    processMessages(zerdeParserPtr) {\n        this.zerdeParser = new ZerdeParser(this.memory, zerdeParserPtr);\n        this.basef32 = new Float32Array(this.memory.buffer);\n        this.baseu32 = new Uint32Array(this.memory.buffer);\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const msgType = this.zerdeParser.parseU32();\n            if (this.sendFnTable[msgType](this)) {\n                break;\n            }\n        }\n    }\n    resize(sizingData) {\n        this.sizingData = sizingData;\n        this.canvas.width = sizingData.width * sizingData.dpiFactor;\n        this.canvas.height = sizingData.height * sizingData.dpiFactor;\n    }\n    getAttribLocations(program, base, slots) {\n        const gl = this.gl;\n        const attribLocs = [];\n        let attribs = slots >> 2;\n        if ((slots & 3) != 0)\n            attribs++;\n        for (let i = 0; i < attribs; i++) {\n            let size = slots - i * 4;\n            if (size > 4)\n                size = 4;\n            attribLocs.push({\n                loc: gl.getAttribLocation(program, base + i),\n                offset: i * 16,\n                size: size,\n                stride: slots * 4,\n            });\n        }\n        return attribLocs;\n    }\n    getUniformLocations(program, uniforms) {\n        const gl = this.gl;\n        const uniformLocs = [];\n        let offset = 0;\n        for (let i = 0; i < uniforms.length; i++) {\n            const uniform = uniforms[i];\n            // lets align the uniform\n            const slots = uniformSizeTable[uniform.ty];\n            if ((offset & 3) != 0 && (offset & 3) + slots > 4) {\n                // goes over the boundary\n                offset += 4 - (offset & 3); // make jump to new slot\n            }\n            uniformLocs.push({\n                name: uniform.name,\n                offset: offset << 2,\n                ty: uniform.ty,\n                loc: gl.getUniformLocation(program, uniform.name),\n                fn: this.uniformFnTable[uniform.ty],\n            });\n            offset += slots;\n        }\n        return uniformLocs;\n    }\n    compileWebGLShader(ash) {\n        const gl = this.gl;\n        const vsh = assertNotNull(gl.createShader(gl.VERTEX_SHADER));\n        gl.shaderSource(vsh, ash.vertex);\n        gl.compileShader(vsh);\n        if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {\n            console.log(gl.getShaderInfoLog(vsh), addLineNumbersToString(ash.vertex));\n        }\n        // compile pixelshader\n        const fsh = assertNotNull(gl.createShader(gl.FRAGMENT_SHADER));\n        gl.shaderSource(fsh, ash.fragment);\n        gl.compileShader(fsh);\n        if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {\n            console.log(gl.getShaderInfoLog(fsh), addLineNumbersToString(ash.fragment));\n        }\n        const program = assertNotNull(gl.createProgram());\n        gl.attachShader(program, vsh);\n        gl.attachShader(program, fsh);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            console.log(gl.getProgramInfoLog(program), addLineNumbersToString(ash.vertex), addLineNumbersToString(ash.fragment));\n        }\n        // fetch all attribs and uniforms\n        this.shaders[ash.shaderId] = {\n            geomAttribs: this.getAttribLocations(program, \"mpsc_packed_geometry_\", ash.geometrySlots),\n            instAttribs: this.getAttribLocations(program, \"mpsc_packed_instance_\", ash.instanceSlots),\n            passUniforms: this.getUniformLocations(program, ash.passUniforms),\n            viewUniforms: this.getUniformLocations(program, ash.viewUniforms),\n            drawUniforms: this.getUniformLocations(program, ash.drawUniforms),\n            userUniforms: this.getUniformLocations(program, ash.userUniforms),\n            textureSlots: this.getUniformLocations(program, ash.textureSlots),\n            instanceSlots: ash.instanceSlots,\n            program: program,\n            ash: ash,\n        };\n    }\n    allocArrayBuffer(arrayBufferId, array) {\n        const gl = this.gl;\n        let buf = this.arrayBuffers[arrayBufferId];\n        if (buf === undefined) {\n            buf = this.arrayBuffers[arrayBufferId] = {\n                glBuf: assertNotNull(gl.createBuffer()),\n                length: array.length,\n            };\n        }\n        else {\n            buf.length = array.length;\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, buf.glBuf);\n        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n    allocIndexBuffer(indexBufferId, array) {\n        const gl = this.gl;\n        let buf = this.indexBuffers[indexBufferId];\n        if (buf === undefined) {\n            buf = this.indexBuffers[indexBufferId] = {\n                glBuf: assertNotNull(gl.createBuffer()),\n                length: array.length,\n            };\n        }\n        else {\n            buf.length = array.length;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.glBuf);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    allocVao(vaoId, shaderId, geomIbId, geomVbId, instVbId) {\n        const gl = this.gl;\n        const oldVao = this.vaos[vaoId];\n        if (oldVao) {\n            this.OESVertexArrayObject.deleteVertexArrayOES(oldVao.glVao);\n        }\n        const glVao = assertNotNull(this.OESVertexArrayObject.createVertexArrayOES());\n        const vao = (this.vaos[vaoId] = { glVao, geomIbId, geomVbId, instVbId });\n        this.OESVertexArrayObject.bindVertexArrayOES(vao.glVao);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffers[geomVbId].glBuf);\n        const shader = this.shaders[shaderId];\n        for (let i = 0; i < shader.geomAttribs.length; i++) {\n            const attr = shader.geomAttribs[i];\n            if (attr.loc < 0) {\n                continue;\n            }\n            gl.vertexAttribPointer(attr.loc, attr.size, gl.FLOAT, false, attr.stride, attr.offset);\n            gl.enableVertexAttribArray(attr.loc);\n            this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(attr.loc, 0);\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffers[instVbId].glBuf);\n        for (let i = 0; i < shader.instAttribs.length; i++) {\n            const attr = shader.instAttribs[i];\n            if (attr.loc < 0) {\n                continue;\n            }\n            gl.vertexAttribPointer(attr.loc, attr.size, gl.FLOAT, false, attr.stride, attr.offset);\n            gl.enableVertexAttribArray(attr.loc);\n            this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(attr.loc, 1);\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffers[geomIbId].glBuf);\n        this.OESVertexArrayObject.bindVertexArrayOES(null);\n    }\n    drawCall(shaderId, vaoId, passUniformsPtr, viewUniformsPtr, drawUniformsPtr, userUniformsPtr, texturesPtr) {\n        const gl = this.gl;\n        const shader = this.shaders[shaderId];\n        gl.useProgram(shader.program);\n        const vao = this.vaos[vaoId];\n        this.OESVertexArrayObject.bindVertexArrayOES(vao.glVao);\n        const indexBuffer = this.indexBuffers[vao.geomIbId];\n        const instanceBuffer = this.arrayBuffers[vao.instVbId];\n        // set up uniforms TODO do this a bit more incremental based on uniform layer\n        // also possibly use webGL2 uniform buffers. For now this will suffice for webGL 1 compat\n        const passUniforms = shader.passUniforms;\n        // if vr_presenting\n        const viewUniforms = shader.viewUniforms;\n        for (let i = 0; i < viewUniforms.length; i++) {\n            const uni = viewUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + viewUniformsPtr);\n        }\n        const drawUniforms = shader.drawUniforms;\n        for (let i = 0; i < drawUniforms.length; i++) {\n            const uni = drawUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + drawUniformsPtr);\n        }\n        const userUniforms = shader.userUniforms;\n        for (let i = 0; i < userUniforms.length; i++) {\n            const uni = userUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + userUniformsPtr);\n        }\n        const textureSlots = shader.textureSlots;\n        for (let i = 0; i < textureSlots.length; i++) {\n            const texSlot = textureSlots[i];\n            const texId = this.baseu32[(texturesPtr >> 2) + i];\n            const texObj = this.textures[texId];\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, texObj);\n            gl.uniform1i(texSlot.loc, i);\n        }\n        const indices = indexBuffer.length;\n        const instances = instanceBuffer.length / shader.instanceSlots;\n        // if (this.isMainCanvas && xrIsPresenting) {\n        // for (let i = 3; i < pass_uniforms.length; i ++) {\n        //     let uni = pass_uniforms[i];\n        //     uni.fn(this, uni.loc, uni.offset + pass_uniforms_ptr);\n        // }\n        // // the first 2 matrices are project and view\n        // let left_viewport = this.xr_left_viewport;\n        // gl.viewport(left_viewport.x, left_viewport.y, left_viewport.width, left_viewport.height);\n        // gl.uniformMatrix4fv(pass_uniforms[0].loc, false, this.xr_left_projection_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[1].loc, false, this.xr_left_transform_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[2].loc, false, this.xr_left_invtransform_matrix);\n        // this.ANGLE_instanced_arrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // let right_viewport = this.xr_right_viewport;\n        // gl.viewport(right_viewport.x, right_viewport.y, right_viewport.width, right_viewport.height);\n        // gl.uniformMatrix4fv(pass_uniforms[0].loc, false, this.xr_right_projection_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[1].loc, false, this.xr_right_transform_matrix);\n        // gl.uniformMatrix4fv(pass_uniforms[2].loc, false, this.xr_right_invtransform_matrix);\n        // this.ANGLE_instanced_arrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // } else {\n        for (let i = 0; i < passUniforms.length; i++) {\n            const uni = passUniforms[i];\n            uni.fn(this, uni.loc, uni.offset + passUniformsPtr);\n        }\n        this.ANGLEInstancedArrays.drawElementsInstancedANGLE(gl.TRIANGLES, indices, gl.UNSIGNED_INT, 0, instances);\n        // }\n        this.OESVertexArrayObject.bindVertexArrayOES(null);\n    }\n    allocTexture(textureId, width, height, dataPtr) {\n        const gl = this.gl;\n        const glTex = this.textures[textureId] || gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, glTex);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        const data = new Uint8Array(this.memory.buffer, dataPtr, width * height * 4);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        this.textures[textureId] = glTex;\n    }\n    beginRenderTargets(passId, width, height) {\n        const gl = this.gl;\n        this.targetWidth = width;\n        this.targetHeight = height;\n        this.clearFlags = 0;\n        // this.isMainCanvas = false;\n        const glFramebuffer = this.framebuffers[passId] ||\n            (this.framebuffers[passId] = assertNotNull(gl.createFramebuffer()));\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glFramebuffer);\n    }\n    addColorTarget(textureId, initOnly, r, g, b, a) {\n        // if use_default\n        this.clearR = r;\n        this.clearG = g;\n        this.clearB = b;\n        this.clearA = a;\n        const gl = this.gl;\n        const glTex = this.textures[textureId] ||\n            (this.textures[textureId] = gl.createTexture());\n        // resize or create texture\n        if (glTex.mpWidth != this.targetWidth ||\n            glTex.mpHeight != this.targetHeight) {\n            gl.bindTexture(gl.TEXTURE_2D, glTex);\n            this.clearFlags |= gl.COLOR_BUFFER_BIT;\n            glTex.mpWidth = this.targetWidth;\n            glTex.mpHeight = this.targetHeight;\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, glTex.mpWidth, glTex.mpHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n        else if (!initOnly) {\n            this.clearFlags |= gl.COLOR_BUFFER_BIT;\n        }\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTex, 0);\n    }\n    setDepthTarget(textureId, initOnly, depth) {\n        const gl = this.gl;\n        this.clearDepth = depth;\n        const glRenderBuffer = this.textures[textureId] ||\n            (this.textures[textureId] = gl.createRenderbuffer());\n        if (glRenderBuffer.mpWidth != this.targetWidth ||\n            glRenderBuffer.mpHeight != this.targetHeight) {\n            // Borrowed concept from https://webglfundamentals.org/webgl/lessons/webgl-render-to-texture.html\n            gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderBuffer);\n            this.clearFlags |= gl.DEPTH_BUFFER_BIT;\n            glRenderBuffer.mpWidth = this.targetWidth;\n            glRenderBuffer.mpHeight = this.targetHeight;\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.targetWidth, this.targetHeight);\n        }\n        else if (!initOnly) {\n            this.clearFlags |= gl.DEPTH_BUFFER_BIT;\n        }\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, glRenderBuffer);\n    }\n    endRenderTargets() {\n        const gl = this.gl;\n        // process the actual 'clear'\n        gl.viewport(0, 0, this.targetWidth, this.targetHeight);\n        // check if we need to clear color, and depth\n        // clear it\n        if (this.clearFlags) {\n            gl.clearColor(this.clearR, this.clearG, this.clearB, this.clearA);\n            gl.clearDepth(this.clearDepth);\n            gl.clear(this.clearFlags);\n        }\n    }\n    setDefaultDepthAndBlendMode() {\n        const gl = this.gl;\n        gl.enable(gl.DEPTH_TEST);\n        gl.depthFunc(gl.LEQUAL);\n        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n    }\n    beginMainCanvas(r, g, b, a, depth) {\n        const gl = this.gl;\n        // this.isMainCanvas = true;\n        // if (this.xrIsPresenting) {\n        // let xr_webgllayer = this.xr_session.renderState.baseLayer;\n        // this.gl.bindFramebuffer(gl.FRAMEBUFFER, xr_webgllayer.framebuffer);\n        // gl.viewport(0, 0, xr_webgllayer.framebufferWidth, xr_webgllayer.framebufferHeight);\n        // // quest 1 is 3648\n        // // quest 2 is 4096\n        // let left_view = this.xr_pose.views[0];\n        // let right_view = this.xr_pose.views[1];\n        // this.xr_left_viewport = xr_webgllayer.getViewport(left_view);\n        // this.xr_right_viewport = xr_webgllayer.getViewport(right_view);\n        // this.xr_left_projection_matrix = left_view.projectionMatrix;\n        // this.xr_left_transform_matrix = left_view.transform.inverse.matrix;\n        // this.xr_left_invtransform_matrix = left_view.transform.matrix;\n        // this.xr_right_projection_matrix = right_view.projectionMatrix;\n        // this.xr_right_transform_matrix = right_view.transform.inverse.matrix;\n        // this.xr_right_camera_pos = right_view.transform.inverse.position;\n        // this.xr_right_invtransform_matrix = right_view.transform.matrix;\n        // } else {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, this.sizingData.width * this.sizingData.dpiFactor, this.sizingData.height * this.sizingData.dpiFactor);\n        // }\n        gl.clearColor(r, g, b, a);\n        gl.clearDepth(depth);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    }\n}\nconst uniformSizeTable = {\n    float: 1,\n    vec2: 2,\n    vec3: 3,\n    vec4: 4,\n    mat2: 4,\n    mat3: 9,\n    mat4: 16,\n};\nfunction addLineNumbersToString(code) {\n    const lines = code.split(\"\\n\");\n    let out = \"\";\n    for (let i = 0; i < lines.length; i++) {\n        out += i + 1 + \": \" + lines[i] + \"\\n\";\n    }\n    return out;\n}\n","export function addDefaultStyles() {\n    const style = document.createElement(\"style\");\n    style.innerHTML = `\n  * {\n    user-select: none;\n  }\n  html, body {\n    overflow: hidden;\n    background-color: #333;\n  }\n  body {\n    margin: 0;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n  }\n\n  #zaplib_js_root {\n    position: absolute; /* For z-index */\n    z-index: 0; /* New stacking context */\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    pointer-events: none;\n  }`;\n    document.body.appendChild(style);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// Import workers inline, so you can just include a single file \"wasm_runtime.js\"\n// without having to worry about having to serve multiple chunks.\n// @ts-ignore\nimport MainWorker from \"worker-loader?inline=no-fallback!./main_worker\";\n// @ts-ignore\nimport AsyncWorker from \"worker-loader?inline=no-fallback!./async_worker\";\n// @ts-ignore\nimport TaskWorker from \"worker-loader?inline=no-fallback!./task_worker\";\nimport { getZapBufferWasm, isZapBuffer, overwriteTypedArraysWithZapArrays, unregisterMutableBuffer, checkValidZapArray, } from \"./zap_buffer\";\nimport { assertNotNull, getZapParamType, initTaskWorkerSab, Rpc, transformParamsFromRustImpl, } from \"./common\";\nimport { makeTextarea } from \"./make_textarea\";\nimport { WebGLRenderer } from \"./webgl_renderer\";\nimport { makeRpcMouseEvent, makeRpcTouchEvent, makeRpcWheelEvent, } from \"./make_rpc_event\";\nimport { WorkerEvent, TaskWorkerEvent, AsyncWorkerEvent, } from \"./rpc_types\";\nimport { addLoadingIndicator, removeLoadingIndicator, } from \"./loading_indicator\";\nimport { addDefaultStyles } from \"./default_styles\";\nimport { inWorker } from \"./type_of_runtime\";\nconst jsFunctions = {};\n/// Users must call this function to register functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const registerCallJsCallbacks = (fns) => {\n    // Check that all new functions are unique\n    for (const key of Object.keys(fns)) {\n        if (key in jsFunctions) {\n            throw new Error(`Error: overwriting existing function \"${key}\" in window.jsFunctions`);\n        }\n    }\n    Object.assign(jsFunctions, fns);\n};\n/// Users must call this function to unregister functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const unregisterCallJsCallbacks = (fnNames) => {\n    for (const name of fnNames) {\n        // Check that functions are registered\n        if (!(name in jsFunctions)) {\n            throw new Error(`Error: unregistering non-existent function \"${name}\".`);\n        }\n        delete jsFunctions[name];\n    }\n};\nlet rpc;\nexport const newWorkerPort = () => {\n    const channel = new MessageChannel();\n    rpc.send(WorkerEvent.BindMainWorkerPort, channel.port1, [channel.port1]);\n    return channel.port2;\n};\nlet wasmMemory;\nconst destructor = (arcPtr) => {\n    rpc.send(WorkerEvent.DecrementArc, arcPtr);\n};\nconst mutableDestructor = (bufferData) => {\n    rpc.send(WorkerEvent.DeallocVec, bufferData);\n};\nconst transformParamsFromRust = (params) => transformParamsFromRustImpl(wasmMemory, destructor, mutableDestructor, params);\n// TODO(JP): Somewhat duplicated with the other implementation.\nconst temporarilyHeldBuffersForPostMessage = new Set();\nexport const serializeZapArrayForPostMessage = (zapArray) => {\n    if (!(typeof zapArray === \"object\" && isZapBuffer(zapArray.buffer))) {\n        throw new Error(\"Only pass Zap arrays to serializeZapArrayForPostMessage\");\n    }\n    const zapBuffer = zapArray.buffer;\n    if (zapBuffer.__zaplibBufferData.readonly) {\n        // Store the buffer temporarily until we've received confirmation that the Arc has been incremented.\n        // Otherwise it might get garbage collected and deallocated (if the Arc's count was 1) before it gets\n        // incremented.\n        temporarilyHeldBuffersForPostMessage.add(zapBuffer);\n        rpc\n            .send(WorkerEvent.IncrementArc, zapBuffer.__zaplibBufferData.arcPtr)\n            .then(() => {\n            temporarilyHeldBuffersForPostMessage.delete(zapBuffer);\n        });\n    }\n    else {\n        unregisterMutableBuffer(zapBuffer);\n    }\n    return {\n        bufferData: zapBuffer.__zaplibBufferData,\n        byteOffset: zapArray.byteOffset,\n        byteLength: zapArray.byteLength,\n    };\n};\nexport const callRust = (name, params = []) => __awaiter(void 0, void 0, void 0, function* () {\n    const transformedParams = params.map((param) => {\n        if (typeof param === \"string\") {\n            return param;\n        }\n        else if (isZapBuffer(param.buffer)) {\n            checkValidZapArray(param);\n            return serializeZapArrayForPostMessage(param);\n        }\n        else {\n            if (!(param.buffer instanceof SharedArrayBuffer)) {\n                console.warn(\"Consider passing Uint8Arrays backed by ZapBuffer or SharedArrayBuffer into `callRust` to prevent copying data\");\n            }\n            return param;\n        }\n    });\n    return transformParamsFromRust(yield rpc.send(WorkerEvent.CallRust, { name, params: transformedParams }));\n});\nexport const createMutableBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const bufferLen = data.byteLength;\n    const bufferPtr = yield rpc.send(WorkerEvent.CreateBuffer, data, [\n        data.buffer,\n    ]);\n    return transformParamsFromRust([\n        {\n            paramType: getZapParamType(data, false),\n            bufferPtr,\n            bufferLen,\n            bufferCap: bufferLen,\n            readonly: false,\n        },\n    ])[0];\n});\nexport const createReadOnlyBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const bufferLen = data.byteLength;\n    const { bufferPtr, arcPtr } = yield rpc.send(WorkerEvent.CreateReadOnlyBuffer, data, [data.buffer]);\n    return transformParamsFromRust([\n        {\n            paramType: getZapParamType(data, true),\n            bufferPtr,\n            bufferLen,\n            arcPtr,\n            readonly: true,\n        },\n    ])[0];\n});\nexport const deserializeZapArrayFromPostMessage = (postMessageData) => {\n    const zapBuffer = getZapBufferWasm(wasmMemory, postMessageData.bufferData, destructor, mutableDestructor);\n    return new Uint8Array(zapBuffer, postMessageData.byteOffset, postMessageData.byteLength);\n};\nexport const callRustInSameThreadSync = (name, _params = []) => {\n    throw new Error(\"`callRustInSameThreadSync` is currently not supported on the main thread in WASM\");\n};\nlet alreadyCalledInitialize = false;\nexport const initialize = (initParams) => {\n    if (alreadyCalledInitialize) {\n        throw new Error(\"Only call zaplib.initialize() once\");\n    }\n    alreadyCalledInitialize = true;\n    if (inWorker) {\n        throw new Error(\"zaplib.initialize() can only be called on the browser's main thread\");\n    }\n    overwriteTypedArraysWithZapArrays();\n    return new Promise((resolve) => {\n        var _a;\n        rpc = new Rpc(new MainWorker());\n        const baseUri = (_a = initParams.baseUri) !== null && _a !== void 0 ? _a : window.location.protocol + \"//\" + window.location.host + \"/\";\n        const wasmPath = new URL(initParams.filename, baseUri).href;\n        // Safari (as of version 15.2) needs the WebAssembly Module to be compiled on the browser's\n        // main thread. This also allows us to start compiling while still waiting for the DOM to load.\n        const wasmModulePromise = WebAssembly.compileStreaming(fetch(wasmPath));\n        // TODO(JP): These file handles are only sent to a worker when it starts running;\n        // it currently can't receive any file handles added after that.\n        const fileHandles = [];\n        const loader = () => {\n            const isMobileSafari = self.navigator.platform.match(/iPhone|iPad/i);\n            const isAndroid = self.navigator.userAgent.match(/Android/i);\n            if (initParams.defaultStyles) {\n                addDefaultStyles();\n                addLoadingIndicator();\n            }\n            let rpcInitialized = false;\n            rpc.receive(WorkerEvent.ShowIncompatibleBrowserNotification, () => {\n                const span = document.createElement(\"span\");\n                span.style.color = \"white\";\n                assertNotNull(canvas.parentNode).replaceChild(span, canvas);\n                span.innerHTML =\n                    \"Sorry, we need browser support for WebGL to run<br/>Please update your browser to a more modern one<br/>Update to at least iOS 10, Safari 10, latest Chrome, Edge or Firefox<br/>Go and update and come back, your browser will be better, faster and more secure!<br/>If you are using chrome on OSX on a 2011/2012 mac please enable your GPU at: Override software rendering list:Enable (the top item) in: <a href='about://flags'>about://flags</a>. Or switch to Firefox or Safari.\";\n            });\n            // TODO(JP): See if we can instead do this when we resolve the `initialize` Promise.\n            rpc.receive(WorkerEvent.RemoveLoadingIndicators, () => {\n                if (initParams.defaultStyles) {\n                    removeLoadingIndicator();\n                }\n            });\n            rpc.receive(WorkerEvent.SetDocumentTitle, (title) => {\n                document.title = title;\n            });\n            rpc.receive(WorkerEvent.SetMouseCursor, (style) => {\n                document.body.style.cursor = style;\n            });\n            rpc.receive(WorkerEvent.Fullscreen, () => {\n                if (document.body.requestFullscreen) {\n                    document.body.requestFullscreen();\n                }\n                else if (document.body.webkitRequestFullscreen) {\n                    document.body.webkitRequestFullscreen();\n                }\n                else if (document.body.mozRequestFullscreen) {\n                    document.body.mozRequestFullscreen();\n                }\n            });\n            rpc.receive(WorkerEvent.Normalscreen, () => {\n                if (document.exitFullscreen) {\n                    document.exitFullscreen();\n                }\n                else if (document.webkitExitFullscreen) {\n                    document.webkitExitFullscreen();\n                }\n                else if (document.mozExitFullscreen) {\n                    document.mozExitFullscreen();\n                }\n            });\n            rpc.receive(WorkerEvent.TextCopyResponse, (textCopyResponse) => {\n                window.navigator.clipboard.writeText(textCopyResponse);\n            });\n            rpc.receive(WorkerEvent.EnableGlobalFileDropTarget, () => {\n                document.addEventListener(\"dragenter\", (ev) => {\n                    const dataTransfer = ev.dataTransfer;\n                    // dataTransfer isn't guaranteed to exist by spec, so it must be checked\n                    if (dataTransfer &&\n                        dataTransfer.types.length === 1 &&\n                        dataTransfer.types[0] === \"Files\") {\n                        ev.stopPropagation();\n                        ev.preventDefault();\n                        dataTransfer.dropEffect = \"copy\";\n                        if (rpcInitialized)\n                            rpc.send(WorkerEvent.DragEnter);\n                    }\n                });\n                document.addEventListener(\"dragover\", (ev) => {\n                    ev.stopPropagation();\n                    ev.preventDefault();\n                    if (rpcInitialized)\n                        rpc.send(WorkerEvent.DragOver, { x: ev.clientX, y: ev.clientY });\n                });\n                document.addEventListener(\"dragleave\", (ev) => {\n                    ev.stopPropagation();\n                    ev.preventDefault();\n                    if (rpcInitialized)\n                        rpc.send(WorkerEvent.DragLeave);\n                });\n                document.addEventListener(\"drop\", (ev) => {\n                    if (!ev.dataTransfer) {\n                        return;\n                    }\n                    const files = Array.from(ev.dataTransfer.files);\n                    if (!files.length) {\n                        return;\n                    }\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                    const fileHandlesToSend = [];\n                    for (const file of files) {\n                        const fileHandle = {\n                            id: fileHandles.length,\n                            basename: file.name,\n                            file,\n                            lastReadStart: -1,\n                            lastReadEnd: -1,\n                        };\n                        fileHandlesToSend.push(fileHandle);\n                        fileHandles.push(fileHandle);\n                    }\n                    if (rpcInitialized) {\n                        rpc.send(WorkerEvent.Drop, { fileHandles, fileHandlesToSend });\n                    }\n                });\n            });\n            rpc.receive(WorkerEvent.CallJs, ({ fnName, params }) => {\n                const fn = jsFunctions[fnName];\n                if (!fn) {\n                    console.error(`call_js with ${fnName} is not available. Have you registered it using \\`registerCallJsCallbacks\\`?`);\n                    return;\n                }\n                fn(transformParamsFromRust(params));\n            });\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"zaplib_canvas\";\n            document.body.appendChild(canvas);\n            document.addEventListener(\"contextmenu\", (event) => {\n                var _a;\n                if (event.target instanceof Element &&\n                    !((_a = document.getElementById(\"zaplib_js_root\")) === null || _a === void 0 ? void 0 : _a.contains(event.target))) {\n                    event.preventDefault();\n                }\n            });\n            document.addEventListener(\"mousedown\", (event) => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.CanvasMouseDown, makeRpcMouseEvent(event));\n            });\n            window.addEventListener(\"mouseup\", (event) => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowMouseUp, makeRpcMouseEvent(event));\n            });\n            window.addEventListener(\"mousemove\", (event) => {\n                document.body.scrollTop = 0;\n                document.body.scrollLeft = 0;\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowMouseMove, makeRpcMouseEvent(event));\n            });\n            window.addEventListener(\"mouseout\", (event) => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowMouseOut, makeRpcMouseEvent(event));\n            });\n            document.addEventListener(\"touchstart\", (event) => {\n                event.preventDefault();\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowTouchStart, makeRpcTouchEvent(event));\n            }, { passive: false });\n            window.addEventListener(\"touchmove\", (event) => {\n                event.preventDefault();\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowTouchMove, makeRpcTouchEvent(event));\n            }, { passive: false });\n            const touchEndCancelLeave = (event) => {\n                event.preventDefault();\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowTouchEndCancelLeave, makeRpcTouchEvent(event));\n            };\n            window.addEventListener(\"touchend\", touchEndCancelLeave);\n            window.addEventListener(\"touchcancel\", touchEndCancelLeave);\n            document.addEventListener(\"wheel\", (event) => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.CanvasWheel, makeRpcWheelEvent(event));\n            });\n            window.addEventListener(\"focus\", () => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowFocus);\n            });\n            window.addEventListener(\"blur\", () => {\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.WindowBlur);\n            });\n            if (!isMobileSafari && !isAndroid) {\n                // mobile keyboards are unusable on a UI like this\n                const { showTextIME } = makeTextarea((taEvent) => {\n                    if (rpcInitialized)\n                        rpc.send(taEvent.type, taEvent);\n                });\n                rpc.receive(WorkerEvent.ShowTextIME, showTextIME);\n            }\n            // One of these variables should get set, depending on if\n            // the browser supports OffscreenCanvas or not.\n            let offscreenCanvas;\n            let webglRenderer;\n            function getSizingData() {\n                const canFullscreen = !!(document.fullscreenEnabled ||\n                    document.webkitFullscreenEnabled ||\n                    document.mozFullscreenEnabled);\n                const isFullscreen = !!(document.fullscreenElement ||\n                    document.webkitFullscreenElement ||\n                    document.mozFullscreenElement);\n                return {\n                    width: canvas.offsetWidth,\n                    height: canvas.offsetHeight,\n                    dpiFactor: window.devicePixelRatio,\n                    canFullscreen,\n                    isFullscreen,\n                };\n            }\n            function onScreenResize() {\n                // TODO(JP): Some day bring this back?\n                // if (is_add_to_homescreen_safari) { // extremely ugly. but whatever.\n                //     if (window.orientation == 90 || window.orientation == -90) {\n                //         h = screen.width;\n                //         w = screen.height - 90;\n                //     }\n                //     else {\n                //         w = screen.width;\n                //         h = screen.height - 80;\n                //     }\n                // }\n                const sizingData = getSizingData();\n                if (webglRenderer) {\n                    webglRenderer.resize(sizingData);\n                }\n                if (rpcInitialized)\n                    rpc.send(WorkerEvent.ScreenResize, sizingData);\n            }\n            window.addEventListener(\"resize\", () => onScreenResize());\n            window.addEventListener(\"orientationchange\", () => onScreenResize());\n            let dpiFactor = window.devicePixelRatio;\n            const mqString = \"(resolution: \" + window.devicePixelRatio + \"dppx)\";\n            const mq = matchMedia(mqString);\n            if (mq && mq.addEventListener) {\n                mq.addEventListener(\"change\", () => onScreenResize());\n            }\n            else {\n                // poll for it. yes. its terrible\n                self.setInterval(() => {\n                    if (window.devicePixelRatio != dpiFactor) {\n                        dpiFactor = window.devicePixelRatio;\n                        onScreenResize();\n                    }\n                }, 1000);\n            }\n            // Some browsers (e.g. Safari 15.2) require SharedArrayBuffers to be initialized\n            // on the browser's main thread; so that's why this has to happen here.\n            //\n            // We also do this before initializing `WebAssembly.Memory`, to make sure we have\n            // enough memory for both.. (This is mostly relevant on mobile; see note below.)\n            const taskWorkerSab = initTaskWorkerSab();\n            const taskWorkerRpc = new Rpc(new TaskWorker());\n            taskWorkerRpc.send(TaskWorkerEvent.Init, {\n                taskWorkerSab,\n                wasmMemory,\n            });\n            // Initial has to be equal to or higher than required by the app (which at the time of writing\n            // is around 20 pages).\n            // Maximum has to be equal to or lower than that of the app, which we've currently set to\n            // the maximum for wasm32 (4GB). Browsers should use virtual memory, as to not actually take up\n            // all this space until requested by the app. TODO(JP): We might need to check this behavior in\n            // different browsers at some point (in Chrome it seems to work fine).\n            //\n            // In Safari on my phone (JP), using maximum:65535 causes an out-of-memory error, so we instead\n            // try a hardcoded value of ~400MB.. Note that especially on mobile, all of\n            // this is quite tricky; see e.g. https://github.com/WebAssembly/design/issues/1397\n            //\n            // TODO(JP): It looks like when using shared memory, the maximum might get fully allocated on\n            // some devices (mobile?), which means that there is little room left for JS objects, and it\n            // means that the web page is at higher risk of getting evicted when switching tabs. There are a\n            // few options here:\n            // 1. Allow the user to specify a maximum by hand for mobile in general; or for specific\n            //    devices (cumbersome!).\n            // 2. Allow single-threaded operation, where we don't specify a maximum (but run the risk of\n            //    getting much less memory to use and therefore the app crashing; see again\n            //    https://github.com/WebAssembly/design/issues/1397 for more details).\n            try {\n                wasmMemory = new WebAssembly.Memory({\n                    initial: 40,\n                    maximum: 65535,\n                    shared: true,\n                });\n            }\n            catch (_) {\n                console.log(\"Can't allocate full WebAssembly memory; trying ~400MB\");\n                try {\n                    wasmMemory = new WebAssembly.Memory({\n                        initial: 40,\n                        maximum: 6000,\n                        shared: true,\n                    });\n                }\n                catch (_) {\n                    throw new Error(\"Can't initilialize WebAssembly memory..\");\n                }\n            }\n            // If the browser supports OffscreenCanvas, then we'll use that. Otherwise, we render on\n            // the browser's main thread using WebGLRenderer.\n            try {\n                offscreenCanvas = canvas.transferControlToOffscreen();\n            }\n            catch (_) {\n                webglRenderer = new WebGLRenderer(canvas, wasmMemory, getSizingData(), () => {\n                    rpc.send(WorkerEvent.ShowIncompatibleBrowserNotification);\n                });\n                rpc.receive(WorkerEvent.RunWebGL, (zerdeParserPtr) => {\n                    webglRenderer.processMessages(zerdeParserPtr);\n                    return new Promise((resolve) => {\n                        requestAnimationFrame(() => {\n                            resolve(undefined);\n                        });\n                    });\n                });\n            }\n            wasmModulePromise.then((wasmModule) => {\n                // Threads need to be spawned on the browser's main thread, otherwise Safari (as of version 15.2)\n                // throws errors.\n                const asyncWorkers = new Set();\n                const threadSpawn = ({ ctxPtr, tlsAndStackData, }) => {\n                    const worker = new AsyncWorker();\n                    const workerErrorHandler = (event) => {\n                        console.log(\"Async worker error event: \", event);\n                    };\n                    worker.onerror = workerErrorHandler;\n                    worker.onmessageerror = workerErrorHandler;\n                    const workerRpc = new Rpc(worker);\n                    // Add the worker to an array of workers, to prevent them getting killed when\n                    // during garbage collection in Firefox; see https://bugzilla.mozilla.org/show_bug.cgi?id=1592227\n                    asyncWorkers.add(worker);\n                    const channel = new MessageChannel();\n                    rpc.send(WorkerEvent.BindMainWorkerPort, channel.port1, [\n                        channel.port1,\n                    ]);\n                    workerRpc.receive(AsyncWorkerEvent.ThreadSpawn, threadSpawn);\n                    workerRpc\n                        .send(AsyncWorkerEvent.Run, {\n                        wasmModule,\n                        memory: wasmMemory,\n                        taskWorkerSab,\n                        ctxPtr,\n                        fileHandles,\n                        baseUri,\n                        tlsAndStackData,\n                        mainWorkerPort: channel.port2,\n                    }, [channel.port2])\n                        .catch((e) => {\n                        console.error(\"async worker failed\", e);\n                    })\n                        .finally(() => {\n                        worker.terminate();\n                        asyncWorkers.delete(worker);\n                    });\n                };\n                rpc.receive(WorkerEvent.ThreadSpawn, threadSpawn);\n                rpc\n                    .send(WorkerEvent.Init, {\n                    wasmModule,\n                    offscreenCanvas,\n                    sizingData: getSizingData(),\n                    baseUri,\n                    memory: wasmMemory,\n                    taskWorkerSab,\n                }, offscreenCanvas ? [offscreenCanvas] : [])\n                    .then(() => {\n                    rpcInitialized = true;\n                    onScreenResize();\n                    resolve();\n                });\n            });\n        };\n        if (document.readyState !== \"loading\") {\n            loader();\n        }\n        else {\n            document.addEventListener(\"DOMContentLoaded\", loader);\n        }\n    });\n};\n","import { assertNotNull } from \"./common\";\nexport function addLoadingIndicator() {\n    const style = document.createElement(\"style\");\n    style.innerHTML = `\n    .zaplib_loading_indicator {\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        color: #666;\n        font-size: 40px;\n    }\n    .zaplib_loading_indicator > span {\n        display: inline-block;\n        animation-name: wiggle;\n        animation-duration: 1000ms;\n        animation-iteration-count: infinite;\n        animation-timing-function: ease-in-out;\n    }\n    @keyframes wiggle {\n        0% {transform: rotate(0deg);}\n        10% {transform: rotate(10deg);}\n        30% {transform: rotate(-10deg);}\n        50% {transform: rotate(20deg);}\n        70% {transform: rotate(-5deg);}\n        90% {transform: rotate(2deg);}\n        95% {transform: rotate(0deg);}\n    }\n\n    .zaplib_loading_indicator > div {\n        position: absolute;\n        width: max-content;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, 40px);\n        font-family: Verdana, Arial Black;\n        font-weight: bold;\n        font-size: 28px;\n\n        background: #222 -webkit-gradient(linear, left top, right top, from(#222), to(#222), color-stop(0.5, #fff)) 0 0 no-repeat;\n        background-image: -webkit-linear-gradient(-40deg, transparent 0%, transparent 40%, #fff 50%, transparent 60%, transparent 100%);\n        background-size: 200px;\n        -webkit-background-clip: text;\n        background-clip: text;\n        animation-name: shine;\n        animation-duration: 1s;\n        animation-iteration-count: infinite;\n        text-shadow: 0 0px 0px rgba(255, 255, 255, 0.5);\n    }\n    @keyframes shine {\n        0% {\n            background-position: -200px 0;\n        }\n        100% {\n            background-position: 250px 0;\n        }\n    }`;\n    document.body.appendChild(style);\n    const loadingIndicator = document.createElement(\"div\");\n    loadingIndicator.className = \"zaplib_loading_indicator\";\n    loadingIndicator.innerHTML =\n        '<span>⚡</span><div style=\"color: rgba(255, 202, 0, 0.5);\">Loading…</div>';\n    document.body.appendChild(loadingIndicator);\n}\nexport function removeLoadingIndicator() {\n    const loaders = document.getElementsByClassName(\"zaplib_loading_indicator\");\n    for (let i = 0; i < loaders.length; i++) {\n        assertNotNull(loaders[i].parentNode).removeChild(loaders[i]);\n    }\n}\n","// Be sure to keep this in sync with cursor.rs!\nexport const cursorMap = [\n    \"none\",\n    \"default\",\n    \"crosshair\",\n    \"pointer\",\n    \"default\",\n    \"move\",\n    \"text\",\n    \"wait\",\n    \"help\",\n    \"not-allowed\",\n    \"n-resize\",\n    \"ne-resize\",\n    \"e-resize\",\n    \"se-resize\",\n    \"s-resize\",\n    \"sw-resize\",\n    \"w-resize\",\n    \"nw-resize\",\n    \"ns-resize\",\n    \"nesw-resize\",\n    \"ew-resize\",\n    \"nwse-resize\",\n    \"col-resize\",\n    \"row-resize\", // RowResize=>23,\n];\n","export function packKeyModifier(e) {\n    return ((e.shiftKey ? 1 : 0) |\n        (e.ctrlKey ? 2 : 0) |\n        (e.altKey ? 4 : 0) |\n        (e.metaKey ? 8 : 0));\n}\nexport const zerdeKeyboardHandlers = {\n    keyDown(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(12);\n        zerdeBuilder.sendU32(data.event.keyCode);\n        zerdeBuilder.sendU32(data.event.repeat ? 1 : 0);\n        zerdeBuilder.sendU32(packKeyModifier(data.event));\n        zerdeBuilder.sendF64(performance.now() / 1000.0);\n    },\n    keyUp(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(13);\n        zerdeBuilder.sendU32(data.event.keyCode);\n        zerdeBuilder.sendU32(data.event.repeat ? 1 : 0);\n        zerdeBuilder.sendU32(packKeyModifier(data.event));\n        zerdeBuilder.sendF64(performance.now() / 1000.0);\n    },\n    textInput(zerdeBuilder, data) {\n        zerdeBuilder.sendU32(14);\n        zerdeBuilder.sendU32(data.wasPaste ? 1 : 0),\n            zerdeBuilder.sendU32(data.replaceLast ? 1 : 0),\n            zerdeBuilder.sendString(data.input);\n    },\n    textCopy(zerdeBuilder) {\n        zerdeBuilder.sendU32(17);\n    },\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { cursorMap } from \"./cursor_map\";\nimport { copyArrayToRustBuffer, getZapParamType } from \"./common\";\nimport { makeTextarea } from \"./make_textarea\";\nimport { ZapParamType, } from \"./types\";\nimport { getCachedZapBuffer, overwriteTypedArraysWithZapArrays, isZapBuffer, checkValidZapArray, getZapBufferCef, } from \"./zap_buffer\";\nimport { ZerdeBuilder } from \"./zerde\";\nimport { zerdeKeyboardHandlers } from \"./zerde_keyboard_handlers\";\nimport { WorkerEvent } from \"./rpc_types\";\nimport { addDefaultStyles } from \"./default_styles\";\nlet newCallbackId = 0;\n// keeping track of pending callbacks from rust side\nconst pendingCallbacks = {};\nconst transformParamsForRust = (params) => params.map((param) => {\n    if (typeof param === \"string\") {\n        return param;\n    }\n    else {\n        if (isZapBuffer(param.buffer)) {\n            checkValidZapArray(param);\n            const zapBuffer = param.buffer;\n            return [\n                zapBuffer.__zaplibWasmBuffer,\n                getZapParamType(param, zapBuffer.readonly),\n            ];\n        }\n        const paramType = getZapParamType(param, false);\n        const [cefBuffer] = window.cefCreateArrayBuffer(param.length, paramType);\n        // TODO(Dmitry): implement optimization to avoid copying when possible\n        copyArrayToRustBuffer(param, cefBuffer, 0);\n        return [cefBuffer, paramType];\n    }\n});\nexport const callRust = (name, params = []) => {\n    const callbackId = newCallbackId++;\n    const promise = new Promise((resolve, _reject) => {\n        pendingCallbacks[callbackId] = (data) => {\n            // TODO(Dmitry): implement retrun_error on rust side and use reject(...) to communicate the error\n            resolve(data);\n        };\n    });\n    window.cefCallRust(name, transformParamsForRust(params), callbackId);\n    return promise;\n};\nfunction _zaplibReturnParams(params) {\n    const callbackId = JSON.parse(params[0]);\n    pendingCallbacks[callbackId](params.slice(1));\n    delete pendingCallbacks[callbackId];\n}\n// Initial set of framework-specific functions\nconst fromCefJsFunctions = {\n    _zaplibReturnParams,\n};\n/// Users must call this function to register functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const registerCallJsCallbacks = (fns) => {\n    // Check that all new functions are unique\n    for (const key of Object.keys(fns)) {\n        if (key in fromCefJsFunctions) {\n            throw new Error(`Error: overwriting existing function \"${key}\"`);\n        }\n    }\n    Object.assign(fromCefJsFunctions, fns);\n    window.cefReadyForMessages();\n};\n/// Users must call this function to unregister functions as runnable from\n/// Rust via `[Cx::call_js]`.\nexport const unregisterCallJsCallbacks = (fnNames) => {\n    fnNames.forEach((name) => {\n        // Check that functions are registered\n        if (!(name in fromCefJsFunctions)) {\n            throw new Error(`Error: unregistering non-existent function \"${name}\"`);\n        }\n        delete fromCefJsFunctions[name];\n    });\n};\nconst transformReturnParams = (returnParams) => returnParams.map((param) => {\n    if (typeof param === \"string\") {\n        return param;\n    }\n    else {\n        const [buffer, arcPtr, paramType] = param;\n        const zapBuffer = getZapBufferCef(buffer, arcPtr, paramType);\n        if (paramType === ZapParamType.String) {\n            throw new Error(\"ZapParam buffer type called with string paramType\");\n        }\n        // These are actually ZapArray types, since we overwrite TypedArrays in overwriteTypedArraysWithZapArrays()\n        const ParamTypeToArrayConstructor = {\n            [ZapParamType.U8Buffer]: Uint8Array,\n            [ZapParamType.ReadOnlyU8Buffer]: Uint8Array,\n            [ZapParamType.F32Buffer]: Float32Array,\n            [ZapParamType.ReadOnlyF32Buffer]: Float32Array,\n        };\n        // Creating array with stable identity as that's what underlying underlying API expects\n        return getCachedZapBuffer(zapBuffer, new ParamTypeToArrayConstructor[paramType](zapBuffer));\n    }\n});\n// TODO(JP): Some of this code is duplicated with callRust/call_js; see if we can reuse some.\nexport const callRustInSameThreadSync = (name, params = []) => transformReturnParams(window.cefCallRustInSameThreadSync(name, transformParamsForRust(params)));\nexport const newWorkerPort = () => {\n    throw new Error(\"`newWorkerPort` is currently not supported on CEF\");\n};\nexport const serializeZapArrayForPostMessage = (_postMessageData) => {\n    throw new Error(\"`serializeZapArrayForPostMessage` is currently not supported on CEF\");\n};\nexport const deserializeZapArrayFromPostMessage = (_postMessageData) => {\n    throw new Error(\"`deserializeZapArrayFromPostMessage` is currently not supported on CEF\");\n};\nexport const initialize = (initParams) => new Promise((resolve) => {\n    overwriteTypedArraysWithZapArrays();\n    window.fromCefSetMouseCursor = (cursorId) => {\n        if (document.body) {\n            document.body.style.cursor = cursorMap[cursorId] || \"default\";\n        }\n    };\n    window.fromCefCallJsFunction = (name, params) => {\n        fromCefJsFunctions[name](transformReturnParams(params));\n    };\n    document.addEventListener(\"DOMContentLoaded\", () => {\n        if (initParams.defaultStyles) {\n            addDefaultStyles();\n        }\n        const { showTextIME, textareaHasFocus } = makeTextarea((taEvent) => {\n            const slots = 20;\n            const [buffer] = window.cefCreateArrayBuffer(slots * 4, ZapParamType.U8Buffer);\n            const zerdeBuilder = new ZerdeBuilder({\n                buffer,\n                byteOffset: 0,\n                slots,\n                growCallback: () => {\n                    throw new Error(\"Growing of this buffer is not supported\");\n                },\n            });\n            if (taEvent.type === WorkerEvent.KeyDown) {\n                zerdeKeyboardHandlers.keyDown(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === WorkerEvent.KeyUp) {\n                zerdeKeyboardHandlers.keyUp(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === WorkerEvent.TextInput) {\n                zerdeKeyboardHandlers.textInput(zerdeBuilder, taEvent);\n            }\n            else if (taEvent.type === WorkerEvent.TextCopy) {\n                zerdeKeyboardHandlers.textCopy(zerdeBuilder);\n            }\n            window.cefHandleKeyboardEvent(buffer);\n        });\n        window.fromCefSetIMEPosition = (x, y) => {\n            showTextIME({ x, y });\n        };\n        document.addEventListener(\"keydown\", (event) => {\n            const code = event.keyCode;\n            if (event.metaKey || event.ctrlKey) {\n                if (!textareaHasFocus()) {\n                    // TODO(JP): Maybe at some point we should use some library for these keycodes,\n                    // e.g. see https://stackoverflow.com/questions/1465374/event-keycode-constants\n                    if (code == 67 /* c */) {\n                        window.cefTriggerCopy();\n                    }\n                    else if (code == 88 /* x */) {\n                        window.cefTriggerCut();\n                    }\n                    else if (code == 65 /* a */) {\n                        window.cefTriggerSelectAll();\n                    }\n                }\n                // We want pastes to also be triggered when the textarea has focus, so we can\n                // handle the paste event in JS.\n                if (code == 86 /* v */) {\n                    window.cefTriggerPaste();\n                }\n            }\n        });\n        resolve();\n    });\n});\n// TODO(JP): See comment at CreateBuffer type.\nexport const createMutableBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const paramType = getZapParamType(data, false);\n    const [cefBuffer] = window.cefCreateArrayBuffer(data.length, paramType);\n    copyArrayToRustBuffer(data, cefBuffer, 0);\n    return transformReturnParams([\n        [cefBuffer, undefined, paramType],\n    ])[0];\n});\n// TODO(JP): See comment at CreateBuffer type.\nexport const createReadOnlyBuffer = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const paramType = getZapParamType(data, true);\n    const [cefBuffer, arcPtr] = window.cefCreateArrayBuffer(data.length, paramType);\n    copyArrayToRustBuffer(data, cefBuffer, 0);\n    return transformReturnParams([\n        [cefBuffer, arcPtr, paramType],\n    ])[0];\n});\n","\n      import API from \"!./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!./node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!./node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!./node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!./node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!./node_modules/css-loader/dist/cjs.js!./zaplib.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!./node_modules/css-loader/dist/cjs.js!./zaplib.css\";\n       export default content && content.locals ? content.locals : undefined;\n","// This is the universal Zaplib Runtime which will work on both CEF and WebAssembly environments,\n// doing runtime detection of which modules to load. No other file besides this one should conditionally\n// branch based on environments, such that cef/wasm runtimes can work without including unnecessary code.\nimport * as wasm from \"./wasm_runtime\";\nimport * as cef from \"./cef_runtime\";\nimport { jsRuntime } from \"./type_of_runtime\";\nimport \"./zaplib.css\";\nconst { initialize, newWorkerPort, registerCallJsCallbacks, unregisterCallJsCallbacks, callRust, serializeZapArrayForPostMessage, deserializeZapArrayFromPostMessage, callRustInSameThreadSync, createMutableBuffer, createReadOnlyBuffer, } = jsRuntime === \"cef\" ? cef : wasm;\nexport { initialize, newWorkerPort, registerCallJsCallbacks, unregisterCallJsCallbacks, callRust, serializeZapArrayForPostMessage, deserializeZapArrayFromPostMessage, callRustInSameThreadSync, jsRuntime, createMutableBuffer, createReadOnlyBuffer, };\n"],"names":["root","factory","exports","module","define","amd","self","___CSS_LOADER_EXPORT___","push","id","cssWithMappingToString","list","toString","this","map","item","content","needLayer","concat","length","join","i","modules","media","dedupe","supports","layer","undefined","alreadyImportedModules","k","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","data","sourceMapping","sourceURLs","sources","source","sourceRoot","stylesInDOM","getIndexByIdentifier","identifier","result","modulesToDom","options","idCountMap","identifiers","base","count","indexByIdentifier","obj","css","sourceMap","references","updater","addElementStyle","byIndex","splice","api","domAPI","update","newObj","remove","lastIdentifiers","newList","index","newLastIdentifiers","_i","_index","memo","insert","style","target","styleTarget","document","querySelector","window","HTMLIFrameElement","contentDocument","head","e","getTarget","Error","appendChild","element","createElement","setAttributes","attributes","styleElement","nonce","setAttribute","insertStyleElement","styleTagTransform","apply","parentNode","removeChild","removeStyleElement","styleSheet","cssText","firstChild","createTextNode","RESPONSE","ERROR","Rpc","constructor","channel","_messageId","_pendingCallbacks","_receivers","Map","_onChannelMessage","ev","topic","Promise","resolve","handler","get","then","postMessage","transferrables","message","catch","err","name","stack","_channel","onmessage","send","transfer","reject","info","error","receive","has","set","console","initTaskWorkerSab","taskWorkerSab","SharedArrayBuffer","taskWorkerSabi32","Int32Array","copyArrayToRustBuffer","inputBuffer","outputBuffer","outputPtr","getZapParamType","array","readonly","Uint8Array","Float32Array","transformParamsFromRustImpl","memory","destructor","mutableDestructor","params","param","zapBuffer","paramType","ArrayConstructor","bufferPtr","bufferLen","BYTES_PER_ELEMENT","assertNotNull","value","objectName","inTest","jsRuntime","inWorker","importScripts","ZapParamType","ZapBuffer","buffer","bufferData","super","__zaplibWasmBuffer","__zaplibBufferData","byteLength","slice","args","zapBufferExtends","cls","ZapTypedArray","Math","floor","__zaplibBuffer","subarray","begin","end","byteOffset","classesToExtend","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint16ClampedArray","Uint32Array","Float64Array","BigInt64Array","BigUint64Array","DataView","zapCls","Object","entries","containsZapBuffer","object","prototype","hasOwnProperty","call","Array","isArray","Set","entry","getPrototypeOf","patchPostMessage","origPostMessage","overwriteTypedArraysWithZapArrays","Worker","MessagePort","zapBufferCache","WeakMap","getCachedZapBuffer","fallbackArray","_a","isZapBuffer","potentialZapBuffer","checkValidZapArray","zapArray","bufferCache","allocatedArcs","allocatedVecs","bufferRegistry","FinalizationRegistry","arcPtr","mutableZapBufferRegistry","getZapBufferWasm","wasmMemory","deref","register","WeakRef","unregisterMutableBuffer","unregister","getZapBufferCef","bufferCap","ZerdeBuilder","slots","growCallback","_buffer","_byteOffset","_slots","_growCallback","_used","_updateRefs","_f32","_u32","_f64","_u64","BigInt","_fit","newSlots","max","newBytes","pos","sendF32","sendU32","sendF64","sendU64","sendString","str","charCodeAt","getData","ZerdeParser","zerdePtr","_memory","_usedSlots","parseU32","parseF32","parseF64","ret","parseU64","parseString","len","c","String","fromCharCode","parseU8Slice","u8Len","spare","u8Pos","u32","parseZapParams","workerConstructor","workerOptions","url","globalScope","blob","Blob","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","append","getBlob","URL","webkitURL","objectURL","createObjectURL","worker","revokeObjectURL","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","defineProperty","enumerable","prop","r","Symbol","toStringTag","Worker_fn","makeRpcMouseEvent","event","pageX","pageY","button","shiftKey","ctrlKey","metaKey","altKey","makeRpcTouchEvent","changedTouches","from","touch","makeRpcKeyboardEvent","keyCode","repeat","WorkerEvent","TaskWorkerEvent","AsyncWorkerEvent","MainWorkerChannelEvent","makeTextarea","callback","ta","textAreaPos","fixFocus","setTimeout","activeElement","getElementById","contains","focus","addEventListener","updateTextAreaPos","left","round","x","top","y","wasPaste","lastLen","uglyIMEHack","recreateTextarea","body","className","height","width","preventDefault","input","substring","type","TextInput","replaceLast","textValue","code","TextCopy","readOnly","KeyDown","KeyUp","showTextIME","textareaHasFocus","WebGLRenderer","canvas","sizingData","incompatibleBrowserCallback","uniformFnTable","float","loc","off","slot","gl","uniform1f","basef32","vec2","uniform2f","vec3","uniform3f","vec4","uniform4f","mat2","uniformMatrix2fv","mat3","uniformMatrix3fv","mat4","uniformMatrix4fv","sendFnTable","_self","parseShvarvec","zerdeParser","vars","ty","ash","shaderId","fragment","vertex","geometrySlots","instanceSlots","passUniforms","viewUniforms","drawUniforms","userUniforms","textureSlots","compileWebGLShader","arrayBufferId","pointer","allocArrayBuffer","indexBufferId","allocIndexBuffer","vaoId","geomIbId","geomVbId","instVbId","allocVao","uniformsPassPtr","uniformsViewPtr","uniformsDrawPtr","uniformsUserPtr","textures","drawCall","textureId","dataPtr","allocTexture","passId","beginRenderTargets","initOnly","g","b","addColorTarget","depth","setDepthTarget","endRenderTargets","setDefaultDepthAndBlendMode","beginMainCanvas","shaders","indexBuffers","arrayBuffers","vaos","framebuffers","targetWidth","targetHeight","clearFlags","clearR","clearG","clearB","clearA","clearDepth","preferLowPowerToHighPerformance","getContext","OESVertexArrayObject","getExtension","ANGLEInstancedArrays","resize","processMessages","zerdeParserPtr","baseu32","msgType","dpiFactor","getAttribLocations","program","attribLocs","attribs","size","getAttribLocation","offset","stride","getUniformLocations","uniforms","uniformLocs","uniform","uniformSizeTable","getUniformLocation","fn","vsh","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","log","getShaderInfoLog","addLineNumbersToString","fsh","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","geomAttribs","instAttribs","buf","glBuf","createBuffer","bindBuffer","ARRAY_BUFFER","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","oldVao","deleteVertexArrayOES","glVao","createVertexArrayOES","vao","bindVertexArrayOES","shader","attr","vertexAttribPointer","FLOAT","enableVertexAttribArray","vertexAttribDivisorANGLE","passUniformsPtr","viewUniformsPtr","drawUniformsPtr","userUniformsPtr","texturesPtr","useProgram","indexBuffer","instanceBuffer","uni","texSlot","texId","texObj","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","uniform1i","indices","instances","drawElementsInstancedANGLE","TRIANGLES","UNSIGNED_INT","glTex","createTexture","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","RGBA","UNSIGNED_BYTE","glFramebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","mpWidth","mpHeight","COLOR_BUFFER_BIT","framebufferTexture2D","COLOR_ATTACHMENT0","glRenderBuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","DEPTH_BUFFER_BIT","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","DEPTH_ATTACHMENT","viewport","clearColor","clear","enable","DEPTH_TEST","depthFunc","LEQUAL","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","ONE_MINUS_SRC_ALPHA","BLEND","lines","split","out","addDefaultStyles","innerHTML","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","done","jsFunctions","registerCallJsCallbacks","fns","keys","assign","unregisterCallJsCallbacks","fnNames","rpc","newWorkerPort","MessageChannel","BindMainWorkerPort","port1","port2","DecrementArc","DeallocVec","transformParamsFromRust","temporarilyHeldBuffersForPostMessage","serializeZapArrayForPostMessage","add","IncrementArc","delete","callRust","transformedParams","warn","CallRust","createMutableBuffer","CreateBuffer","createReadOnlyBuffer","CreateReadOnlyBuffer","deserializeZapArrayFromPostMessage","postMessageData","callRustInSameThreadSync","_params","alreadyCalledInitialize","initialize","initParams","baseUri","location","protocol","host","wasmPath","filename","href","wasmModulePromise","WebAssembly","compileStreaming","fetch","fileHandles","loader","isMobileSafari","navigator","platform","match","isAndroid","userAgent","defaultStyles","loadingIndicator","addLoadingIndicator","rpcInitialized","ShowIncompatibleBrowserNotification","span","color","replaceChild","RemoveLoadingIndicators","loaders","getElementsByClassName","removeLoadingIndicator","SetDocumentTitle","title","SetMouseCursor","cursor","Fullscreen","requestFullscreen","webkitRequestFullscreen","mozRequestFullscreen","Normalscreen","exitFullscreen","webkitExitFullscreen","mozExitFullscreen","TextCopyResponse","textCopyResponse","clipboard","writeText","EnableGlobalFileDropTarget","dataTransfer","types","stopPropagation","dropEffect","DragEnter","DragOver","clientX","clientY","DragLeave","files","fileHandlesToSend","file","fileHandle","basename","lastReadStart","lastReadEnd","Drop","CallJs","fnName","Element","CanvasMouseDown","WindowMouseUp","scrollTop","scrollLeft","WindowMouseMove","WindowMouseOut","WindowTouchStart","passive","WindowTouchMove","touchEndCancelLeave","WindowTouchEndCancelLeave","CanvasWheel","timeStamp","deltaMode","deltaX","deltaY","wheelDeltaY","makeRpcWheelEvent","WindowFocus","WindowBlur","taEvent","ShowTextIME","offscreenCanvas","webglRenderer","getSizingData","canFullscreen","fullscreenEnabled","webkitFullscreenEnabled","mozFullscreenEnabled","isFullscreen","fullscreenElement","webkitFullscreenElement","mozFullscreenElement","offsetWidth","offsetHeight","devicePixelRatio","onScreenResize","ScreenResize","mqString","mq","matchMedia","setInterval","Init","Memory","initial","maximum","shared","_","transferControlToOffscreen","RunWebGL","requestAnimationFrame","wasmModule","asyncWorkers","threadSpawn","ctxPtr","tlsAndStackData","workerErrorHandler","onerror","onmessageerror","workerRpc","ThreadSpawn","Run","mainWorkerPort","finally","terminate","readyState","cursorMap","packKeyModifier","zerdeKeyboardHandlers","keyDown","zerdeBuilder","performance","now","keyUp","textInput","textCopy","newCallbackId","pendingCallbacks","transformParamsForRust","cefBuffer","cefCreateArrayBuffer","callbackId","promise","_reject","cefCallRust","fromCefJsFunctions","_zaplibReturnParams","parse","cefReadyForMessages","forEach","transformReturnParams","returnParams","ParamTypeToArrayConstructor","cefCallRustInSameThreadSync","_postMessageData","fromCefSetMouseCursor","cursorId","fromCefCallJsFunction","cefHandleKeyboardEvent","fromCefSetIMEPosition","cefTriggerCopy","cefTriggerCut","cefTriggerSelectAll","cefTriggerPaste"],"sourceRoot":""}