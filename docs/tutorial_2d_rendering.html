<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tutorial: Rendering 2D Shapes - Zaplib docs</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="basic_tooling.html"><strong aria-hidden="true">3.</strong> Basic Tooling</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic APIs</li><li class="chapter-item expanded "><a href="tutorial_hello_world_console.html"><strong aria-hidden="true">4.</strong> Tutorial: Hello World Console</a></li><li class="chapter-item expanded "><a href="tutorial_hello_thread.html"><strong aria-hidden="true">5.</strong> Tutorial: Hello Thread, Hello File</a></li><li class="chapter-item expanded "><a href="basic_api_overview.html"><strong aria-hidden="true">6.</strong> API Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">JS-Rust Bridge</li><li class="chapter-item expanded "><a href="tutorial_js_rust_bridge.html"><strong aria-hidden="true">7.</strong> Tutorial: Integrating with JS</a></li><li class="chapter-item expanded "><a href="tutorial_sharing_data.html"><strong aria-hidden="true">8.</strong> Tutorial: Sharing Data</a></li><li class="chapter-item expanded "><a href="bridge_api.html"><strong aria-hidden="true">9.</strong> API Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bridge_api_basics.html"><strong aria-hidden="true">9.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="bridge_api_params.html"><strong aria-hidden="true">9.2.</strong> Types of Parameters</a></li><li class="chapter-item expanded "><a href="bridge_api_workers.html"><strong aria-hidden="true">9.3.</strong> Web Workers</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Rendering</li><li class="chapter-item expanded "><a href="tutorial_hello_world_canvas.html"><strong aria-hidden="true">10.</strong> Tutorial: Hello World Canvas</a></li><li class="chapter-item expanded "><a href="tutorial_2d_rendering.html" class="active"><strong aria-hidden="true">11.</strong> Tutorial: Rendering 2D Shapes</a></li><li class="chapter-item expanded "><a href="tutorial_3d_rendering.html"><strong aria-hidden="true">12.</strong> Tutorial: Rendering 3D Meshes</a></li><li class="chapter-item expanded "><a href="rendering_api_overview.html"><strong aria-hidden="true">13.</strong> API Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rendering_api_overview_model.html"><strong aria-hidden="true">13.1.</strong> Rendering model</a></li><li class="chapter-item expanded "><a href="rendering_api_events_overview.html"><strong aria-hidden="true">13.2.</strong> Events</a></li><li class="chapter-item expanded "><a href="rendering_api_overview_geometry.html"><strong aria-hidden="true">13.3.</strong> Geometry</a></li><li class="chapter-item expanded "><a href="rendering_api_shaders.html"><strong aria-hidden="true">13.4.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="rendering_api_drawing.html"><strong aria-hidden="true">13.5.</strong> Drawing</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">UI</li><li class="chapter-item expanded "><a href="tutorial_ui_components.html"><strong aria-hidden="true">14.</strong> Tutorial: UI Components</a></li><li class="chapter-item expanded "><a href="tutorial_ui_layout.html"><strong aria-hidden="true">15.</strong> Tutorial: UI Layout</a></li><li class="chapter-item expanded "><a href="ui_api_overview.html"><strong aria-hidden="true">16.</strong> API Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ui_api_overview_components.html"><strong aria-hidden="true">16.1.</strong> UI Components</a></li><li class="chapter-item expanded "><a href="ui_api_overview_layout.html"><strong aria-hidden="true">16.2.</strong> Layout</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="known_issues.html"><strong aria-hidden="true">17.</strong> Known Issues</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Zaplib docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tutorial-rendering-2d-shapes"><a class="header" href="#tutorial-rendering-2d-shapes">Tutorial: Rendering 2D Shapes</a></h1>
<p>Now that we've put <a href="./tutorial_hello_world.html">Hello World</a>] on the screen, let's draw some more interesting shapes.</p>
<h2 id="step-1-render-colored-rectangle"><a class="header" href="#step-1-render-colored-rectangle">Step 1: Render colored rectangle</a></h2>
<p>A shader is a type of program that runs on the GPU. Typically the process of rendering using shaders goes through multiple stages:</p>
<ul>
<li>Geometry Definition — defining the base geometry figure, which can be as simple as a rectangle or as complex as a teapot (which we'll look at in <a href="./tutorial_rendering.html">Tutorial: Rendering 3D Meshes</a>).</li>
<li>Vertex Shader — transforming the geometry's coordinates into screen coordinates.</li>
<li>Rasterization — determining which pixels are inside the figure.</li>
<li>Pixel Shader — computing the color of each pixel inside the rasterized figure.</li>
<li>Instancing — repeat the above process for multiple instances of the same geometry, with some different instance-specific variables each time (like color or position).</li>
</ul>
<p>See <a href="https://learnopengl.com/Getting-started/Hello-Triangle">Learn OpenGL</a> for an example how this works in OpenGL.</p>
<p>Now let's go through the process of creating our own shader using Zaplib. First, write a function that builds a geometry:</p>
<pre><code class="language-rust noplayground">fn build_geom() -&gt; Geometry {
    let vertex_attributes = vec![
        // top left vertex
        vec2(0., 0.),
        // top right vertex
        vec2(1., 0.),
        // bottom right vertex
        vec2(1., 1.),
        // bottom left vertex
        vec2(0., 1.),
    ];
    let indices = vec![
        // top-right triangle
        [0, 1, 2],
        // bottom-left triangle
        [2, 3, 0],
    ];
    Geometry::new(vertex_attributes, indices)
}
</code></pre>
<p>This function defines 2 adjacent triangles that form a rectangle.</p>
<p>Define a <code>SHADER</code> object:</p>
<pre><code class="language-rust noplayground">static SHADER: Shader = Shader {
    build_geom: Some(build_geom),
    code_to_concatenate: &amp;[
        Cx::STD_SHADER,
        code_fragment!(
            r#&quot;
            geometry geom: vec2;
            instance color: vec4;

            fn vertex() -&gt; vec4 {
                return vec4(geom.x, geom.y, 0., 1.);
            }

            fn pixel() -&gt; vec4 {
                return color;
            }
            &quot;#
        ),
    ],
    ..Shader::DEFAULT
};
</code></pre>
<ul>
<li><code>code_to_concatenate</code> is the custom code assigned to the shader. We add <code>Cx::STD_SHADER</code> as a first argument which is a standard library of shaders within Zaplib.</li>
<li><code>geometry</code> is a qualifier that defines the data passed from <code>build_geom</code> output. Since our <code>vertex_attributes</code> in <code>build_geom</code> consist of <code>Vec2</code> objects, we define it as such here.</li>
<li><code>instance</code> is a qualifier that defines an instance-specific variable — more about that later.</li>
<li><code>color</code> is used to define which color to use for rectangle.</li>
<li><code>fn vertex()</code> defines the vertex shader. This gets called for each vertex returned from <code>build_geom</code>, with <code>geom</code> getting set to the corresponding point. It returns <code>vec4(x, y, z, w)</code> where the values mean the following:
<ul>
<li><code>x, y</code> — coordinates on the screen (from -1 to 1).</li>
<li><code>z</code> — draw order (from 0 to 1). Draws with higher <code>z</code> will be on top.</li>
<li><code>w</code> — normalization parameter. Not very important for now, so we'll set it currently to 1.0.</li>
</ul>
</li>
<li><code>fn pixel()</code> defines the pixel shader. Since we are not drawing any special shapes yet, we'll set every pixel to the same color. The pixel shader is called once for each pixel in the output image.</li>
</ul>
<p>Define the struct to pass the color into the shader as an instance variable:</p>
<pre><code class="language-rust noplayground">#[derive(Clone)]
#[repr(C)]
struct RectIns {
    color: Vec4,
}
</code></pre>
<p>Now we can combine all of this together and use the following <code>draw</code> function in our application:</p>
<pre><code class="language-rust noplayground">    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
        self.view.begin_view(cx, LayoutSize::FILL);

        let color = vec4(1., 0., 0., 1.);
        cx.add_instances(&amp;SHADER, &amp;[RectIns { color }]);

        self.view.end_view(cx);
        self.pass.end_pass(cx);
        self.window.end_window(cx);
    }
</code></pre>
<ul>
<li><code>let color</code> defines the red color.</li>
<li><code>cx.add_instances</code> takes a shader and passes the <code>MyIns</code> data into it. Under the hood this creates a new &quot;draw call&quot;.</li>
</ul>
<p>You can run this full example with Cargo:</p>
<pre><code class="language-bash">cargo run -p tutorial_2d_rendering_step1
</code></pre>
<p><img src="./img/tutorial_2d_rendering_step1.png" alt="" /></p>
<p>Note: the coordinates of vertices returned from <code>vertex()</code> shader are in <code>[0; 1]</code> range, while the window canvas uses <code>[-1; 1]</code>. That's why we see a red rectangle covering only a quarter of the window. In the next section we'll see how to draw with pixel coordinates.</p>
<h2 id="step-2-render-multiple-bordered-rectangles"><a class="header" href="#step-2-render-multiple-bordered-rectangles">Step 2: Render multiple bordered rectangles</a></h2>
<p>Now let's modify our example to draw 2 bordered rectangles of the given sizes on top of each other.</p>
<p>Modify <code>RectIns</code> to include the top-left position of rectangle and its size:</p>
<pre><code class="language-rust noplayground">#[derive(Clone)]
#[repr(C)]
struct RectIns {
    color: Vec4,
    rect_pos: Vec2,
    rect_size: Vec2,
}
</code></pre>
<p>Update the shader code:</p>
<pre><code class="language-rust noplayground">            r#&quot;
            geometry geom: vec2;
            instance color: vec4;
            instance rect_pos: vec2;
            instance rect_size: vec2;
            varying pos: vec2;

            fn vertex() -&gt; vec4 {
                let point = geom * rect_size + rect_pos;
                pos = (point - rect_pos) / rect_size;
                return camera_projection * camera_view * vec4(point.x, point.y, 0., 1.);
            }

            fn pixel() -&gt; vec4 {
                let border = 10.;
                let pt = pos * rect_size;
                if pt.x &lt; border || pt.y &lt; border || pt.x &gt; rect_size.x - border || pt.y &gt; rect_size.y - border {
                    return vec4(1., 1., 0., 1.0);
                }
                return color;
            }
            &quot;#
</code></pre>
<ul>
<li><code>instance</code> variables <code>color</code>, <code>rect_pos</code>, <code>rect_size</code> define the data passed into the shader. They must be in the same order as the fields of the <code>RectIns</code> struct.</li>
<li><code>varying pos</code> defines a local variable that gets passed from <code>vertex()</code> shader to the <code>pixel()</code> shader.</li>
<li>Inside <code>vertex()</code> we transform the geometry points to absolute coordinates of the rectangle to draw. In the end we apply <code>camera_projection</code> and <code>camera_view</code>, which are helper structs built into Zaplib that transform the absolute coordinates in pixels on the screen to <code>[-1; 1]</code> range.</li>
<li>Inside <code>pixel()</code> we define a 10 pixel border and return yellow for the pixels within that border, and <code>color</code> for other pixels in that rectangle.</li>
</ul>
<p>Finally, update the <code>draw</code> function to pass the new <code>RectIns</code> struct with new colors and positions of rectangles to draw:</p>
<pre><code class="language-rust noplayground">    fn draw(&amp;mut self, cx: &amp;mut Cx) {
       self.window.begin_window(cx);
       self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
       self.view.begin_view(cx, LayoutSize::FILL);

       let rect1 = RectIns { color: vec4(1., 0., 0., 1.), rect_pos: vec2(50., 50.), rect_size: vec2(400., 200.) };
       let rect2 = RectIns { color: vec4(0., 0., 1., 1.), rect_pos: vec2(100., 100.), rect_size: vec2(200., 400.) };

       cx.add_instances(&amp;SHADER, &amp;[rect1, rect2]);

       self.view.end_view(cx);
       self.pass.end_pass(cx);
       self.window.end_window(cx);
   }
</code></pre>
<p>You can run this full example with Cargo:</p>
<pre><code class="language-bash">cargo run -p tutorial_2d_rendering_step2
</code></pre>
<p><img src="./img/tutorial_2d_rendering_step2.png" alt="" /></p>
<h2 id="step-3-using-quadins"><a class="header" href="#step-3-using-quadins">Step 3: Using <code>QuadIns</code></a></h2>
<p>Drawing rectangles is very common in graphics, so Zaplib provides a convenient <code>QuadIns</code> struct. Let's use it in our latest example.</p>
<p>Update the <code>SHADER</code> definition:</p>
<pre><code class="language-rust noplayground">static SHADER: Shader = Shader {
    build_geom: Some(QuadIns::build_geom),
    code_to_concatenate: &amp;[
        Cx::STD_SHADER,
        QuadIns::SHADER,
        code_fragment!(
            r#&quot;
            instance color: vec4;
            fn pixel() -&gt; vec4 {
                let border = 10.;
                let pt = pos * rect_size;
                if pt.x &lt; border || pt.y &lt; border || pt.x &gt; rect_size.x - border || pt.y &gt; rect_size.y - border {
                    return vec4(1., 1., 0., 1.0);
                }
                return color;
            }
            &quot;#
        ),
    ],
    ..Shader::DEFAULT
};
</code></pre>
<ul>
<li>Pass in the <code>QuadIns::build_geom</code> function — it is identical to the <code>build_geom</code> function we defined above!</li>
<li>Prefix the shader with <code>QuadIns::SHADER</code>. This defines a <code>vertex()</code> shader, so we can remove that code.</li>
<li>We can remove <code>geom</code>, <code>rect_pos</code>, <code>rect_size</code>, and <code>pos</code>, since those are also defined inside <code>QuadIns::SHADER</code>.</li>
</ul>
<p>Update <code>RectIns</code> to use <code>QuadIns</code> instead of <code>rect_pos</code> and <code>rect_size</code>:</p>
<pre><code class="language-rust noplayground">#[repr(C)]
struct RectIns {
    quad: QuadIns,
    color: Vec4,
}
</code></pre>
<p>We put <code>quad</code> on top to match the order in which shaders are concatenated above</p>
<p>Finally, change the <code>draw</code> function to pass new <code>RectIns</code> objects to the <code>add_instances</code> calls:</p>
<pre><code class="language-rust noplayground">    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
        self.view.begin_view(cx, LayoutSize::FILL);

        let rect1 = RectIns {
            quad: QuadIns { rect_pos: vec2(50., 50.), rect_size: vec2(400., 200.), draw_depth: 0. },
            color: vec4(1., 0., 0., 1.),
        };
        let rect2 = RectIns {
            quad: QuadIns { rect_pos: vec2(100., 100.), rect_size: vec2(200., 400.), draw_depth: 0. },
            color: vec4(0., 0., 1., 1.),
        };

        cx.add_instances(&amp;SHADER, &amp;[rect1, rect2]);

        self.view.end_view(cx);
        self.pass.end_pass(cx);
        self.window.end_window(cx);
    }
</code></pre>
<p>You can run this full example with Cargo:</p>
<pre><code class="language-bash">cargo run -p tutorial_2d_rendering_step3
</code></pre>
<p>The output hasn't changed:</p>
<p><img src="./img/tutorial_2d_rendering_step2.png" alt="" /></p>
<p>This is what the full code looks like:</p>
<pre><code class="language-rust noplayground">use zaplib::*;

#[repr(C)]
struct RectIns {
    quad: QuadIns,
    color: Vec4,
}

static SHADER: Shader = Shader {
    build_geom: Some(QuadIns::build_geom),
    code_to_concatenate: &amp;[
        Cx::STD_SHADER,
        QuadIns::SHADER,
        code_fragment!(
            r#&quot;
            instance color: vec4;

            fn pixel() -&gt; vec4 {
                let border = 10.;
                let pt = pos * rect_size;
                if pt.x &lt; border || pt.y &lt; border || pt.x &gt; rect_size.x - border || pt.y &gt; rect_size.y - border {
                    return vec4(1., 1., 0., 1.0);
                }
                return color;
            }
            &quot;#
        ),
    ],
    ..Shader::DEFAULT
};

#[derive(Default)]
struct App {
    window: Window,
    pass: Pass,
    view: View,
}

impl App {
    fn new(_cx: &amp;mut Cx) -&gt; Self {
        Self::default()
    }

    fn handle(&amp;mut self, _cx: &amp;mut Cx, _event: &amp;mut Event) {}

    fn draw(&amp;mut self, cx: &amp;mut Cx) {
        self.window.begin_window(cx);
        self.pass.begin_pass(cx, Vec4::color(&quot;0&quot;));
        self.view.begin_view(cx, LayoutSize::FILL);

        let rect1 = RectIns {
            quad: QuadIns { rect_pos: vec2(50., 50.), rect_size: vec2(400., 200.), draw_depth: 0. },
            color: vec4(1., 0., 0., 1.),
        };
        let rect2 = RectIns {
            quad: QuadIns { rect_pos: vec2(100., 100.), rect_size: vec2(200., 400.), draw_depth: 0. },
            color: vec4(0., 0., 1., 1.),
        };

        cx.add_instances(&amp;SHADER, &amp;[rect1, rect2]);

        self.view.end_view(cx);
        self.pass.end_pass(cx);
        self.window.end_window(cx);
    }
}

main_app!(App);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="tutorial_hello_world_canvas.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="tutorial_3d_rendering.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="tutorial_hello_world_canvas.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="tutorial_3d_rendering.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
