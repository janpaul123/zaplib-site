!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.zaplib=t():e.zaplib=t()}(self,(function(){return(()=>{"use strict";var e={605:(e,t,r)=>{r.d(t,{Z:()=>i});var n=r(537),s=r.n(n),a=r(645),o=r.n(a)()(s());o.push([e.id,'.zaplib_canvas {\n    position: absolute; /* For z-index */\n    top: 0;\n    left: 0;\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\n    z-index: 2147483647;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    user-select: none;\n    touch-action: pan-x pan-y; /* Mobile Safari doesn\'t support "none" */\n}\n\ntextarea.zaplib_textarea {\n    z-index: 1000;\n    position: absolute;\n    opacity: 0;\n    border-radius: 4px;\n    color:white;\n    font-size: 6;\n    background: gray;\n    -moz-appearance: none;\n    appearance:none;\n    border:none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    text-indent: 0px;\n    padding: 0 0px;\n    margin: 0 -1px;\n    text-indent: 0px;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    white-space: pre!important;\n}\ntextarea:focus.zaplib_textarea {\n    outline: 0px !important;\n    -webkit-appearance: none;\n}\n',"",{version:3,sources:["webpack://./zaplib.css"],names:[],mappings:"AAAA;IACI,kBAAkB,EAAE,gBAAgB;IACpC,MAAM;IACN,OAAO;IACP,uHAAuH;IACvH,mBAAmB;IACnB,WAAW;IACX,YAAY;IACZ,oBAAoB;IACpB,iBAAiB;IACjB,yBAAyB,EAAE,yCAAyC;AACxE;;AAEA;IACI,aAAa;IACb,kBAAkB;IAClB,UAAU;IACV,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,gBAAgB;IAChB,qBAAqB;IACrB,eAAe;IACf,WAAW;IACX,YAAY;IACZ,aAAa;IACb,gBAAgB;IAChB,gBAAgB;IAChB,cAAc;IACd,cAAc;IACd,gBAAgB;IAChB,qBAAqB;IACrB,sBAAsB;IACtB,yBAAyB;IACzB,iBAAiB;IACjB,0BAA0B;AAC9B;AACA;IACI,uBAAuB;IACvB,wBAAwB;AAC5B",sourcesContent:['.zaplib_canvas {\n    position: absolute; /* For z-index */\n    top: 0;\n    left: 0;\n    /* Max value to be super sure that it really is on top of everything, in case JS creates elements outside of #js-root */\n    z-index: 2147483647;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    user-select: none;\n    touch-action: pan-x pan-y; /* Mobile Safari doesn\'t support "none" */\n}\n\ntextarea.zaplib_textarea {\n    z-index: 1000;\n    position: absolute;\n    opacity: 0;\n    border-radius: 4px;\n    color:white;\n    font-size: 6;\n    background: gray;\n    -moz-appearance: none;\n    appearance:none;\n    border:none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    text-indent: 0px;\n    padding: 0 0px;\n    margin: 0 -1px;\n    text-indent: 0px;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    white-space: pre!important;\n}\ntextarea:focus.zaplib_textarea {\n    outline: 0px !important;\n    -webkit-appearance: none;\n}\n'],sourceRoot:""}]);const i=o},645:e=>{e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var r="",n=void 0!==t[5];return t[4]&&(r+="@supports (".concat(t[4],") {")),t[2]&&(r+="@media ".concat(t[2]," {")),n&&(r+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),r+=e(t),n&&(r+="}"),t[2]&&(r+="}"),t[4]&&(r+="}"),r})).join("")},t.i=function(e,r,n,s,a){"string"==typeof e&&(e=[[null,e,void 0]]);var o={};if(n)for(var i=0;i<this.length;i++){var l=this[i][0];null!=l&&(o[l]=!0)}for(var f=0;f<e.length;f++){var c=[].concat(e[f]);n&&o[c[0]]||(void 0!==a&&(void 0===c[5]||(c[1]="@layer".concat(c[5].length>0?" ".concat(c[5]):""," {").concat(c[1],"}")),c[5]=a),r&&(c[2]?(c[1]="@media ".concat(c[2]," {").concat(c[1],"}"),c[2]=r):c[2]=r),s&&(c[4]?(c[1]="@supports (".concat(c[4],") {").concat(c[1],"}"),c[4]=s):c[4]="".concat(s)),t.push(c))}},t}},537:e=>{e.exports=function(e){var t=e[1],r=e[3];if(!r)return t;if("function"==typeof btoa){var n=btoa(unescape(encodeURIComponent(JSON.stringify(r)))),s="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(n),a="/*# ".concat(s," */"),o=r.sources.map((function(e){return"/*# sourceURL=".concat(r.sourceRoot||"").concat(e," */")}));return[t].concat(o).concat([a]).join("\n")}return[t].join("\n")}},379:e=>{var t=[];function r(e){for(var r=-1,n=0;n<t.length;n++)if(t[n].identifier===e){r=n;break}return r}function n(e,n){for(var a={},o=[],i=0;i<e.length;i++){var l=e[i],f=n.base?l[0]+n.base:l[0],c=a[f]||0,d="".concat(f," ").concat(c);a[f]=c+1;var u=r(d),h={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==u)t[u].references++,t[u].updater(h);else{var p=s(h,n);n.byIndex=i,t.splice(i,0,{identifier:d,updater:p,references:1})}o.push(d)}return o}function s(e,t){var r=t.domAPI(t);return r.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;r.update(e=t)}else r.remove()}}e.exports=function(e,s){var a=n(e=e||[],s=s||{});return function(e){e=e||[];for(var o=0;o<a.length;o++){var i=r(a[o]);t[i].references--}for(var l=n(e,s),f=0;f<a.length;f++){var c=r(a[f]);0===t[c].references&&(t[c].updater(),t.splice(c,1))}a=l}}},569:e=>{var t={};e.exports=function(e,r){var n=function(e){if(void 0===t[e]){var r=document.querySelector(e);if(window.HTMLIFrameElement&&r instanceof window.HTMLIFrameElement)try{r=r.contentDocument.head}catch(e){r=null}t[e]=r}return t[e]}(e);if(!n)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");n.appendChild(r)}},216:e=>{e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},565:(e,t,r)=>{e.exports=function(e){var t=r.nc;t&&e.setAttribute("nonce",t)}},795:e=>{e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(r){!function(e,t,r){var n="";r.supports&&(n+="@supports (".concat(r.supports,") {")),r.media&&(n+="@media ".concat(r.media," {"));var s=void 0!==r.layer;s&&(n+="@layer".concat(r.layer.length>0?" ".concat(r.layer):""," {")),n+=r.css,s&&(n+="}"),r.media&&(n+="}"),r.supports&&(n+="}");var a=r.sourceMap;a&&"undefined"!=typeof btoa&&(n+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(n,e,t.options)}(t,e,r)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},589:e=>{e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},90:(e,t,r)=>{r.d(t,{Wl:()=>i,fB:()=>l,dy:()=>f,D3:()=>c,re:()=>d,yR:()=>u,m5:()=>h});var n=r(676),s=r(760);r(540);const a="$$RESPONSE",o="$$ERROR";class i{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:t,topic:r,data:n}=e.data;if(r===a)return this._pendingCallbacks[t](e.data),void delete this._pendingCallbacks[t];new Promise((e=>{const t=this._receivers.get(r);if(!t)throw new Error(`no receiver registered for ${r}`);e(t(n))})).then((e=>{if(!e)return void this.postMessage({topic:a,id:t},[]);const r=e[i.transferrables];delete e[i.transferrables];const n={topic:a,id:t,data:e};this.postMessage(n,r)})).catch((e=>{const r={topic:a,id:t,data:{[o]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(r,[])}))},this._channel=e,this._channel.onmessage)throw new Error("channel.onmessage is already set. Can only use one Rpc instance per channel.");this._channel.onmessage=this._onChannelMessage}send(e,t,r){const n=this._messageId++,s={topic:e,id:n,data:t},a=new Promise(((e,t)=>{this._pendingCallbacks[n]=r=>{if(r.data&&r.data[o]){const e=new Error(r.data.message);e.name=r.data.name,e.stack=r.data.stack,t(e)}else e(r.data)}}));return this.postMessage(s,r),a}receive(e,t){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,t)}postMessage(e,t){try{this._channel.postMessage(e,t)}catch(e){console.error("Rpc postMessage call itself failed: ",e)}}}i.transferrables="$$TRANSFERRABLES";const l=()=>{const e=new SharedArrayBuffer(1e4),t=new Int32Array(e);return t[0]=0,t[1]=0,e},f=(e,t,r)=>{new e.constructor(t,r,e.length).set(e)},c=(e,t)=>{if(e instanceof Uint8Array)return t?n.r.ReadOnlyU8Buffer:n.r.U8Buffer;if(e instanceof Float32Array)return t?n.r.ReadOnlyF32Buffer:n.r.F32Buffer;throw new Error("Invalid array type")};function d(e,t,r,a){return a.map((a=>{if("string"==typeof a)return a;{const o=(0,s._)(e,a,t,r);if(a.paramType===n.r.String)throw new Error("ZapParam buffer type called with string paramType");const i={[n.r.U8Buffer]:Uint8Array,[n.r.ReadOnlyU8Buffer]:Uint8Array,[n.r.F32Buffer]:Float32Array,[n.r.ReadOnlyF32Buffer]:Float32Array}[a.paramType];return(0,s.CO)(o,new i(o,a.bufferPtr,a.bufferLen/i.BYTES_PER_ELEMENT))}}))}function u(e,t="Value"){if(null==e)throw new Error(`Assertion failed: ${t} is null`);return e}Error;const h=e=>{const t=()=>{if(!e())throw new Error("Zaplib WebAssembly instance crashed")};return{checkWasm:t,wrapWasmExports:e=>new Proxy(e,{get:function(e,r){return t(),e[r]}})}}},214:(e,t,r)=>{r.d(t,{l_:()=>o,zp:()=>i,eM:()=>l,Ed:()=>u,dm:()=>h,u6:()=>p});var n=r(3),s=r(760),a=function(e,t,r,n){return new(r||(r=Promise))((function(s,a){function o(e){try{l(n.next(e))}catch(e){a(e)}}function i(e){try{l(n.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,i)}l((n=n.apply(e,t||[])).next())}))};const o=(e,t)=>{if(t!==e)throw new Error(`Failure: Got ${e}, Expected ${t}`);console.debug(`Success: Got ${e}, Expected ${t}`)},i=(e,t)=>{let r;try{e()}catch(e){r=e}o(!!r,!0),r&&t&&o(r.message,t)},l=(e,t)=>a(void 0,void 0,void 0,(function*(){let r;try{yield e()}catch(e){r=e}o(!!r,!0),r&&t&&o(r.message,t)})),f=e=>new Promise((t=>setTimeout(t,e))),c=(e,t)=>a(void 0,void 0,void 0,(function*(){const r=performance.now();for(;!e()&&performance.now()<r+t;)yield f(10);return e()})),d=()=>{for(let e=0;e<1e4;e++)self["garbage_"+e]={i:e};for(let e=0;e<1e4;e++)delete self["garbage_"+e]},u=(e,t)=>{if("cef"===n.Zm)return Promise.resolve();const r=t.buffer;return r.readonly?((e,t)=>a(void 0,void 0,void 0,(function*(){if(!t.__zaplibBufferData.readonly)throw new Error("arcAllocated called on mutable buffer");const r=t.__zaplibBufferData.arcPtr;o(s.OJ[r],!0);const[n]=yield e("check_arc_count",[`${BigInt(r)}`]),[a]=n;return o(a,1),r})))(e,r).then((e=>(e=>a(void 0,void 0,void 0,(function*(){o(yield c((()=>(d(),!1===s.OJ[e])),2e4),!0)})))(e))):(i=r.__zaplibBufferData.bufferPtr,a(void 0,void 0,void 0,(function*(){s.Bh[i]&&o(yield c((()=>(d(),!1===s.Bh[i])),2e4),!0)})));var i};let h=!1;const p=e=>{h=e}},3:(e,t,r)=>{r.d(t,{Zm:()=>n,iO:()=>s});const n="cefCallRust"in self?"cef":"wasm",s="function"==typeof importScripts},676:(e,t,r)=>{var n;r.d(t,{r:()=>n}),function(e){e[e.String=0]="String",e[e.ReadOnlyU8Buffer=1]="ReadOnlyU8Buffer",e[e.U8Buffer=2]="U8Buffer",e[e.F32Buffer=3]="F32Buffer",e[e.ReadOnlyF32Buffer=4]="ReadOnlyF32Buffer"}(n||(n={}))},760:(e,t,r)=>{r.d(t,{fV:()=>o,CT:()=>l,Ko:()=>f,$q:()=>d,CO:()=>h,hC:()=>p,gU:()=>y,OJ:()=>m,Bh:()=>b,_:()=>v,ku:()=>w,rx:()=>A});var n=r(90),s=r(676),a=r(214);class o extends SharedArrayBuffer{constructor(e,t){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=t}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function i(e){return class t extends e{constructor(...t){const r=t[0];if("object"==typeof r&&r instanceof o){if(t.length<2&&(t[1]=r.__zaplibBufferData.bufferPtr),t.length<3&&(t[2]=Math.floor((r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen-t[1])/e.BYTES_PER_ELEMENT)),t[1]<r.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${t[1]} is out of bounds`);if(t[1]+t[2]*e.BYTES_PER_ELEMENT>r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${t[1]} + length ${t[2]} is out of bounds`);t[0]=r.__zaplibWasmBuffer,super(...t),this.__zaplibBuffer=r}else super(...t)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,r=this.length){return e<0&&(e=this.length+e),r<0&&(r=this.length+r),r<e&&(r=e),new t(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,r-e)}}}const l={Int8Array:"ZapInt8Array",Uint8Array:"ZapUint8Array",Uint8ClampedArray:"ZapUint8ClampedArray",Int16Array:"ZapInt16Array",Uint16Array:"ZapUint16Array",Uint16ClampedArray:"ZapUint16ClampedArray",Int32Array:"ZapInt32Array",Uint32Array:"ZapUint32Array",Float32Array:"ZapFloat32Array",Float64Array:"ZapFloat64Array",BigInt64Array:"ZapBigInt64Array",BigUint64Array:"ZapBigUint64Array",DataView:"ZapDataView"};for(const[e,t]of Object.entries(l))e in self&&(self[t]=i(self[e]));function f(e){if("object"!=typeof e||null===e)return!1;if(Object.prototype.hasOwnProperty.call(e,"__zaplibBuffer"))return!0;if(Array.isArray(e)||e instanceof Set||e instanceof Map){for(const t of e)if(f(t))return!0}else if(Object.getPrototypeOf(e)===Object.getPrototypeOf({}))for(const t of Object.entries(e))if(f(t))return!0;return!1}function c(e){const t=e.postMessage;e.postMessage=function(...e){if(f(e[0]))throw new Error("Sending ZapBuffers to/from workers is not supported - use .slice() on typed array instead to make an explicit copy");t.apply(this,e)}}function d(){for(const[e,t]of Object.entries(l))e in self&&(self[e]=self[t]);c(self),c(self.Worker),self.MessagePort&&c(self.MessagePort)}const u=new WeakMap;function h(e,t){var r;return(null===(r=u.get(e))||void 0===r?void 0:r.BYTES_PER_ELEMENT)!==t.BYTES_PER_ELEMENT&&u.set(e,t),u.get(e)}function p(e){return"object"==typeof e&&e instanceof o}function y(e){if(!p(e.buffer))throw new Error("zapArray.buffer is not a ZapBuffer in checkValidZapArray");const t=e.buffer;if(e.byteOffset!==t.__zaplibBufferData.bufferPtr||e.byteLength!==t.__zaplibBufferData.bufferLen)throw new Error("Called Rust with a buffer that does not span the entire underlying ZapBuffer");const r=(0,n.D3)(e,t.readonly);if(r!==t.__zaplibBufferData.paramType)throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${s.r[t.__zaplibBufferData.paramType]} but got ${s.r[r]}`)}const g={},m={},b={},_=new FinalizationRegistry((({arcPtr:e,destructor:t})=>{if(a.dm){if(!1===m[e])throw new Error(`Deallocating an already deallocated arcPtr ${e}`);if(void 0===m[e])throw new Error(`Deallocating an unallocated arcPtr ${e}`);m[e]=!1}delete g[e],t&&t(e)})),E=new FinalizationRegistry((({bufferData:e,destructor:t})=>{if(a.dm){const{bufferPtr:t}=e;if(!1===b[t])throw new Error(`Deallocating an already deallocated bufferPtr ${t}`);if(void 0===b[t])throw new Error(`Deallocating an unallocated bufferPtr ${t}`);b[t]=!1}t(e)})),v=(e,t,r,n)=>{var s;if(t.readonly){if(null===(s=g[t.arcPtr])||void 0===s?void 0:s.deref())r(t.arcPtr);else{a.dm&&(m[t.arcPtr]=!0);const n=new o(e.buffer,t);_.register(n,{arcPtr:t.arcPtr,destructor:r}),g[t.arcPtr]=new WeakRef(n)}return g[t.arcPtr].deref()}{a.dm&&(b[t.bufferPtr]=!0);const r=new o(e.buffer,t);return E.register(r,{bufferData:t,destructor:n},r),r}},w=e=>{if(e.readonly)throw new Error("`unregisterMutableBuffer` should only be called on mutable ZapBuffers");E.unregister(e),a.dm&&(b[e.__zaplibBufferData.bufferPtr]=!1)},A=(e,t,r)=>{var n;if(t){if(!(null===(n=g[t])||void 0===n?void 0:n.deref())){const n=new o(e,{bufferPtr:0,bufferLen:e.byteLength,readonly:!0,paramType:r,arcPtr:-1});_.register(n,{arcPtr:t}),g[t]=new WeakRef(n)}return g[t].deref()}return new o(e,{bufferPtr:0,bufferLen:e.byteLength,bufferCap:e.byteLength,paramType:r,readonly:!1})}},167:(e,t,r)=>{r.d(t,{callRust:()=>Ce,callRustInSameThreadSync:()=>Me,createMutableBuffer:()=>De,createReadOnlyBuffer:()=>Oe,deserializeZapArrayFromPostMessage:()=>Ie,initialize:()=>ke,jsRuntime:()=>U.Zm,newWorkerPort:()=>Pe,registerCallJsCallbacks:()=>ze,serializeZapArrayForPostMessage:()=>xe});var n={};r.r(n),r.d(n,{callRust:()=>V,callRustInSameThreadSync:()=>H,createMutableBuffer:()=>$,createReadOnlyBuffer:()=>G,deserializeZapArrayFromPostMessage:()=>K,initialize:()=>Y,newWorkerPort:()=>I,registerCallJsCallbacks:()=>W,serializeZapArrayForPostMessage:()=>Z,unregisterCallJsCallbacks:()=>T});var s={};r.r(s),r.d(s,{callRust:()=>se,callRustInSameThreadSync:()=>fe,createMutableBuffer:()=>pe,createReadOnlyBuffer:()=>ye,deserializeZapArrayFromPostMessage:()=>ue,initialize:()=>he,newWorkerPort:()=>ce,registerCallJsCallbacks:()=>oe,serializeZapArrayForPostMessage:()=>de,unregisterCallJsCallbacks:()=>ie});var a=r(477),o=r.n(a);function i(){return o()('(()=>{"use strict";const e=["none","default","crosshair","pointer","default","move","text","wait","help","not-allowed","n-resize","ne-resize","e-resize","se-resize","s-resize","sw-resize","w-resize","nw-resize","ns-resize","nesw-resize","ew-resize","nwse-resize","col-resize","row-resize"];var t,r;(r=t||(t={}))[r.String=0]="String",r[r.ReadOnlyU8Buffer=1]="ReadOnlyU8Buffer",r[r.U8Buffer=2]="U8Buffer",r[r.F32Buffer=3]="F32Buffer",r[r.ReadOnlyF32Buffer=4]="ReadOnlyF32Buffer",self;class s extends SharedArrayBuffer{constructor(e,t){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=t}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class t extends e{constructor(...t){const r=t[0];if("object"==typeof r&&r instanceof s){if(t.length<2&&(t[1]=r.__zaplibBufferData.bufferPtr),t.length<3&&(t[2]=Math.floor((r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen-t[1])/e.BYTES_PER_ELEMENT)),t[1]<r.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${t[1]} is out of bounds`);if(t[1]+t[2]*e.BYTES_PER_ELEMENT>r.__zaplibBufferData.bufferPtr+r.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${t[1]} + length ${t[2]} is out of bounds`);t[0]=r.__zaplibWasmBuffer,super(...t),this.__zaplibBuffer=r}else super(...t)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,r=this.length){return e<0&&(e=this.length+e),r<0&&(r=this.length+r),r<e&&(r=e),new t(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,r-e)}}}const i={Int8Array:"ZapInt8Array",Uint8Array:"ZapUint8Array",Uint8ClampedArray:"ZapUint8ClampedArray",Int16Array:"ZapInt16Array",Uint16Array:"ZapUint16Array",Uint16ClampedArray:"ZapUint16ClampedArray",Int32Array:"ZapInt32Array",Uint32Array:"ZapUint32Array",Float32Array:"ZapFloat32Array",Float64Array:"ZapFloat64Array",BigInt64Array:"ZapBigInt64Array",BigUint64Array:"ZapBigUint64Array",DataView:"ZapDataView"};for(const[e,t]of Object.entries(i))e in self&&(self[t]=n(self[e]));new WeakMap;const a={};new FinalizationRegistry((({arcPtr:e,destructor:t})=>{delete a[e],t&&t(e)})),new FinalizationRegistry((({bufferData:e,destructor:t})=>{t(e)}));class o{constructor({buffer:e,byteOffset:t,slots:r,growCallback:s}){this._buffer=e,this._byteOffset=t,this._slots=r,this._growCallback=s,this._used=2,this._updateRefs()}_updateRefs(){this._f32=new Float32Array(this._buffer,this._byteOffset,this._slots),this._u32=new Uint32Array(this._buffer,this._byteOffset,this._slots),this._f64=new Float64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64=new BigUint64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64[0]=BigInt(this._slots)*BigInt(4)}_fit(e){if(this._used+e>this._slots){let t=Math.max(this._used+e,2*this._slots);1&t&&t++;const r=4*t,{buffer:s,byteOffset:n}=this._growCallback(this._buffer,this._byteOffset,r);this._buffer=s,this._byteOffset=n,this._slots=t,this._updateRefs()}const t=this._used;return this._used+=e,t}sendF32(e){const t=this._fit(1);this._f32[t]=e}sendU32(e){const t=this._fit(1);this._u32[t]=e}sendF64(e){if(1&this._used){const t=this._fit(3)+1;this._f64[t>>1]=e}else{const t=this._fit(2);this._f64[t>>1]=e}}sendU64(e){if(1&this._used){const t=this._fit(3)+1;this._u64[t>>1]=e}else{const t=this._fit(2);this._u64[t>>1]=e}}sendString(e){let t=this._fit(e.length+1);this._u32[t++]=e.length;for(let r=0;r<e.length;r++)this._u32[t++]=e.charCodeAt(r)}getData(){return{buffer:this._buffer,byteOffset:this._byteOffset}}}class d{constructor(e,t){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,t),this._u32=new Uint32Array(this._memory.buffer,t),this._f64=new Float64Array(this._memory.buffer,t),this._u64=new BigUint64Array(this._memory.buffer,t)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e="";const t=this.parseU32();for(let r=0;r<t;r++){const t=this.parseU32();0!=t&&(e+=String.fromCharCode(t))}return e}parseU8Slice(){const e=this.parseU32(),t=e>>2,r=new Uint8Array(e),s=3&e;for(let e=0;e<t;e++){const t=e<<2,s=this.parseU32();r[t+0]=255&s,r[t+1]=s>>8&255,r[t+2]=s>>16&255,r[t+3]=s>>24&255}const n=t<<2;if(1==s){const e=this.parseU32();r[n+0]=255&e}else if(2==s){const e=this.parseU32();r[n+0]=255&e,r[n+1]=e>>8&255}else if(3==s){const e=this.parseU32();r[n+0]=255&e,r[n+1]=e>>8&255,r[n+2]=e>>16&255}return r}parseZapParams(){const e=this.parseU32(),r=[];for(let s=0;s<e;++s){const e=this.parseU32();if(e===t.String)r.push(this.parseString());else if(e===t.ReadOnlyU8Buffer||e===t.ReadOnlyF32Buffer){const t=this.parseU32(),s=this.parseU32(),n=this.parseU32();r.push({paramType:e,bufferPtr:t,bufferLen:s,arcPtr:n,readonly:!0})}else{if(e!==t.U8Buffer&&e!==t.F32Buffer)throw new Error(`Unknown ZapParam type: ${e}`);{const t=this.parseU32(),s=this.parseU32(),n=this.parseU32();r.push({paramType:e,bufferPtr:t,bufferLen:s,bufferCap:n,readonly:!1})}}}return r}}const l="$$RESPONSE",h="$$ERROR";class c{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:t,topic:r,data:s}=e.data;if(r===l)return this._pendingCallbacks[t](e.data),void delete this._pendingCallbacks[t];new Promise((e=>{const t=this._receivers.get(r);if(!t)throw new Error(`no receiver registered for ${r}`);e(t(s))})).then((e=>{if(!e)return void this.postMessage({topic:l,id:t},[]);const r=e[c.transferrables];delete e[c.transferrables];const s={topic:l,id:t,data:e};this.postMessage(s,r)})).catch((e=>{const r={topic:l,id:t,data:{[h]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(r,[])}))},this._channel=e,this._channel.onmessage)throw new Error("channel.onmessage is already set. Can only use one Rpc instance per channel.");this._channel.onmessage=this._onChannelMessage}send(e,t,r){const s=this._messageId++,n={topic:e,id:s,data:t},i=new Promise(((e,t)=>{this._pendingCallbacks[s]=r=>{if(r.data&&r.data[h]){const e=new Error(r.data.message);e.name=r.data.name,e.stack=r.data.stack,t(e)}else e(r.data)}}));return this.postMessage(n,r),i}receive(e,t){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,t)}postMessage(e,t){try{this._channel.postMessage(e,t)}catch(e){console.error("Rpc postMessage call itself failed: ",e)}}}c.transferrables="$$TRANSFERRABLES";const u=e=>{const t=8*Math.ceil((e.__tls_size.value+2097152)/8);return{ptr:e.allocWasmMessage(BigInt(t)),size:t}},f=(e,t,r)=>{new e.constructor(t,r,e.length).set(e)},p=(e,r)=>{if(e instanceof Uint8Array)return r?t.ReadOnlyU8Buffer:t.U8Buffer;if(e instanceof Float32Array)return r?t.ReadOnlyF32Buffer:t.F32Buffer;throw new Error("Invalid array type")},m=(e,t,r)=>{const s=Number(t.allocWasmVec(BigInt(r.byteLength)));return f(r,e.buffer,s),s};function g(e,t="Value"){if(null==e)throw new Error(`Assertion failed: ${t} is null`);return e}class E extends Error{constructor(e){super(e),this.name="RustPanic"}}function _(e){return(e.shiftKey?1:0)|(e.ctrlKey?2:0)|(e.altKey?4:0)|(e.metaKey?8:0)}const b={keyDown(e,t){e.sendU32(12),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(_(t.event)),e.sendF64(performance.now()/1e3)},keyUp(e,t){e.sendU32(13),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(_(t.event)),e.sendF64(performance.now()/1e3)},textInput(e,t){e.sendU32(14),e.sendU32(t.wasPaste?1:0),e.sendU32(t.replaceLast?1:0),e.sendString(t.input)},textCopy(e){e.sendU32(17)}};class v{constructor(e){this._wasmApp=e,this._zerdeBuilder=((e,t)=>{const r=Number(t.allocWasmMessage(BigInt(4096)));return new o({buffer:e.buffer,byteOffset:r,slots:1024,growCallback:(r,s,n)=>{const i=Number(t.reallocWasmMessage(BigInt(s),BigInt(n)));return{buffer:e.buffer,byteOffset:i}}})})(e.memory,e.exports),this._zerdeBuilder.sendF64(0)}getWasmApp(){return this._wasmApp}createWasmBuffer(e){return m(this._wasmApp.memory,this._wasmApp.exports,e)}createArcVec(e,t){return Number(this._wasmApp.exports.createArcVec(BigInt(e),BigInt(t.length),BigInt(p(t,!0))))}init(e){this._zerdeBuilder.sendU32(1),this._zerdeBuilder.sendF32(e.width),this._zerdeBuilder.sendF32(e.height),this._zerdeBuilder.sendF32(e.dpiFactor),this._zerdeBuilder.sendU32(e.xrCanPresent?1:0),this._zerdeBuilder.sendU32(e.canFullscreen?1:0),this._zerdeBuilder.sendString("95652baad38c4b81599274b44e1fbf27b63f2839")}resize(e){this._zerdeBuilder.sendU32(4),this._zerdeBuilder.sendF32(e.width),this._zerdeBuilder.sendF32(e.height),this._zerdeBuilder.sendF32(e.dpiFactor),this._zerdeBuilder.sendU32(e.xrIsPresenting?1:0),this._zerdeBuilder.sendU32(e.xrCanPresent?1:0),this._zerdeBuilder.sendU32(e.isFullscreen?1:0)}animationFrame(){this._zerdeBuilder.sendU32(5)}pointerDown(e){this._zerdeBuilder.sendU32(6),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.button),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerUp(e){this._zerdeBuilder.sendU32(7),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.button),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerMove(e){this._zerdeBuilder.sendU32(8),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.digit),this._zerdeBuilder.sendU32(e.touch?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerHover(e){this._zerdeBuilder.sendU32(9),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerScroll(e){this._zerdeBuilder.sendU32(10),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendF32(e.scrollX),this._zerdeBuilder.sendF32(e.scrollY),this._zerdeBuilder.sendU32(e.isWheel?1:0),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}pointerOut(e){this._zerdeBuilder.sendU32(11),this._zerdeBuilder.sendF32(e.x),this._zerdeBuilder.sendF32(e.y),this._zerdeBuilder.sendU32(e.modifiers),this._zerdeBuilder.sendF64(e.time)}keyDown(e){b.keyDown(this._zerdeBuilder,e)}keyUp(e){b.keyUp(this._zerdeBuilder,e)}textInput(e){b.textInput(this._zerdeBuilder,e)}textCopy(){b.textCopy(this._zerdeBuilder)}timerFired(e){this._zerdeBuilder.sendU32(18),this._zerdeBuilder.sendF64(e)}windowFocus(e){this._zerdeBuilder.sendU32(19),this._zerdeBuilder.sendU32(e?1:0)}xrUpdateHead(e,t){}xrUpdateInputs(e,t,r,s,n){}paintDirty(e,t){this._zerdeBuilder.sendU32(21)}httpSendResponse(e,t){this._zerdeBuilder.sendU32(22),this._zerdeBuilder.sendU32(e),this._zerdeBuilder.sendU32(t)}sendEventFromAnyThread(e){this._zerdeBuilder.sendU32(26),this._zerdeBuilder.sendU64(e)}websocketMessage(e,t){const r=t.byteLength,s=this.createWasmBuffer(new Uint8Array(t));this._zerdeBuilder.sendU32(23),this._zerdeBuilder.sendU32(s),this._zerdeBuilder.sendU32(r),this._zerdeBuilder.sendString(e)}websocketError(e,t){this._zerdeBuilder.sendU32(24),this._zerdeBuilder.sendString(e),this._zerdeBuilder.sendString(t)}appOpenFiles(e){this._zerdeBuilder.sendU32(25),this._zerdeBuilder.sendU32(e.length);for(const t of e)this._zerdeBuilder.sendU32(t.id),this._zerdeBuilder.sendU64(BigInt(t.file.size)),this._zerdeBuilder.sendString(t.basename)}dragenter(){this._zerdeBuilder.sendU32(27)}dragleave(){this._zerdeBuilder.sendU32(28)}dragover(e,t){this._zerdeBuilder.sendU32(29),this._zerdeBuilder.sendU32(e),this._zerdeBuilder.sendU32(t)}callRust(e,r,s){this._zerdeBuilder.sendU32(30),this._zerdeBuilder.sendString(e),this._zerdeBuilder.sendU32(r.length);for(const e of r)if("string"==typeof e)this._zerdeBuilder.sendU32(t.String),this._zerdeBuilder.sendString(e);else if("bufferData"in e)this._zerdeBuilder.sendU32(e.bufferData.paramType),e.bufferData.readonly?this._zerdeBuilder.sendU32(e.bufferData.arcPtr):(this._zerdeBuilder.sendU32(e.bufferData.bufferPtr),this._zerdeBuilder.sendU32(e.bufferData.bufferLen),this._zerdeBuilder.sendU32(e.bufferData.bufferCap));else{const t=e.byteLength,r=this.createWasmBuffer(e);this._zerdeBuilder.sendU32(p(e,!1)),this._zerdeBuilder.sendU32(r),this._zerdeBuilder.sendU32(t),this._zerdeBuilder.sendU32(t)}this._zerdeBuilder.sendU32(s)}end(){this._zerdeBuilder.sendU32(0);const{buffer:e,byteOffset:t}=this._zerdeBuilder.getData();return new Float64Array(e,t,2)[1]=performance.now()/1e3,t}}class z{constructor(e,t,r,s){this.uniformFnTable={float:function(e,t,r){const s=r>>2;e.gl.uniform1f(t,e.basef32[s])},vec2:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform2f(t,n[s],n[s+1])},vec3:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform3f(t,n[s],n[s+1],n[s+2])},vec4:function(e,t,r){const s=r>>2,n=e.basef32;e.gl.uniform4f(t,n[s],n[s+1],n[s+2],n[s+3])},mat2:function(e,t,r){e.gl.uniformMatrix2fv(t,!1,new Float32Array(e.memory.buffer,r,4))},mat3:function(e,t,r){e.gl.uniformMatrix3fv(t,!1,new Float32Array(e.memory.buffer,r,9))},mat4:function(e,t,r){const s=new Float32Array(e.memory.buffer,r,16);e.gl.uniformMatrix4fv(t,!1,s)}},this.sendFnTable=[function(e){return!0},function(e){function t(){const t=e.zerdeParser.parseU32(),r=[];for(let s=0;s<t;s++)r.push({ty:e.zerdeParser.parseString(),name:e.zerdeParser.parseString()});return r}const r={shaderId:e.zerdeParser.parseU32(),fragment:e.zerdeParser.parseString(),vertex:e.zerdeParser.parseString(),geometrySlots:e.zerdeParser.parseU32(),instanceSlots:e.zerdeParser.parseU32(),passUniforms:t(),viewUniforms:t(),drawUniforms:t(),userUniforms:t(),textureSlots:t()};e.compileWebGLShader(r)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=new Float32Array(e.memory.buffer,s,r);e.allocArrayBuffer(t,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=new Uint32Array(e.memory.buffer,s,r);e.allocIndexBuffer(t,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),i=e.zerdeParser.parseU32();e.allocVao(t,r,s,n,i)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),i=e.zerdeParser.parseU32(),a=e.zerdeParser.parseU32(),o=e.zerdeParser.parseU32();e.drawCall(t,r,s,n,i,a,o)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32();e.allocTexture(t,r,s,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32();e.beginRenderTargets(t,r,s)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseF32(),n=e.zerdeParser.parseF32(),i=e.zerdeParser.parseF32(),a=e.zerdeParser.parseF32();e.addColorTarget(t,r,s,n,i,a)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseF32();e.setDepthTarget(t,r,s)},function(e){e.endRenderTargets()},function(e){e.setDefaultDepthAndBlendMode()},function(e){const t=e.zerdeParser.parseF32(),r=e.zerdeParser.parseF32(),s=e.zerdeParser.parseF32(),n=e.zerdeParser.parseF32(),i=e.zerdeParser.parseF32();e.beginMainCanvas(t,r,s,n,i)}],this.canvas=e,this.memory=t,this.sizingData=r,this.shaders=[],this.indexBuffers=[],this.arrayBuffers=[],this.vaos=[],this.textures=[],this.framebuffers=[],this.targetWidth=0,this.targetHeight=0,this.clearFlags=0,this.clearR=0,this.clearG=0,this.clearB=0,this.clearA=0,this.clearDepth=0;const n={preferLowPowerToHighPerformance:!0};this.gl=e.getContext("webgl",n)||e.getContext("webgl-experimental",n)||e.getContext("experimental-webgl",n),this.gl?(this.OESVertexArrayObject=g(this.gl.getExtension("OES_vertex_array_object")),this.ANGLEInstancedArrays=g(this.gl.getExtension("ANGLE_instanced_arrays")),this.gl.getExtension("OES_standard_derivatives"),this.gl.getExtension("OES_element_index_uint"),this.resize(r)):s()}processMessages(e){for(this.zerdeParser=new d(this.memory,e),this.basef32=new Float32Array(this.memory.buffer),this.baseu32=new Uint32Array(this.memory.buffer);;){const e=this.zerdeParser.parseU32();if(this.sendFnTable[e](this))break}}resize(e){this.sizingData=e,this.canvas.width=e.width*e.dpiFactor,this.canvas.height=e.height*e.dpiFactor}getAttribLocations(e,t,r){const s=this.gl,n=[];let i=r>>2;0!=(3&r)&&i++;for(let a=0;a<i;a++){let i=r-4*a;i>4&&(i=4),n.push({loc:s.getAttribLocation(e,t+a),offset:16*a,size:i,stride:4*r})}return n}getUniformLocations(e,t){const r=this.gl,s=[];let n=0;for(let i=0;i<t.length;i++){const a=t[i],o=U[a.ty];0!=(3&n)&&(3&n)+o>4&&(n+=4-(3&n)),s.push({name:a.name,offset:n<<2,ty:a.ty,loc:r.getUniformLocation(e,a.name),fn:this.uniformFnTable[a.ty]}),n+=o}return s}compileWebGLShader(e){const t=this.gl,r=g(t.createShader(t.VERTEX_SHADER));t.shaderSource(r,e.vertex),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(r),B(e.vertex));const s=g(t.createShader(t.FRAGMENT_SHADER));t.shaderSource(s,e.fragment),t.compileShader(s),t.getShaderParameter(s,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(s),B(e.fragment));const n=g(t.createProgram());t.attachShader(n,r),t.attachShader(n,s),t.linkProgram(n),t.getProgramParameter(n,t.LINK_STATUS)||console.log(t.getProgramInfoLog(n),B(e.vertex),B(e.fragment)),this.shaders[e.shaderId]={geomAttribs:this.getAttribLocations(n,"mpsc_packed_geometry_",e.geometrySlots),instAttribs:this.getAttribLocations(n,"mpsc_packed_instance_",e.instanceSlots),passUniforms:this.getUniformLocations(n,e.passUniforms),viewUniforms:this.getUniformLocations(n,e.viewUniforms),drawUniforms:this.getUniformLocations(n,e.drawUniforms),userUniforms:this.getUniformLocations(n,e.userUniforms),textureSlots:this.getUniformLocations(n,e.textureSlots),instanceSlots:e.instanceSlots,program:n,ash:e}}allocArrayBuffer(e,t){const r=this.gl;let s=this.arrayBuffers[e];void 0===s?s=this.arrayBuffers[e]={glBuf:g(r.createBuffer()),length:t.length}:s.length=t.length,r.bindBuffer(r.ARRAY_BUFFER,s.glBuf),r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,null)}allocIndexBuffer(e,t){const r=this.gl;let s=this.indexBuffers[e];void 0===s?s=this.indexBuffers[e]={glBuf:g(r.createBuffer()),length:t.length}:s.length=t.length,r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,s.glBuf),r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null)}allocVao(e,t,r,s,n){const i=this.gl,a=this.vaos[e];a&&this.OESVertexArrayObject.deleteVertexArrayOES(a.glVao);const o=g(this.OESVertexArrayObject.createVertexArrayOES()),d=this.vaos[e]={glVao:o,geomIbId:r,geomVbId:s,instVbId:n};this.OESVertexArrayObject.bindVertexArrayOES(d.glVao),i.bindBuffer(i.ARRAY_BUFFER,this.arrayBuffers[s].glBuf);const l=this.shaders[t];for(let e=0;e<l.geomAttribs.length;e++){const t=l.geomAttribs[e];t.loc<0||(i.vertexAttribPointer(t.loc,t.size,i.FLOAT,!1,t.stride,t.offset),i.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,0))}i.bindBuffer(i.ARRAY_BUFFER,this.arrayBuffers[n].glBuf);for(let e=0;e<l.instAttribs.length;e++){const t=l.instAttribs[e];t.loc<0||(i.vertexAttribPointer(t.loc,t.size,i.FLOAT,!1,t.stride,t.offset),i.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,1))}i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,this.indexBuffers[r].glBuf),this.OESVertexArrayObject.bindVertexArrayOES(null)}drawCall(e,t,r,s,n,i,a){const o=this.gl,d=this.shaders[e];o.useProgram(d.program);const l=this.vaos[t];this.OESVertexArrayObject.bindVertexArrayOES(l.glVao);const h=this.indexBuffers[l.geomIbId],c=this.arrayBuffers[l.instVbId],u=d.passUniforms,f=d.viewUniforms;for(let e=0;e<f.length;e++){const t=f[e];t.fn(this,t.loc,t.offset+s)}const p=d.drawUniforms;for(let e=0;e<p.length;e++){const t=p[e];t.fn(this,t.loc,t.offset+n)}const m=d.userUniforms;for(let e=0;e<m.length;e++){const t=m[e];t.fn(this,t.loc,t.offset+i)}const g=d.textureSlots;for(let e=0;e<g.length;e++){const t=g[e],r=this.baseu32[(a>>2)+e],s=this.textures[r];o.activeTexture(o.TEXTURE0+e),o.bindTexture(o.TEXTURE_2D,s),o.uniform1i(t.loc,e)}const E=h.length,_=c.length/d.instanceSlots;for(let e=0;e<u.length;e++){const t=u[e];t.fn(this,t.loc,t.offset+r)}this.ANGLEInstancedArrays.drawElementsInstancedANGLE(o.TRIANGLES,E,o.UNSIGNED_INT,0,_),this.OESVertexArrayObject.bindVertexArrayOES(null)}allocTexture(e,t,r,s){const n=this.gl,i=this.textures[e]||n.createTexture();n.bindTexture(n.TEXTURE_2D,i),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);const a=new Uint8Array(this.memory.buffer,s,t*r*4);n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t,r,0,n.RGBA,n.UNSIGNED_BYTE,a),this.textures[e]=i}beginRenderTargets(e,t,r){const s=this.gl;this.targetWidth=t,this.targetHeight=r,this.clearFlags=0;const n=this.framebuffers[e]||(this.framebuffers[e]=g(s.createFramebuffer()));s.bindFramebuffer(s.FRAMEBUFFER,n)}addColorTarget(e,t,r,s,n,i){this.clearR=r,this.clearG=s,this.clearB=n,this.clearA=i;const a=this.gl,o=this.textures[e]||(this.textures[e]=a.createTexture());o.mpWidth!=this.targetWidth||o.mpHeight!=this.targetHeight?(a.bindTexture(a.TEXTURE_2D,o),this.clearFlags|=a.COLOR_BUFFER_BIT,o.mpWidth=this.targetWidth,o.mpHeight=this.targetHeight,a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,o.mpWidth,o.mpHeight,0,a.RGBA,a.UNSIGNED_BYTE,null)):t||(this.clearFlags|=a.COLOR_BUFFER_BIT),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,o,0)}setDepthTarget(e,t,r){const s=this.gl;this.clearDepth=r;const n=this.textures[e]||(this.textures[e]=s.createRenderbuffer());n.mpWidth!=this.targetWidth||n.mpHeight!=this.targetHeight?(s.bindRenderbuffer(s.RENDERBUFFER,n),this.clearFlags|=s.DEPTH_BUFFER_BIT,n.mpWidth=this.targetWidth,n.mpHeight=this.targetHeight,s.renderbufferStorage(s.RENDERBUFFER,s.DEPTH_COMPONENT16,this.targetWidth,this.targetHeight)):t||(this.clearFlags|=s.DEPTH_BUFFER_BIT),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.RENDERBUFFER,n)}endRenderTargets(){const e=this.gl;e.viewport(0,0,this.targetWidth,this.targetHeight),this.clearFlags&&(e.clearColor(this.clearR,this.clearG,this.clearB,this.clearA),e.clearDepth(this.clearDepth),e.clear(this.clearFlags))}setDefaultDepthAndBlendMode(){const e=this.gl;e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.blendEquationSeparate(e.FUNC_ADD,e.FUNC_ADD),e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA),e.enable(e.BLEND)}beginMainCanvas(e,t,r,s,n){const i=this.gl;i.bindFramebuffer(i.FRAMEBUFFER,null),i.viewport(0,0,this.sizingData.width*this.sizingData.dpiFactor,this.sizingData.height*this.sizingData.dpiFactor),i.clearColor(e,t,r,s),i.clearDepth(n),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT)}}const U={float:1,vec2:2,vec3:3,vec4:4,mat2:4,mat3:9,mat4:16};function B(e){const t=e.split("\\n");let r="";for(let e=0;e<t.length;e++)r+=e+1+": "+t[e]+"\\n";return r}var y,w,A,F;!function(e){e.CallRust="WorkerEvent.CallRust",e.CreateBuffer="WorkerEvent.CreateBuffer",e.CreateReadOnlyBuffer="WorkerEvent.CreateReadOnlyBuffer",e.BindMainWorkerPort="WorkerEvent.BindMainWorkerPort",e.DecrementArc="WorkerEvent.DecrementArc",e.DeallocVec="WorkerEvent.DeallocVec",e.IncrementArc="WorkerEvent.IncrementArc",e.DragEnter="WorkerEvent.DragEnter",e.DragOver="WorkerEvent.DragOver",e.DragLeave="WorkerEvent.DragLeave",e.Drop="WorkerEvent.Drop",e.WindowMouseUp="WorkerEvent.WindowMouseUp",e.CanvasMouseDown="WorkerEvent.CanvasMouseDown",e.WindowMouseMove="WorkerEvent.WindowMouseMove",e.WindowMouseOut="WorkerEvent.WindowMouseOut",e.WindowFocus="WorkerEvent.WindowFocus",e.WindowBlur="WorkerEvent.WindowBlur",e.ScreenResize="WorkerEvent.ScreenResize",e.CanvasWheel="WorkerEvent.CanvasWheel",e.ShowIncompatibleBrowserNotification="WorkerEvent.ShowIncompatibleBrowserNotification",e.RemoveLoadingIndicators="WorkerEvent.RemoveLoadingIndicators",e.SetDocumentTitle="WorkerEvent.SetDocumentTitle",e.SetMouseCursor="WorkerEvent.SetMouseCursor",e.Fullscreen="WorkerEvent.Fullscreen",e.Normalscreen="WorkerEvent.Normalscreen",e.TextCopyResponse="WorkerEvent.TextCopyResponse",e.EnableGlobalFileDropTarget="WorkerEvent.EnableGlobalFileDropTarget",e.CallJs="WorkerEvent.CallJs",e.ShowTextIME="WorkerEvent.ShowTextIME",e.TextInput="WorkerEvent.TextInput",e.TextCopy="WorkerEvent.TextCopy",e.KeyDown="WorkerEvent.KeyDown",e.KeyUp="WorkerEvent.KeyUp",e.Init="WorkerEvent.Init",e.RunWebGL="WorkerEvent.RunWebGL",e.ThreadSpawn="WorkerEvent.ThreadSpawn",e.WindowTouchStart="WorkerEvent.WindowTouchStart",e.WindowTouchMove="WorkerEvent.WindowTouchMove",e.WindowTouchEndCancelLeave="WorkerEvent.WindowTouchEndCancelLeave",e.Panic="WorkerEvent.Panic"}(y||(y={})),function(e){e.Init="TaskWorkerEvent.Init"}(w||(w={})),function(e){e.Run="AsyncWorkerEvent.Run",e.ThreadSpawn="AsyncWorkerEvent.ThreadSpawn"}(A||(A={})),function(e){e.Init="MainWorkerChannelEvent.Init",e.BindMainWorkerPort="MainWorkerChannelEvent.BindMainWorkerPort",e.CallRust="MainWorkerChannelEvent.CallRust",e.SendEventFromAnyThread="MainWorkerChannelEvent.SendEventFromAnyThread"}(F||(F={}));var R,T=function(e,t,r,s){return new(r||(r=Promise))((function(n,i){function a(e){try{d(s.next(e))}catch(e){i(e)}}function o(e){try{d(s.throw(e))}catch(e){i(e)}}function d(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,o)}d((s=s.apply(e,t||[])).next())}))};const P=new c(self),S=(null===(R=self.navigator)||void 0===R?void 0:R.userAgent.toLowerCase().indexOf("firefox"))>-1;let W;const{wrapWasmExports:x}=(e=>{const t=()=>{if(1!==Atomics.load(W,0))throw new Error("Zaplib WebAssembly instance crashed")};return{checkWasm:t,wrapWasmExports:e=>new Proxy(e,{get:function(e,r){return t(),e[r]}})}})();class I{constructor({offscreenCanvas:e,wasmModule:t,wasmExports:r,memory:s,sizingData:n,baseUri:i,fileHandles:a,taskWorkerSab:o}){this.xrCanPresent=!1,this.xrIsPresenting=!1,this.sendFnTable=[function(e){return!0},function(e){const t=e.zerdeParser.parseU64();e.webglRenderer?(e.webglRenderer.processMessages(Number(t)),e.exports.deallocWasmMessage(t)):e.runWebGLPromise=P.send(y.RunWebGL,Number(t)).then((()=>{e.exports.deallocWasmMessage(t),e.runWebGLPromise=void 0}))},function(e){console.log(e.zerdeParser.parseString())},function(e){e.requestAnimationFrame()},function(e){e.setDocumentTitle(e.zerdeParser.parseString())},function(e){e.setMouseCursor(e.zerdeParser.parseU32())},function(e){const t=e.zerdeParser.parseF32(),r=e.zerdeParser.parseF32();P.send(y.ShowTextIME,{x:t,y:r})},function(e){},function(e){const t=e.zerdeParser.parseString();P.send(y.TextCopyResponse,t)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseF64(),s=e.zerdeParser.parseF64();e.startTimer(r,s,t)},function(e){const t=e.zerdeParser.parseF64();e.stopTimer(t)},function(e){e.xrStartPresenting()},function(e){e.xrStopPresenting()},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),s=e.zerdeParser.parseString(),n=e.zerdeParser.parseString(),i=e.zerdeParser.parseString(),a=e.zerdeParser.parseString(),o=e.zerdeParser.parseString(),d=e.zerdeParser.parseU8Slice();e.httpSend(s,n,i,a,t,o,d,r)},function(e){P.send(y.Fullscreen)},function(e){P.send(y.Normalscreen)},function(e){const t=e.zerdeParser.parseString(),r=e.zerdeParser.parseU8Slice();e.websocketSend(t,r)},function(e){e.enableGlobalFileDropTarget()},function(e){const t=e.zerdeParser.parseString(),r=e.zerdeParser.parseZapParams();if("_zaplibReturnParams"===t){const t=JSON.parse(r[0]);e.callRustPendingCallbacks[t](r.slice(1)),delete e.callRustPendingCallbacks[t]}else P.send(y.CallJs,{fnName:t,params:r})}],this.module=t,this.exports=r,this.memory=s,this.baseUri=i,this.sizingData=n,this.timers=[],this.hasRequestedAnimationFrame=!1,this.websockets={},this.fileHandles=a,this.callRustNewCallbackId=0,this.callRustPendingCallbacks={},e&&(this.webglRenderer=new z(e,this.memory,this.sizingData,(()=>{P.send(y.ShowIncompatibleBrowserNotification)}))),P.receive(y.ScreenResize,(e=>{this.sizingData=e,this.webglRenderer&&this.webglRenderer.resize(this.sizingData),this.zerdeEventloopEvents.resize({width:this.sizingData.width,height:this.sizingData.height,dpiFactor:this.sizingData.dpiFactor,xrIsPresenting:this.xrIsPresenting,xrCanPresent:this.xrCanPresent,isFullscreen:this.sizingData.isFullscreen}),this.requestAnimationFrame()})),this.bindMouseAndTouch(),this.bindKeyboard(),this.appPtr=this.exports.createWasmApp(),P.receive(y.WindowFocus,(()=>{this.zerdeEventloopEvents.windowFocus(!0),this.doWasmIo()})),P.receive(y.WindowBlur,(()=>{this.zerdeEventloopEvents.windowFocus(!1),this.doWasmIo()}));const d=({name:e,params:t})=>{const r=this.callRustNewCallbackId++,s=new Promise(((e,t)=>{this.callRustPendingCallbacks[r]=t=>{e(t)}}));return this.zerdeEventloopEvents.callRust(e,t,r),this.doWasmIo(),s};P.receive(y.CallRust,d),P.receive(y.CreateBuffer,(e=>this.zerdeEventloopEvents.createWasmBuffer(e))),P.receive(y.CreateReadOnlyBuffer,(e=>{const t=this.zerdeEventloopEvents.createWasmBuffer(e);return{bufferPtr:t,arcPtr:this.zerdeEventloopEvents.createArcVec(t,e)}})),P.receive(y.IncrementArc,(e=>{this.exports.incrementArc(BigInt(e))})),P.receive(y.DecrementArc,(e=>{this.exports.decrementArc(BigInt(e))})),P.receive(y.DeallocVec,(({bufferPtr:e,bufferLen:t,bufferCap:r})=>{this.exports.deallocVec(BigInt(e),BigInt(t),BigInt(r))}));const l=e=>{const t=new c(e);t.receive(F.Init,(()=>({wasmModule:this.module,memory:this.memory,taskWorkerSab:o,appPtr:this.appPtr,baseUri:i,tlsAndStackData:u(this.exports),wasmOnline:W}))),t.receive(F.BindMainWorkerPort,(e=>{l(e)})),t.receive(F.CallRust,d),t.receive(F.SendEventFromAnyThread,(e=>{this.sendEventFromAnyThread(e)}))};P.receive(y.BindMainWorkerPort,(e=>{l(e)})),Atomics.store(W,0,1),this.exports=x(this.exports),P.send(y.RemoveLoadingIndicators),this.zerdeEventloopEvents=new v(this),this.zerdeEventloopEvents.init({width:this.sizingData.width,height:this.sizingData.height,dpiFactor:this.sizingData.dpiFactor,xrCanPresent:this.xrCanPresent,canFullscreen:this.sizingData.canFullscreen,xrIsPresenting:!1}),this.doWasmIo()}doWasmIo(){if(this.doWasmBlock)return;const e=this.zerdeEventloopEvents.end(),t=Number(this.exports.processWasmEvents(this.appPtr,BigInt(e)));for(this.zerdeEventloopEvents=new v(this),this.zerdeParser=new d(this.memory,t);;){const e=this.zerdeParser.parseU32();if(this.sendFnTable[e](this))break}this.exports.deallocWasmMessage(BigInt(t))}setDocumentTitle(e){P.send(y.SetDocumentTitle,e)}bindMouseAndTouch(){let e;const t=[];function r(e){const r=t[e.button]||(t[e.button]={});return r.x=e.pageX,r.y=e.pageY,r.button=e.button,r.digit=e.button,r.time=performance.now()/1e3,r.modifiers=_(e),r.touch=!1,r}const s=[];P.receive(y.CanvasMouseDown,(e=>{s[e.button]=!0,this.zerdeEventloopEvents.pointerDown(r(e)),this.doWasmIo()})),P.receive(y.WindowMouseUp,(e=>{s[e.button]=!1,this.zerdeEventloopEvents.pointerUp(r(e)),this.doWasmIo()})),P.receive(y.WindowMouseMove,(t=>{for(let e=0;e<s.length;e++)if(s[e]){const s=r(t);s.digit=e,this.zerdeEventloopEvents.pointerMove(s)}e=r(t),this.zerdeEventloopEvents.pointerHover(e),this.doWasmIo()})),P.receive(y.WindowMouseOut,(e=>{this.zerdeEventloopEvents.pointerOut(r(e)),this.doWasmIo()}));const n=[];let i,a;P.receive(y.WindowTouchStart,(e=>{for(const t of e.changedTouches){let r=n.indexOf(void 0);-1===r&&(r=n.length),n[r]=t.identifier,this.zerdeEventloopEvents.pointerDown({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0})}this.doWasmIo()})),P.receive(y.WindowTouchMove,(e=>{for(const t of e.changedTouches){const r=n.indexOf(t.identifier);-1!=r?this.zerdeEventloopEvents.pointerMove({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0}):console.error("Unrecognized digit in WorkerEvent.WindowTouchMove")}this.doWasmIo()})),P.receive(y.WindowTouchEndCancelLeave,(e=>{for(const t of e.changedTouches){const r=n.indexOf(t.identifier);-1!=r?(n[r]=void 0,this.zerdeEventloopEvents.pointerUp({x:t.pageX,y:t.pageY,button:0,digit:r,time:performance.now()/1e3,modifiers:_(e),touch:!0})):console.error("Unrecognized digit in WorkerEvent.WindowTouchMove")}this.doWasmIo()})),P.receive(y.CanvasWheel,(e=>{const t=r(e),s=e.timeStamp-i;i=e.timeStamp,a=S?1==e.deltaMode:!(Math.abs(Math.abs(e.deltaY/e.wheelDeltaY)-1/3)<1e-5||!a&&s<250);let n=1;1===e.deltaMode?n=40:2===e.deltaMode&&(n=800);const o=Object.assign(Object.assign({},t),{scrollX:e.deltaX*n,scrollY:e.deltaY*n,isWheel:a});this.zerdeEventloopEvents.pointerScroll(o),this.doWasmIo()}))}bindKeyboard(){P.receive(y.TextInput,(e=>{this.zerdeEventloopEvents.textInput(e),this.doWasmIo()})),P.receive(y.TextCopy,(()=>{this.zerdeEventloopEvents.textCopy(),this.doWasmIo()})),P.receive(y.KeyDown,(e=>{this.zerdeEventloopEvents.keyDown(e),this.doWasmIo()})),P.receive(y.KeyUp,(e=>{this.zerdeEventloopEvents.keyUp(e),this.doWasmIo()}))}setMouseCursor(t){P.send(y.SetMouseCursor,e[t]||"default")}startTimer(e,t,r){for(let t=0;t<this.timers.length;t++)if(this.timers[t].id==e)return void console.log("Timer ID collision!");const s=0!==r?self.setInterval((()=>{this.zerdeEventloopEvents.timerFired(e),this.doWasmIo()}),1e3*t):self.setTimeout((()=>{for(let t=0;t<this.timers.length;t++)if(this.timers[t].id==e){this.timers.splice(t,1);break}this.zerdeEventloopEvents.timerFired(e),this.doWasmIo()}),1e3*t);this.timers.push({id:e,repeats:r,sysId:s})}stopTimer(e){for(let t=0;t<this.timers.length;t++){const r=this.timers[t];if(r.id==e)return r.repeats?self.clearInterval(r.sysId):self.clearTimeout(r.sysId),void this.timers.splice(t,1)}}httpSend(e,t,r,s,n,i,a,o){const d=new XMLHttpRequest;d.addEventListener("error",(e=>{this.zerdeEventloopEvents.httpSendResponse(o,2),this.doWasmIo()})),d.addEventListener("load",(e=>{200!==d.status?this.zerdeEventloopEvents.httpSendResponse(o,2):this.zerdeEventloopEvents.httpSendResponse(o,1),this.doWasmIo()})),d.open(e,r+"://"+s+":"+n+t,!0),console.log(e,r+"://"+s+":"+n+t,a),d.send(a.buffer)}websocketSend(e,t){const r=this.websockets[e];if(r)r.sendStack?r.sendStack.push(t):r.send(t);else{const r=new WebSocket(e);this.websockets[e]=r,r.sendStack=[t],r.addEventListener("close",(()=>{this.websockets[e]=null})),r.addEventListener("error",(t=>{this.websockets[e]=null,this.zerdeEventloopEvents.websocketError(e,""+t),this.doWasmIo()})),r.addEventListener("message",(t=>{t.data.arrayBuffer().then((t=>{this.zerdeEventloopEvents.websocketMessage(e,t),this.doWasmIo()}))})),r.addEventListener("open",(()=>{const e=r.sendStack;for(t of(r.sendStack=null,e))r.send(t)}))}}enableGlobalFileDropTarget(){P.send(y.EnableGlobalFileDropTarget),P.receive(y.DragEnter,(()=>{this.zerdeEventloopEvents.dragenter(),this.doWasmIo()})),P.receive(y.DragOver,(({x:e,y:t})=>{this.zerdeEventloopEvents.dragover(e,t),this.doWasmIo()})),P.receive(y.DragLeave,(()=>{this.zerdeEventloopEvents.dragleave(),this.doWasmIo()})),P.receive(y.Drop,(({fileHandles:e,fileHandlesToSend:t})=>{this.fileHandles.splice(0,this.fileHandles.length),this.fileHandles.push(...e),this.zerdeEventloopEvents.appOpenFiles(t),this.doWasmIo()}))}requestAnimationFrame(){return T(this,void 0,void 0,(function*(){this.xrIsPresenting||this.hasRequestedAnimationFrame||(this.hasRequestedAnimationFrame=!0,this.runWebGLPromise&&(yield this.runWebGLPromise),(self.requestAnimationFrame||self.setTimeout)((()=>T(this,void 0,void 0,(function*(){if(this.runWebGLPromise&&(yield this.runWebGLPromise),this.hasRequestedAnimationFrame=!1,!this.xrIsPresenting){this.zerdeEventloopEvents.animationFrame();try{this.doWasmIo()}catch(e){if(!(e instanceof Error&&"RustPanic"===e.name))throw e;Atomics.store(W,0,0),P.send(y.Panic,e)}}})))))}))}xrStartPresenting(){}xrStopPresenting(){}sendEventFromAnyThread(e){setTimeout((()=>{try{this.zerdeEventloopEvents.sendEventFromAnyThread(e),this.doWasmIo()}catch(e){if(!(e instanceof Error&&"RustPanic"===e.name))throw e;Atomics.store(W,0,0),P.send(y.Panic,e)}}))}}P.receive(y.Init,(({wasmModule:e,offscreenCanvas:t,sizingData:r,baseUri:s,memory:n,taskWorkerSab:i,wasmOnline:a})=>{let o;return W=a,new Promise(((a,d)=>{const l=[],h=(({getExports:e,memory:t,taskWorkerSab:r,fileHandles:s,sendEventFromAnyThread:n,threadSpawn:i,baseUri:a})=>{const o=(e,r)=>{let s="";const n=new Uint32Array(t.buffer,e,r);for(let e=0;e<r;e++)s+=String.fromCharCode(n[e]);return s};return{memory:t,_consoleLog:(e,t)=>{const r=o(parseInt(e),parseInt(t));console.log(r)},_throwError:(e,t)=>{throw new E(o(parseInt(e),parseInt(t)))},readUserFileRange:(e,r,n,i)=>{const a=s[e],o=Number(i),d=o+Number(n);a.lastReadStart<=o&&o<a.lastReadEnd&&console.warn(`Read start (${o}) fell in the range of the last read (${a.lastReadStart}-${a.lastReadEnd}); this usually happens if you don\'t use BufReader or if you don\'t use BufReader.seek_relative.`),a.lastReadStart=o,a.lastReadEnd=d;const l=(new FileReaderSync).readAsArrayBuffer(a.file.slice(o,d));return f(new Uint8Array(l),t.buffer,Number(r)),BigInt(l.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{i(e)},_sendEventFromAnyThread:e=>{n(e)},readUrlSync:(r,s,n,i)=>{const d=o(r,s),l=new XMLHttpRequest;if(l.responseType="arraybuffer",l.open("GET",new URL(d,a).href,!1),l.send(null),200===l.status){const r=e(),s=m(t,r,new Uint8Array(l.response));return new Uint32Array(t.buffer,n,1)[0]=s,new Uint32Array(t.buffer,i,1)[0]=l.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,t)=>{const r=new Int32Array(e);((e,t)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(r);const s=r[1];new Uint32Array(e)[s+2]=t,r[1]=s+1,((e,t)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error("Called mutex_unlock on an already unlocked mutex");Atomics.notify(e,0,1)})(r),Atomics.notify(r,1)})(r,parseInt(e))}}})({getExports:()=>o.exports,memory:n,taskWorkerSab:i,fileHandles:l,sendEventFromAnyThread:e=>{o.sendEventFromAnyThread(e)},threadSpawn:e=>{P.send(y.ThreadSpawn,{ctxPtr:e,tlsAndStackData:u(o.exports)})},baseUri:s});WebAssembly.instantiate(e,{env:h}).then((d=>{const h=d.exports;(e=>{const t=e.allocWasmMessage(BigInt(e.__tls_size.value));e.__wasm_init_tls(Number(t))})(h),o=new I({offscreenCanvas:t,wasmModule:e,wasmExports:h,memory:n,sizingData:r,baseUri:s,fileHandles:l,taskWorkerSab:i}),a()}),d)}))}))})();\n',"Worker",void 0,void 0)}function l(){return o()('(()=>{"use strict";var e,r;(r=e||(e={}))[r.String=0]="String",r[r.ReadOnlyU8Buffer=1]="ReadOnlyU8Buffer",r[r.U8Buffer=2]="U8Buffer",r[r.F32Buffer=3]="F32Buffer",r[r.ReadOnlyF32Buffer=4]="ReadOnlyF32Buffer",self;class t extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class r extends e{constructor(...r){const n=r[0];if("object"==typeof n&&n instanceof t){if(r.length<2&&(r[1]=n.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<n.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=n.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=n}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const a={Int8Array:"ZapInt8Array",Uint8Array:"ZapUint8Array",Uint8ClampedArray:"ZapUint8ClampedArray",Int16Array:"ZapInt16Array",Uint16Array:"ZapUint16Array",Uint16ClampedArray:"ZapUint16ClampedArray",Int32Array:"ZapInt32Array",Uint32Array:"ZapUint32Array",Float32Array:"ZapFloat32Array",Float64Array:"ZapFloat64Array",BigInt64Array:"ZapBigInt64Array",BigUint64Array:"ZapBigUint64Array",DataView:"ZapDataView"};for(const[e,r]of Object.entries(a))e in self&&(self[r]=n(self[e]));new WeakMap;const o={};new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete o[e],r&&r(e)})),new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)}));const s="$$RESPONSE",i="$$ERROR";class l{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===s)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:s,id:r},[]);const t=e[l.transferrables];delete e[l.transferrables];const n={topic:s,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:s,id:r,data:{[i]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error("channel.onmessage is already set. Can only use one Rpc instance per channel.");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,a={topic:e,id:n,data:r},o=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[i]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(a,t),o}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error("Rpc postMessage call itself failed: ",e)}}}l.transferrables="$$TRANSFERRABLES";const c=e=>{const r=8*Math.ceil((e.__tls_size.value+2097152)/8);return{ptr:e.allocWasmMessage(BigInt(r)),size:r}},u=(e,r,t)=>{new e.constructor(r,t,e.length).set(e)},f=({getExports:e,memory:r,taskWorkerSab:t,fileHandles:n,sendEventFromAnyThread:a,threadSpawn:o,baseUri:s})=>{const i=(e,t)=>{let n="";const a=new Uint32Array(r.buffer,e,t);for(let e=0;e<t;e++)n+=String.fromCharCode(a[e]);return n};return{memory:r,_consoleLog:(e,r)=>{const t=i(parseInt(e),parseInt(r));console.log(t)},_throwError:(e,r)=>{throw new d(i(parseInt(e),parseInt(r)))},readUserFileRange:(e,t,a,o)=>{const s=n[e],i=Number(o),l=i+Number(a);s.lastReadStart<=i&&i<s.lastReadEnd&&console.warn(`Read start (${i}) fell in the range of the last read (${s.lastReadStart}-${s.lastReadEnd}); this usually happens if you don\'t use BufReader or if you don\'t use BufReader.seek_relative.`),s.lastReadStart=i,s.lastReadEnd=l;const c=(new FileReaderSync).readAsArrayBuffer(s.file.slice(i,l));return u(new Uint8Array(c),r.buffer,Number(t)),BigInt(c.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{o(e)},_sendEventFromAnyThread:e=>{a(e)},readUrlSync:(t,n,a,o)=>{const l=i(t,n),c=new XMLHttpRequest;if(c.responseType="arraybuffer",c.open("GET",new URL(l,s).href,!1),c.send(null),200===c.status){const t=e(),n=((e,r,t)=>{const n=Number(r.allocWasmVec(BigInt(t.byteLength)));return u(t,e.buffer,n),n})(r,t,new Uint8Array(c.response));return new Uint32Array(r.buffer,a,1)[0]=n,new Uint32Array(r.buffer,o,1)[0]=c.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,r)=>{const t=new Int32Array(e);((e,r)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(t);const n=t[1];new Uint32Array(e)[n+2]=r,t[1]=n+1,((e,r)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error("Called mutex_unlock on an already unlocked mutex");Atomics.notify(e,0,1)})(t),Atomics.notify(t,1)})(t,parseInt(e))}}};class d extends Error{constructor(e){super(e),this.name="RustPanic"}}var p,h,E,y;!function(e){e.CallRust="WorkerEvent.CallRust",e.CreateBuffer="WorkerEvent.CreateBuffer",e.CreateReadOnlyBuffer="WorkerEvent.CreateReadOnlyBuffer",e.BindMainWorkerPort="WorkerEvent.BindMainWorkerPort",e.DecrementArc="WorkerEvent.DecrementArc",e.DeallocVec="WorkerEvent.DeallocVec",e.IncrementArc="WorkerEvent.IncrementArc",e.DragEnter="WorkerEvent.DragEnter",e.DragOver="WorkerEvent.DragOver",e.DragLeave="WorkerEvent.DragLeave",e.Drop="WorkerEvent.Drop",e.WindowMouseUp="WorkerEvent.WindowMouseUp",e.CanvasMouseDown="WorkerEvent.CanvasMouseDown",e.WindowMouseMove="WorkerEvent.WindowMouseMove",e.WindowMouseOut="WorkerEvent.WindowMouseOut",e.WindowFocus="WorkerEvent.WindowFocus",e.WindowBlur="WorkerEvent.WindowBlur",e.ScreenResize="WorkerEvent.ScreenResize",e.CanvasWheel="WorkerEvent.CanvasWheel",e.ShowIncompatibleBrowserNotification="WorkerEvent.ShowIncompatibleBrowserNotification",e.RemoveLoadingIndicators="WorkerEvent.RemoveLoadingIndicators",e.SetDocumentTitle="WorkerEvent.SetDocumentTitle",e.SetMouseCursor="WorkerEvent.SetMouseCursor",e.Fullscreen="WorkerEvent.Fullscreen",e.Normalscreen="WorkerEvent.Normalscreen",e.TextCopyResponse="WorkerEvent.TextCopyResponse",e.EnableGlobalFileDropTarget="WorkerEvent.EnableGlobalFileDropTarget",e.CallJs="WorkerEvent.CallJs",e.ShowTextIME="WorkerEvent.ShowTextIME",e.TextInput="WorkerEvent.TextInput",e.TextCopy="WorkerEvent.TextCopy",e.KeyDown="WorkerEvent.KeyDown",e.KeyUp="WorkerEvent.KeyUp",e.Init="WorkerEvent.Init",e.RunWebGL="WorkerEvent.RunWebGL",e.ThreadSpawn="WorkerEvent.ThreadSpawn",e.WindowTouchStart="WorkerEvent.WindowTouchStart",e.WindowTouchMove="WorkerEvent.WindowTouchMove",e.WindowTouchEndCancelLeave="WorkerEvent.WindowTouchEndCancelLeave",e.Panic="WorkerEvent.Panic"}(p||(p={})),function(e){e.Init="TaskWorkerEvent.Init"}(h||(h={})),function(e){e.Run="AsyncWorkerEvent.Run",e.ThreadSpawn="AsyncWorkerEvent.ThreadSpawn"}(E||(E={})),function(e){e.Init="MainWorkerChannelEvent.Init",e.BindMainWorkerPort="MainWorkerChannelEvent.BindMainWorkerPort",e.CallRust="MainWorkerChannelEvent.CallRust",e.SendEventFromAnyThread="MainWorkerChannelEvent.SendEventFromAnyThread"}(y||(y={}));const v=new l(self);v.receive(E.Run,(({wasmModule:e,memory:r,taskWorkerSab:t,ctxPtr:n,fileHandles:a,baseUri:o,tlsAndStackData:s,mainWorkerPort:i})=>{let u;const d=new l(i),p=f({getExports:()=>u,memory:r,taskWorkerSab:t,fileHandles:a,sendEventFromAnyThread:e=>{d.send(y.SendEventFromAnyThread,e)},threadSpawn:e=>{v.send(E.ThreadSpawn,{ctxPtr:e,tlsAndStackData:c(u)})},baseUri:o});return new Promise(((r,t)=>{WebAssembly.instantiate(e,{env:p}).then((e=>{u=e.exports,((e,r)=>{e.__stack_pointer.value=Number(r.ptr)+r.size-8,e.__wasm_init_tls(Number(r.ptr))})(u,s),u.runFunctionPointer(n),r()}),t)}))}))})();\n',"Worker",void 0,void 0)}function f(){return o()('(()=>{"use strict";var e,r;(r=e||(e={}))[r.String=0]="String",r[r.ReadOnlyU8Buffer=1]="ReadOnlyU8Buffer",r[r.U8Buffer=2]="U8Buffer",r[r.F32Buffer=3]="F32Buffer",r[r.ReadOnlyF32Buffer=4]="ReadOnlyF32Buffer",self;class t extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function n(e){return class r extends e{constructor(...r){const n=r[0];if("object"==typeof n&&n instanceof t){if(r.length<2&&(r[1]=n.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<n.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>n.__zaplibBufferData.bufferPtr+n.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=n.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=n}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const s={Int8Array:"ZapInt8Array",Uint8Array:"ZapUint8Array",Uint8ClampedArray:"ZapUint8ClampedArray",Int16Array:"ZapInt16Array",Uint16Array:"ZapUint16Array",Uint16ClampedArray:"ZapUint16ClampedArray",Int32Array:"ZapInt32Array",Uint32Array:"ZapUint32Array",Float32Array:"ZapFloat32Array",Float64Array:"ZapFloat64Array",BigInt64Array:"ZapBigInt64Array",BigUint64Array:"ZapBigUint64Array",DataView:"ZapDataView"};for(const[e,r]of Object.entries(s))e in self&&(self[r]=n(self[e]));new WeakMap;const a={};new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete a[e],r&&r(e)})),new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)}));class o{constructor(e,r){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,r),this._u32=new Uint32Array(this._memory.buffer,r),this._f64=new Float64Array(this._memory.buffer,r),this._u64=new BigUint64Array(this._memory.buffer,r)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e="";const r=this.parseU32();for(let t=0;t<r;t++){const r=this.parseU32();0!=r&&(e+=String.fromCharCode(r))}return e}parseU8Slice(){const e=this.parseU32(),r=e>>2,t=new Uint8Array(e),n=3&e;for(let e=0;e<r;e++){const r=e<<2,n=this.parseU32();t[r+0]=255&n,t[r+1]=n>>8&255,t[r+2]=n>>16&255,t[r+3]=n>>24&255}const s=r<<2;if(1==n){const e=this.parseU32();t[s+0]=255&e}else if(2==n){const e=this.parseU32();t[s+0]=255&e,t[s+1]=e>>8&255}else if(3==n){const e=this.parseU32();t[s+0]=255&e,t[s+1]=e>>8&255,t[s+2]=e>>16&255}return t}parseZapParams(){const r=this.parseU32(),t=[];for(let n=0;n<r;++n){const r=this.parseU32();if(r===e.String)t.push(this.parseString());else if(r===e.ReadOnlyU8Buffer||r===e.ReadOnlyF32Buffer){const e=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,arcPtr:s,readonly:!0})}else{if(r!==e.U8Buffer&&r!==e.F32Buffer)throw new Error(`Unknown ZapParam type: ${r}`);{const e=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,bufferCap:s,readonly:!1})}}}return t}}const i="$$RESPONSE",f="$$ERROR";class u{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===i)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:i,id:r},[]);const t=e[u.transferrables];delete e[u.transferrables];const n={topic:i,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:i,id:r,data:{[f]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error("channel.onmessage is already set. Can only use one Rpc instance per channel.");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,s={topic:e,id:n,data:r},a=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[f]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(s,t),a}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error("Rpc postMessage call itself failed: ",e)}}}u.transferrables="$$TRANSFERRABLES";const l=(e,r)=>{for(;;){if(0==Atomics.compareExchange(e,r,0,1))return;Atomics.wait(e,r,1)}},c=(e,r)=>{if(1!=Atomics.compareExchange(e,r,1,0))throw new Error("Called mutex_unlock on an already unlocked mutex");Atomics.notify(e,r,1)};function h(e,r="Value"){if(null==e)throw new Error(`Assertion failed: ${r} is null`);return e}var d,p,y,v;Error,function(e){e.CallRust="WorkerEvent.CallRust",e.CreateBuffer="WorkerEvent.CreateBuffer",e.CreateReadOnlyBuffer="WorkerEvent.CreateReadOnlyBuffer",e.BindMainWorkerPort="WorkerEvent.BindMainWorkerPort",e.DecrementArc="WorkerEvent.DecrementArc",e.DeallocVec="WorkerEvent.DeallocVec",e.IncrementArc="WorkerEvent.IncrementArc",e.DragEnter="WorkerEvent.DragEnter",e.DragOver="WorkerEvent.DragOver",e.DragLeave="WorkerEvent.DragLeave",e.Drop="WorkerEvent.Drop",e.WindowMouseUp="WorkerEvent.WindowMouseUp",e.CanvasMouseDown="WorkerEvent.CanvasMouseDown",e.WindowMouseMove="WorkerEvent.WindowMouseMove",e.WindowMouseOut="WorkerEvent.WindowMouseOut",e.WindowFocus="WorkerEvent.WindowFocus",e.WindowBlur="WorkerEvent.WindowBlur",e.ScreenResize="WorkerEvent.ScreenResize",e.CanvasWheel="WorkerEvent.CanvasWheel",e.ShowIncompatibleBrowserNotification="WorkerEvent.ShowIncompatibleBrowserNotification",e.RemoveLoadingIndicators="WorkerEvent.RemoveLoadingIndicators",e.SetDocumentTitle="WorkerEvent.SetDocumentTitle",e.SetMouseCursor="WorkerEvent.SetMouseCursor",e.Fullscreen="WorkerEvent.Fullscreen",e.Normalscreen="WorkerEvent.Normalscreen",e.TextCopyResponse="WorkerEvent.TextCopyResponse",e.EnableGlobalFileDropTarget="WorkerEvent.EnableGlobalFileDropTarget",e.CallJs="WorkerEvent.CallJs",e.ShowTextIME="WorkerEvent.ShowTextIME",e.TextInput="WorkerEvent.TextInput",e.TextCopy="WorkerEvent.TextCopy",e.KeyDown="WorkerEvent.KeyDown",e.KeyUp="WorkerEvent.KeyUp",e.Init="WorkerEvent.Init",e.RunWebGL="WorkerEvent.RunWebGL",e.ThreadSpawn="WorkerEvent.ThreadSpawn",e.WindowTouchStart="WorkerEvent.WindowTouchStart",e.WindowTouchMove="WorkerEvent.WindowTouchMove",e.WindowTouchEndCancelLeave="WorkerEvent.WindowTouchEndCancelLeave",e.Panic="WorkerEvent.Panic"}(d||(d={})),function(e){e.Init="TaskWorkerEvent.Init"}(p||(p={})),function(e){e.Run="AsyncWorkerEvent.Run",e.ThreadSpawn="AsyncWorkerEvent.ThreadSpawn"}(y||(y={})),function(e){e.Init="MainWorkerChannelEvent.Init",e.BindMainWorkerPort="MainWorkerChannelEvent.BindMainWorkerPort",e.CallRust="MainWorkerChannelEvent.CallRust",e.SendEventFromAnyThread="MainWorkerChannelEvent.SendEventFromAnyThread"}(v||(v={})),new u(self).receive(p.Init,(({taskWorkerSab:e,wasmMemory:r})=>{const t=new Int32Array(e);let n=0,s=1;const a={};function i(e,t){const n=new Int32Array(r.buffer,e,1);if(n[0]===t)throw new Error("Have to set the return value to something different than the initial value, otherwise Atomics.notify won\'t do anything");n[0]=t,Atomics.notify(n,0)}function f(e){const r=a[e];n++,r.reader.read().then((t=>{n--,t.done?r.done=!0:(r.values.push(t.value),f(e)),u(e)})).catch((t=>{n--,console.error("fetch read error",t),r.error=!0,u(e)}))}function u(e){const t=a[e];if(!t.currentTwMessage)return;if(t.error)return i(t.currentTwMessage.bytesReadReturnValPtr,-2),void(t.currentTwMessage=void 0);if(0===t.values.length)return void(t.done&&(i(t.currentTwMessage.bytesReadReturnValPtr,0),t.currentTwMessage=void 0));let n=0;for(;t.values.length>0&&n<t.currentTwMessage.bufLen;){const e=t.values[0],s=t.currentTwMessage.bufLen-n,a=Math.min(e.byteLength,s),o=new Uint8Array(e.buffer,e.byteOffset,a);new Uint8Array(r.buffer,t.currentTwMessage.bufPtr+n,a).set(o),a<e.byteLength?t.values[0]=new Uint8Array(e.buffer,e.byteOffset+a,e.byteLength-a):t.values.shift(),n+=a}i(t.currentTwMessage.bytesReadReturnValPtr,n),t.currentTwMessage=void 0}function d(e){const r=e.parseU32();if(1==r){const r=e.parseU32(),t=e.parseString(),o=e.parseString(),u=e.parseU8Slice(),l=e.parseU32(),c={};for(let r=0;r<l;r++)c[e.parseString()]=e.parseString();n++,fetch(t,{method:o,body:u,headers:c}).then((e=>{if(n--,e.ok){const t=s++;a[t]={reader:h(e.body).getReader(),values:[],done:!1,error:!1,currentTwMessage:void 0},f(t),i(r,t)}else i(r,-2)})).catch((e=>{n--,console.error("fetch create error",e),i(r,-2)}))}else if(2==r){const r={bytesReadReturnValPtr:e.parseU32(),streamId:e.parseU32(),bufPtr:e.parseU32(),bufLen:e.parseU32()};if(a[r.streamId].currentTwMessage)return console.error("Got multiple http_stream_read messages in a row"),void i(r.bytesReadReturnValPtr,-2);a[r.streamId].currentTwMessage=r,u(r.streamId)}}setTimeout((function s(){for(;;){if(Atomics.load(t,1)>0){l(t,0);const n=t[1];for(let t=0;t<n;t++){const n=new Uint32Array(e)[t+2];d(new o(r,n))}t[1]=0,c(t,0)}if(n>0){setTimeout(s,1);break}Atomics.wait(t,1,0)}}),0)}))})();\n',"Worker",void 0,void 0)}var c=r(760),d=r(90);const u=e=>({pageX:e.pageX,pageY:e.pageY,button:e.button,shiftKey:e.shiftKey,ctrlKey:e.ctrlKey,metaKey:e.metaKey,altKey:e.altKey}),h=e=>({shiftKey:e.shiftKey,ctrlKey:e.ctrlKey,metaKey:e.metaKey,altKey:e.altKey,changedTouches:Array.from(e.changedTouches).map((e=>({pageX:e.pageX,pageY:e.pageY,identifier:e.identifier})))}),p=e=>({keyCode:e.keyCode,repeat:e.repeat,shiftKey:e.shiftKey,ctrlKey:e.ctrlKey,metaKey:e.metaKey,altKey:e.altKey});var y,g,m,b;function _(e){let t,r;function n(){setTimeout((()=>{var e;t&&document.activeElement!==t&&!(null===(e=document.getElementById("zaplib_js_root"))||void 0===e?void 0:e.contains(document.activeElement))&&t.focus()}))}document.addEventListener("mousedown",n,!0),document.addEventListener("mouseup",n,!0),document.addEventListener("focus",n,!0),document.addEventListener("blur",n,!0);const s=()=>{r?(t.style.left=Math.round(r.x)-4+"px",t.style.top=Math.round(r.y)+"px"):(t.style.left="-100px",t.style.top="-100px")};let a=!1,o=0,i=!1;const l=function(){t&&document.body.removeChild(t),t=document.createElement("textarea"),t.className="zaplib_textarea",t.setAttribute("autocomplete","off"),t.setAttribute("autocorrect","off"),t.setAttribute("autocapitalize","off"),t.setAttribute("spellcheck","false"),t.style.left="-100px",t.style.top="-100px",t.style.height="1px",t.style.width="1px",t.addEventListener("contextmenu",(e=>(e.preventDefault(),!1))),document.body.appendChild(t),t.focus(),s(),t.addEventListener("cut",(()=>{setTimeout((()=>{t.value="",o=0}))})),t.addEventListener("copy",(()=>{setTimeout((()=>{t.value="",o=0}))})),t.addEventListener("paste",(()=>{a=!0})),t.addEventListener("input",(()=>{if(t.value.length>0)if(a){a=!1;const r=t.value.substring(o);t.value="",e({type:y.TextInput,wasPaste:!0,input:r,replaceLast:!1})}else{let r=!1,n=t.value;t.value.length>=2?(n=t.value.substring(1,2),t.value=n):1==t.value.length&&o==t.value.length&&(r=!0),(r||"\n"!=n)&&e({type:y.TextInput,wasPaste:!1,input:n,replaceLast:r})}o=t.value.length})),t.addEventListener("keydown",(r=>{const n=r.keyCode;18!=n&&17!=n&&16!=n||r.preventDefault(),8!==n&&9!==n||r.preventDefault(),89===n&&(r.metaKey||r.ctrlKey)&&r.preventDefault(),83===n&&(r.metaKey||r.ctrlKey)&&r.preventDefault(),n>=33&&n<=40&&(t.value="",o=t.value.length),88!==n&&67!=n||!r.metaKey&&!r.ctrlKey||(e({type:y.TextCopy}),r.preventDefault()),90===n&&(r.metaKey||r.ctrlKey)&&(s(),t.value="",i=!0,t.readOnly=!0,r.preventDefault()),e({type:y.KeyDown,event:p(r)})})),t.addEventListener("keyup",(t=>{const r=t.keyCode;18!=r&&17!=r&&16!=r||t.preventDefault(),91==r&&t.preventDefault(),i&&(i=!1,l()),e({type:y.KeyUp,event:p(t)})}))};return l(),{showTextIME:function({x:e,y:t}){r={x:e,y:t},s()},textareaHasFocus:function(){return document.activeElement==t}}}!function(e){e.CallRust="WorkerEvent.CallRust",e.CreateBuffer="WorkerEvent.CreateBuffer",e.CreateReadOnlyBuffer="WorkerEvent.CreateReadOnlyBuffer",e.BindMainWorkerPort="WorkerEvent.BindMainWorkerPort",e.DecrementArc="WorkerEvent.DecrementArc",e.DeallocVec="WorkerEvent.DeallocVec",e.IncrementArc="WorkerEvent.IncrementArc",e.DragEnter="WorkerEvent.DragEnter",e.DragOver="WorkerEvent.DragOver",e.DragLeave="WorkerEvent.DragLeave",e.Drop="WorkerEvent.Drop",e.WindowMouseUp="WorkerEvent.WindowMouseUp",e.CanvasMouseDown="WorkerEvent.CanvasMouseDown",e.WindowMouseMove="WorkerEvent.WindowMouseMove",e.WindowMouseOut="WorkerEvent.WindowMouseOut",e.WindowFocus="WorkerEvent.WindowFocus",e.WindowBlur="WorkerEvent.WindowBlur",e.ScreenResize="WorkerEvent.ScreenResize",e.CanvasWheel="WorkerEvent.CanvasWheel",e.ShowIncompatibleBrowserNotification="WorkerEvent.ShowIncompatibleBrowserNotification",e.RemoveLoadingIndicators="WorkerEvent.RemoveLoadingIndicators",e.SetDocumentTitle="WorkerEvent.SetDocumentTitle",e.SetMouseCursor="WorkerEvent.SetMouseCursor",e.Fullscreen="WorkerEvent.Fullscreen",e.Normalscreen="WorkerEvent.Normalscreen",e.TextCopyResponse="WorkerEvent.TextCopyResponse",e.EnableGlobalFileDropTarget="WorkerEvent.EnableGlobalFileDropTarget",e.CallJs="WorkerEvent.CallJs",e.ShowTextIME="WorkerEvent.ShowTextIME",e.TextInput="WorkerEvent.TextInput",e.TextCopy="WorkerEvent.TextCopy",e.KeyDown="WorkerEvent.KeyDown",e.KeyUp="WorkerEvent.KeyUp",e.Init="WorkerEvent.Init",e.RunWebGL="WorkerEvent.RunWebGL",e.ThreadSpawn="WorkerEvent.ThreadSpawn",e.WindowTouchStart="WorkerEvent.WindowTouchStart",e.WindowTouchMove="WorkerEvent.WindowTouchMove",e.WindowTouchEndCancelLeave="WorkerEvent.WindowTouchEndCancelLeave",e.Panic="WorkerEvent.Panic"}(y||(y={})),function(e){e.Init="TaskWorkerEvent.Init"}(g||(g={})),function(e){e.Run="AsyncWorkerEvent.Run",e.ThreadSpawn="AsyncWorkerEvent.ThreadSpawn"}(m||(m={})),function(e){e.Init="MainWorkerChannelEvent.Init",e.BindMainWorkerPort="MainWorkerChannelEvent.BindMainWorkerPort",e.CallRust="MainWorkerChannelEvent.CallRust",e.SendEventFromAnyThread="MainWorkerChannelEvent.SendEventFromAnyThread"}(b||(b={}));var E=r(540);class v{constructor(e,t,r,n){this.uniformFnTable={float:function(e,t,r){const n=r>>2;e.gl.uniform1f(t,e.basef32[n])},vec2:function(e,t,r){const n=r>>2,s=e.basef32;e.gl.uniform2f(t,s[n],s[n+1])},vec3:function(e,t,r){const n=r>>2,s=e.basef32;e.gl.uniform3f(t,s[n],s[n+1],s[n+2])},vec4:function(e,t,r){const n=r>>2,s=e.basef32;e.gl.uniform4f(t,s[n],s[n+1],s[n+2],s[n+3])},mat2:function(e,t,r){e.gl.uniformMatrix2fv(t,!1,new Float32Array(e.memory.buffer,r,4))},mat3:function(e,t,r){e.gl.uniformMatrix3fv(t,!1,new Float32Array(e.memory.buffer,r,9))},mat4:function(e,t,r){const n=new Float32Array(e.memory.buffer,r,16);e.gl.uniformMatrix4fv(t,!1,n)}},this.sendFnTable=[function(e){return!0},function(e){function t(){const t=e.zerdeParser.parseU32(),r=[];for(let n=0;n<t;n++)r.push({ty:e.zerdeParser.parseString(),name:e.zerdeParser.parseString()});return r}const r={shaderId:e.zerdeParser.parseU32(),fragment:e.zerdeParser.parseString(),vertex:e.zerdeParser.parseString(),geometrySlots:e.zerdeParser.parseU32(),instanceSlots:e.zerdeParser.parseU32(),passUniforms:t(),viewUniforms:t(),drawUniforms:t(),userUniforms:t(),textureSlots:t()};e.compileWebGLShader(r)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),s=new Float32Array(e.memory.buffer,n,r);e.allocArrayBuffer(t,s)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),s=new Uint32Array(e.memory.buffer,n,r);e.allocIndexBuffer(t,s)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),a=e.zerdeParser.parseU32();e.allocVao(t,r,n,s,a)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32(),a=e.zerdeParser.parseU32(),o=e.zerdeParser.parseU32(),i=e.zerdeParser.parseU32();e.drawCall(t,r,n,s,a,o,i)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32(),s=e.zerdeParser.parseU32();e.allocTexture(t,r,n,s)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),n=e.zerdeParser.parseU32();e.beginRenderTargets(t,r,n)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),n=e.zerdeParser.parseF32(),s=e.zerdeParser.parseF32(),a=e.zerdeParser.parseF32(),o=e.zerdeParser.parseF32();e.addColorTarget(t,r,n,s,a,o)},function(e){const t=e.zerdeParser.parseU32(),r=e.zerdeParser.parseU32(),n=e.zerdeParser.parseF32();e.setDepthTarget(t,r,n)},function(e){e.endRenderTargets()},function(e){e.setDefaultDepthAndBlendMode()},function(e){const t=e.zerdeParser.parseF32(),r=e.zerdeParser.parseF32(),n=e.zerdeParser.parseF32(),s=e.zerdeParser.parseF32(),a=e.zerdeParser.parseF32();e.beginMainCanvas(t,r,n,s,a)}],this.canvas=e,this.memory=t,this.sizingData=r,this.shaders=[],this.indexBuffers=[],this.arrayBuffers=[],this.vaos=[],this.textures=[],this.framebuffers=[],this.targetWidth=0,this.targetHeight=0,this.clearFlags=0,this.clearR=0,this.clearG=0,this.clearB=0,this.clearA=0,this.clearDepth=0;const s={preferLowPowerToHighPerformance:!0};this.gl=e.getContext("webgl",s)||e.getContext("webgl-experimental",s)||e.getContext("experimental-webgl",s),this.gl?(this.OESVertexArrayObject=(0,d.yR)(this.gl.getExtension("OES_vertex_array_object")),this.ANGLEInstancedArrays=(0,d.yR)(this.gl.getExtension("ANGLE_instanced_arrays")),this.gl.getExtension("OES_standard_derivatives"),this.gl.getExtension("OES_element_index_uint"),this.resize(r)):n()}processMessages(e){for(this.zerdeParser=new E.x(this.memory,e),this.basef32=new Float32Array(this.memory.buffer),this.baseu32=new Uint32Array(this.memory.buffer);;){const e=this.zerdeParser.parseU32();if(this.sendFnTable[e](this))break}}resize(e){this.sizingData=e,this.canvas.width=e.width*e.dpiFactor,this.canvas.height=e.height*e.dpiFactor}getAttribLocations(e,t,r){const n=this.gl,s=[];let a=r>>2;0!=(3&r)&&a++;for(let o=0;o<a;o++){let a=r-4*o;a>4&&(a=4),s.push({loc:n.getAttribLocation(e,t+o),offset:16*o,size:a,stride:4*r})}return s}getUniformLocations(e,t){const r=this.gl,n=[];let s=0;for(let a=0;a<t.length;a++){const o=t[a],i=w[o.ty];0!=(3&s)&&(3&s)+i>4&&(s+=4-(3&s)),n.push({name:o.name,offset:s<<2,ty:o.ty,loc:r.getUniformLocation(e,o.name),fn:this.uniformFnTable[o.ty]}),s+=i}return n}compileWebGLShader(e){const t=this.gl,r=(0,d.yR)(t.createShader(t.VERTEX_SHADER));t.shaderSource(r,e.vertex),t.compileShader(r),t.getShaderParameter(r,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(r),A(e.vertex));const n=(0,d.yR)(t.createShader(t.FRAGMENT_SHADER));t.shaderSource(n,e.fragment),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS)||console.log(t.getShaderInfoLog(n),A(e.fragment));const s=(0,d.yR)(t.createProgram());t.attachShader(s,r),t.attachShader(s,n),t.linkProgram(s),t.getProgramParameter(s,t.LINK_STATUS)||console.log(t.getProgramInfoLog(s),A(e.vertex),A(e.fragment)),this.shaders[e.shaderId]={geomAttribs:this.getAttribLocations(s,"mpsc_packed_geometry_",e.geometrySlots),instAttribs:this.getAttribLocations(s,"mpsc_packed_instance_",e.instanceSlots),passUniforms:this.getUniformLocations(s,e.passUniforms),viewUniforms:this.getUniformLocations(s,e.viewUniforms),drawUniforms:this.getUniformLocations(s,e.drawUniforms),userUniforms:this.getUniformLocations(s,e.userUniforms),textureSlots:this.getUniformLocations(s,e.textureSlots),instanceSlots:e.instanceSlots,program:s,ash:e}}allocArrayBuffer(e,t){const r=this.gl;let n=this.arrayBuffers[e];void 0===n?n=this.arrayBuffers[e]={glBuf:(0,d.yR)(r.createBuffer()),length:t.length}:n.length=t.length,r.bindBuffer(r.ARRAY_BUFFER,n.glBuf),r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,null)}allocIndexBuffer(e,t){const r=this.gl;let n=this.indexBuffers[e];void 0===n?n=this.indexBuffers[e]={glBuf:(0,d.yR)(r.createBuffer()),length:t.length}:n.length=t.length,r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,n.glBuf),r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null)}allocVao(e,t,r,n,s){const a=this.gl,o=this.vaos[e];o&&this.OESVertexArrayObject.deleteVertexArrayOES(o.glVao);const i=(0,d.yR)(this.OESVertexArrayObject.createVertexArrayOES()),l=this.vaos[e]={glVao:i,geomIbId:r,geomVbId:n,instVbId:s};this.OESVertexArrayObject.bindVertexArrayOES(l.glVao),a.bindBuffer(a.ARRAY_BUFFER,this.arrayBuffers[n].glBuf);const f=this.shaders[t];for(let e=0;e<f.geomAttribs.length;e++){const t=f.geomAttribs[e];t.loc<0||(a.vertexAttribPointer(t.loc,t.size,a.FLOAT,!1,t.stride,t.offset),a.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,0))}a.bindBuffer(a.ARRAY_BUFFER,this.arrayBuffers[s].glBuf);for(let e=0;e<f.instAttribs.length;e++){const t=f.instAttribs[e];t.loc<0||(a.vertexAttribPointer(t.loc,t.size,a.FLOAT,!1,t.stride,t.offset),a.enableVertexAttribArray(t.loc),this.ANGLEInstancedArrays.vertexAttribDivisorANGLE(t.loc,1))}a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.indexBuffers[r].glBuf),this.OESVertexArrayObject.bindVertexArrayOES(null)}drawCall(e,t,r,n,s,a,o){const i=this.gl,l=this.shaders[e];i.useProgram(l.program);const f=this.vaos[t];this.OESVertexArrayObject.bindVertexArrayOES(f.glVao);const c=this.indexBuffers[f.geomIbId],d=this.arrayBuffers[f.instVbId],u=l.passUniforms,h=l.viewUniforms;for(let e=0;e<h.length;e++){const t=h[e];t.fn(this,t.loc,t.offset+n)}const p=l.drawUniforms;for(let e=0;e<p.length;e++){const t=p[e];t.fn(this,t.loc,t.offset+s)}const y=l.userUniforms;for(let e=0;e<y.length;e++){const t=y[e];t.fn(this,t.loc,t.offset+a)}const g=l.textureSlots;for(let e=0;e<g.length;e++){const t=g[e],r=this.baseu32[(o>>2)+e],n=this.textures[r];i.activeTexture(i.TEXTURE0+e),i.bindTexture(i.TEXTURE_2D,n),i.uniform1i(t.loc,e)}const m=c.length,b=d.length/l.instanceSlots;for(let e=0;e<u.length;e++){const t=u[e];t.fn(this,t.loc,t.offset+r)}this.ANGLEInstancedArrays.drawElementsInstancedANGLE(i.TRIANGLES,m,i.UNSIGNED_INT,0,b),this.OESVertexArrayObject.bindVertexArrayOES(null)}allocTexture(e,t,r,n){const s=this.gl,a=this.textures[e]||s.createTexture();s.bindTexture(s.TEXTURE_2D,a),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.LINEAR),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.LINEAR),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE);const o=new Uint8Array(this.memory.buffer,n,t*r*4);s.texImage2D(s.TEXTURE_2D,0,s.RGBA,t,r,0,s.RGBA,s.UNSIGNED_BYTE,o),this.textures[e]=a}beginRenderTargets(e,t,r){const n=this.gl;this.targetWidth=t,this.targetHeight=r,this.clearFlags=0;const s=this.framebuffers[e]||(this.framebuffers[e]=(0,d.yR)(n.createFramebuffer()));n.bindFramebuffer(n.FRAMEBUFFER,s)}addColorTarget(e,t,r,n,s,a){this.clearR=r,this.clearG=n,this.clearB=s,this.clearA=a;const o=this.gl,i=this.textures[e]||(this.textures[e]=o.createTexture());i.mpWidth!=this.targetWidth||i.mpHeight!=this.targetHeight?(o.bindTexture(o.TEXTURE_2D,i),this.clearFlags|=o.COLOR_BUFFER_BIT,i.mpWidth=this.targetWidth,i.mpHeight=this.targetHeight,o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.LINEAR),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.LINEAR),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE),o.texImage2D(o.TEXTURE_2D,0,o.RGBA,i.mpWidth,i.mpHeight,0,o.RGBA,o.UNSIGNED_BYTE,null)):t||(this.clearFlags|=o.COLOR_BUFFER_BIT),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,i,0)}setDepthTarget(e,t,r){const n=this.gl;this.clearDepth=r;const s=this.textures[e]||(this.textures[e]=n.createRenderbuffer());s.mpWidth!=this.targetWidth||s.mpHeight!=this.targetHeight?(n.bindRenderbuffer(n.RENDERBUFFER,s),this.clearFlags|=n.DEPTH_BUFFER_BIT,s.mpWidth=this.targetWidth,s.mpHeight=this.targetHeight,n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,this.targetWidth,this.targetHeight)):t||(this.clearFlags|=n.DEPTH_BUFFER_BIT),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,s)}endRenderTargets(){const e=this.gl;e.viewport(0,0,this.targetWidth,this.targetHeight),this.clearFlags&&(e.clearColor(this.clearR,this.clearG,this.clearB,this.clearA),e.clearDepth(this.clearDepth),e.clear(this.clearFlags))}setDefaultDepthAndBlendMode(){const e=this.gl;e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.blendEquationSeparate(e.FUNC_ADD,e.FUNC_ADD),e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA),e.enable(e.BLEND)}beginMainCanvas(e,t,r,n,s){const a=this.gl;a.bindFramebuffer(a.FRAMEBUFFER,null),a.viewport(0,0,this.sizingData.width*this.sizingData.dpiFactor,this.sizingData.height*this.sizingData.dpiFactor),a.clearColor(e,t,r,n),a.clearDepth(s),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT)}}const w={float:1,vec2:2,vec3:3,vec4:4,mat2:4,mat3:9,mat4:16};function A(e){const t=e.split("\n");let r="";for(let e=0;e<t.length;e++)r+=e+1+": "+t[e]+"\n";return r}function B(){const e=document.createElement("style");e.innerHTML="\n  * {\n    user-select: none;\n  }\n  html, body {\n    overflow: hidden;\n    background-color: #333;\n  }\n  body {\n    margin: 0;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n  }\n\n  #zaplib_js_root {\n    position: absolute; /* For z-index */\n    z-index: 0; /* New stacking context */\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    pointer-events: none;\n  }",document.body.appendChild(e)}var U=r(3),R=function(e,t,r,n){return new(r||(r=Promise))((function(s,a){function o(e){try{l(n.next(e))}catch(e){a(e)}}function i(e){try{l(n.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,i)}l((n=n.apply(e,t||[])).next())}))};const S={},W=e=>{for(const t of Object.keys(e))if(t in S)throw new Error(`Error: overwriting existing function "${t}" in window.jsFunctions`);Object.assign(S,e)},T=e=>{for(const t of e){if(!(t in S))throw new Error(`Error: unregistering non-existent function "${t}".`);delete S[t]}},k=new Uint8Array(new SharedArrayBuffer(1));Atomics.store(k,0,0);const P=()=>1===Atomics.load(k,0),{checkWasm:z}=(0,d.m5)(P);let F;const C=(...e)=>R(void 0,void 0,void 0,(function*(){try{return yield F.send(...e)}catch(e){throw e instanceof Error&&"RustPanic"===e.name&&Atomics.store(k,0,0),e}})),x=(...e)=>F.receive(...e),I=()=>{const e=new MessageChannel;return C(y.BindMainWorkerPort,e.port1,[e.port1]),e.port2};let M;const D=e=>{C(y.DecrementArc,e)},O=e=>{C(y.DeallocVec,e)},L=e=>(0,d.re)(M,D,O,e),N=new Set,Z=e=>{if("object"!=typeof e||!(0,c.hC)(e.buffer))throw new Error("Only pass Zap arrays to serializeZapArrayForPostMessage");const t=e.buffer;return t.__zaplibBufferData.readonly?(N.add(t),C(y.IncrementArc,t.__zaplibBufferData.arcPtr).then((()=>{N.delete(t)}))):(0,c.ku)(t),{bufferData:t.__zaplibBufferData,byteOffset:e.byteOffset,byteLength:e.byteLength}},V=(e,t=[])=>R(void 0,void 0,void 0,(function*(){z();const r=t.map((e=>"string"==typeof e?e:(0,c.hC)(e.buffer)?((0,c.gU)(e),Z(e)):(e.buffer instanceof SharedArrayBuffer||console.warn("Consider passing Uint8Arrays backed by ZapBuffer or SharedArrayBuffer into `callRust` to prevent copying data"),e)));return L(yield C(y.CallRust,{name:e,params:r}))})),$=e=>R(void 0,void 0,void 0,(function*(){z();const t=e.byteLength,r=yield C(y.CreateBuffer,e,[e.buffer]);return L([{paramType:(0,d.D3)(e,!1),bufferPtr:r,bufferLen:t,bufferCap:t,readonly:!1}])[0]})),G=e=>R(void 0,void 0,void 0,(function*(){z();const t=e.byteLength,{bufferPtr:r,arcPtr:n}=yield C(y.CreateReadOnlyBuffer,e,[e.buffer]);return L([{paramType:(0,d.D3)(e,!0),bufferPtr:r,bufferLen:t,arcPtr:n,readonly:!0}])[0]})),K=e=>{const t=(0,c._)(M,e.bufferData,D,O);return new Uint8Array(t,e.byteOffset,e.byteLength)},H=(e,t=[])=>{throw new Error("`callRustInSameThreadSync` is currently not supported on the main thread in WASM")};let j=!1;const Y=e=>{if(j)throw new Error("Only call zaplib.initialize() once");if(j=!0,U.iO)throw new Error("zaplib.initialize() can only be called on the browser's main thread");return(0,c.$q)(),new Promise((t=>{var r;F=new d.Wl(new i);const n=null!==(r=e.baseUri)&&void 0!==r?r:window.location.protocol+"//"+window.location.host+"/";let s;if("string"==typeof e.wasmModule){const t=new URL(e.wasmModule,n).href;s=WebAssembly.compileStreaming(fetch(t))}else s=e.wasmModule;const a=[],o=()=>{e.defaultStyles&&(B(),function(){const e=document.createElement("style");e.innerHTML="\n    .zaplib_loading_indicator {\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        color: #666;\n        font-size: 40px;\n    }\n    .zaplib_loading_indicator > span {\n        display: inline-block;\n        animation-name: wiggle;\n        animation-duration: 1000ms;\n        animation-iteration-count: infinite;\n        animation-timing-function: ease-in-out;\n    }\n    @keyframes wiggle {\n        0% {transform: rotate(0deg);}\n        10% {transform: rotate(10deg);}\n        30% {transform: rotate(-10deg);}\n        50% {transform: rotate(20deg);}\n        70% {transform: rotate(-5deg);}\n        90% {transform: rotate(2deg);}\n        95% {transform: rotate(0deg);}\n    }\n\n    .zaplib_loading_indicator > div {\n        position: absolute;\n        width: max-content;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, 40px);\n        font-family: Verdana, Arial Black;\n        font-weight: bold;\n        font-size: 28px;\n\n        background: #222 -webkit-gradient(linear, left top, right top, from(#222), to(#222), color-stop(0.5, #fff)) 0 0 no-repeat;\n        background-image: -webkit-linear-gradient(-40deg, transparent 0%, transparent 40%, #fff 50%, transparent 60%, transparent 100%);\n        background-size: 200px;\n        -webkit-background-clip: text;\n        background-clip: text;\n        animation-name: shine;\n        animation-duration: 1s;\n        animation-iteration-count: infinite;\n        text-shadow: 0 0px 0px rgba(255, 255, 255, 0.5);\n    }\n    @keyframes shine {\n        0% {\n            background-position: -200px 0;\n        }\n        100% {\n            background-position: 250px 0;\n        }\n    }",document.body.appendChild(e);const t=document.createElement("div");t.className="zaplib_loading_indicator",t.innerHTML='<span></span><div style="color: rgba(255, 202, 0, 0.5);">Loading</div>',document.body.appendChild(t)}());const r=(0,d.fB)();new d.Wl(new f).send(g.Init,{taskWorkerSab:r,wasmMemory:M});try{M=new WebAssembly.Memory({initial:40,maximum:65535,shared:!0})}catch(e){console.log("Can't allocate full WebAssembly memory; trying ~400MB");try{M=new WebAssembly.Memory({initial:40,maximum:6e3,shared:!0})}catch(e){throw new Error("Can't initilialize WebAssembly memory..")}}x(y.ShowIncompatibleBrowserNotification,(()=>{const e=document.createElement("span");e.style.color="white",e.innerHTML="Sorry, we need browser support for WebGL to run<br/>Please update your browser to a more modern one<br/>Update to at least iOS 10, Safari 10, latest Chrome, Edge or Firefox<br/>Go and update and come back, your browser will be better, faster and more secure!<br/>If you are using chrome on OSX on a 2011/2012 mac please enable your GPU at: Override software rendering list:Enable (the top item) in: <a href='about://flags'>about://flags</a>. Or switch to Firefox or Safari."})),x(y.RemoveLoadingIndicators,(()=>{e.defaultStyles&&function(){const e=document.getElementsByClassName("zaplib_loading_indicator");for(let t=0;t<e.length;t++)(0,d.yR)(e[t].parentNode).removeChild(e[t])}()})),x(y.SetDocumentTitle,(e=>{document.title=e})),x(y.SetMouseCursor,(e=>{document.body.style.cursor=e})),x(y.Fullscreen,(()=>{document.body.requestFullscreen?document.body.requestFullscreen():document.body.webkitRequestFullscreen?document.body.webkitRequestFullscreen():document.body.mozRequestFullscreen&&document.body.mozRequestFullscreen()})),x(y.Normalscreen,(()=>{document.exitFullscreen?document.exitFullscreen():document.webkitExitFullscreen?document.webkitExitFullscreen():document.mozExitFullscreen&&document.mozExitFullscreen()})),x(y.TextCopyResponse,(e=>{window.navigator.clipboard.writeText(e)})),x(y.EnableGlobalFileDropTarget,(()=>{document.addEventListener("dragenter",(e=>{const t=e.dataTransfer;t&&1===t.types.length&&"Files"===t.types[0]&&(e.stopPropagation(),e.preventDefault(),t.dropEffect="copy",P()&&C(y.DragEnter))})),document.addEventListener("dragover",(e=>{e.stopPropagation(),e.preventDefault(),P()&&C(y.DragOver,{x:e.clientX,y:e.clientY})})),document.addEventListener("dragleave",(e=>{e.stopPropagation(),e.preventDefault(),P()&&C(y.DragLeave)})),document.addEventListener("drop",(e=>{if(!e.dataTransfer)return;const t=Array.from(e.dataTransfer.files);if(!t.length)return;e.preventDefault(),e.stopPropagation();const r=[];for(const e of t){const t={id:a.length,basename:e.name,file:e,lastReadStart:-1,lastReadEnd:-1};r.push(t),a.push(t)}P()&&C(y.Drop,{fileHandles:a,fileHandlesToSend:r})}))})),x(y.CallJs,(({fnName:e,params:t})=>{const r=S[e];r?r(L(t)):console.error(`call_js with ${e} is not available. Have you registered it using \`registerCallJsCallbacks\`?`)}));let o={getSizingData:()=>({width:0,height:0,dpiFactor:1,canFullscreen:!1,isFullscreen:!1}),onScreenResize:()=>{},renderingMethod:void 0},i=e.canvas;!i&&e.defaultStyles&&(i=document.createElement("canvas"),document.body.appendChild(i)),i&&(o=function(e){e.className="zaplib_canvas",document.addEventListener("contextmenu",(e=>{var t;e.target instanceof Element&&!(null===(t=document.getElementById("zaplib_js_root"))||void 0===t?void 0:t.contains(e.target))&&e.preventDefault()})),document.addEventListener("mousedown",(e=>{P()&&C(y.CanvasMouseDown,u(e))})),window.addEventListener("mouseup",(e=>{P()&&C(y.WindowMouseUp,u(e))})),window.addEventListener("mousemove",(e=>{document.body.scrollTop=0,document.body.scrollLeft=0,P()&&C(y.WindowMouseMove,u(e))})),window.addEventListener("mouseout",(e=>{P()&&C(y.WindowMouseOut,u(e))})),document.addEventListener("touchstart",(e=>{e.preventDefault(),P()&&C(y.WindowTouchStart,h(e))}),{passive:!1}),window.addEventListener("touchmove",(e=>{e.preventDefault(),P()&&C(y.WindowTouchMove,h(e))}),{passive:!1});const t=e=>{e.preventDefault(),P()&&C(y.WindowTouchEndCancelLeave,h(e))};window.addEventListener("touchend",t),window.addEventListener("touchcancel",t),document.addEventListener("wheel",(e=>{P()&&C(y.CanvasWheel,(e=>({pageX:e.pageX,pageY:e.pageY,button:e.button,timeStamp:e.timeStamp,deltaMode:e.deltaMode,deltaX:e.deltaX,deltaY:e.deltaY,wheelDeltaY:e.wheelDeltaY,shiftKey:e.shiftKey,ctrlKey:e.ctrlKey,metaKey:e.metaKey,altKey:e.altKey}))(e))})),window.addEventListener("focus",(()=>{P()&&C(y.WindowFocus)})),window.addEventListener("blur",(()=>{P()&&C(y.WindowBlur)}));const r=self.navigator.platform.match(/iPhone|iPad/i),n=self.navigator.userAgent.match(/Android/i);if(!r&&!n){const{showTextIME:e}=_((e=>{P()&&C(e.type,e)}));x(y.ShowTextIME,e)}const s=()=>{const t=!!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullscreenEnabled),r=!!(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullscreenElement);return{width:e.offsetWidth,height:e.offsetHeight,dpiFactor:window.devicePixelRatio,canFullscreen:t,isFullscreen:r}};let a;const o=()=>{const e=s();a&&a.resize(e),P()&&C(y.ScreenResize,e)};window.addEventListener("resize",(()=>o())),window.addEventListener("orientationchange",(()=>o()));let i=window.devicePixelRatio;const l="(resolution: "+window.devicePixelRatio+"dppx)",f=matchMedia(l);let c;f&&f.addEventListener?f.addEventListener("change",(()=>o())):self.setInterval((()=>{window.devicePixelRatio!=i&&(i=window.devicePixelRatio,o())}),1e3);try{c=e.transferControlToOffscreen()}catch(t){a=new v(e,M,s(),(()=>{C(y.ShowIncompatibleBrowserNotification)})),x(y.RunWebGL,(e=>(a.processMessages(e),new Promise((e=>{requestAnimationFrame((()=>{e(void 0)}))}))))),c=a}return{renderingMethod:c,onScreenResize:o,getSizingData:s}}(i)),x(y.Panic,(t=>{if(!e.onRenderingPanic)throw console.warn("Specify `onRenderingPanic` to catch errors from rendering. See https://zaplib.com/docs/bridge_api_basics.html#zaplibinitialize."),t;e.onRenderingPanic(t)})),s.then((e=>{const s=new Set,i=({ctxPtr:t,tlsAndStackData:o})=>{const f=new l,c=e=>{console.log("Async worker error event: ",e)};f.onerror=c,f.onmessageerror=c;const u=new d.Wl(f);s.add(f);const h=new MessageChannel;C(y.BindMainWorkerPort,h.port1,[h.port1]),u.receive(m.ThreadSpawn,i),u.send(m.Run,{wasmModule:e,memory:M,taskWorkerSab:r,ctxPtr:t,fileHandles:a,baseUri:n,tlsAndStackData:o,mainWorkerPort:h.port2},[h.port2]).catch((e=>{console.error("async worker failed",e)})).finally((()=>{f.terminate(),s.delete(f)}))};x(y.ThreadSpawn,i);const f=self.OffscreenCanvas&&o.renderingMethod instanceof OffscreenCanvas?o.renderingMethod:void 0;C(y.Init,{wasmModule:e,offscreenCanvas:f,sizingData:o.getSizingData(),baseUri:n,memory:M,taskWorkerSab:r,wasmOnline:k},f?[f]:[]).then((()=>{o.onScreenResize(),t()}))}))};"loading"!==document.readyState?o():document.addEventListener("DOMContentLoaded",o)}))},X=["none","default","crosshair","pointer","default","move","text","wait","help","not-allowed","n-resize","ne-resize","e-resize","se-resize","s-resize","sw-resize","w-resize","nw-resize","ns-resize","nesw-resize","ew-resize","nwse-resize","col-resize","row-resize"];var J=r(676);function q(e){return(e.shiftKey?1:0)|(e.ctrlKey?2:0)|(e.altKey?4:0)|(e.metaKey?8:0)}const Q={keyDown(e,t){e.sendU32(12),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(q(t.event)),e.sendF64(performance.now()/1e3)},keyUp(e,t){e.sendU32(13),e.sendU32(t.event.keyCode),e.sendU32(t.event.repeat?1:0),e.sendU32(q(t.event)),e.sendF64(performance.now()/1e3)},textInput(e,t){e.sendU32(14),e.sendU32(t.wasPaste?1:0),e.sendU32(t.replaceLast?1:0),e.sendString(t.input)},textCopy(e){e.sendU32(17)}};var ee=function(e,t,r,n){return new(r||(r=Promise))((function(s,a){function o(e){try{l(n.next(e))}catch(e){a(e)}}function i(e){try{l(n.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,i)}l((n=n.apply(e,t||[])).next())}))};let te=0;const re={},ne=e=>e.map((e=>{if("string"==typeof e)return e;{if((0,c.hC)(e.buffer)){(0,c.gU)(e);const t=e.buffer;return[t.__zaplibWasmBuffer,(0,d.D3)(e,t.readonly)]}const t=(0,d.D3)(e,!1),[r]=window.cefCreateArrayBuffer(e.length,t);return(0,d.dy)(e,r,0),[r,t]}})),se=(e,t=[])=>{const r=te++,n=new Promise(((e,t)=>{re[r]=t=>{e(t)}}));return window.cefCallRust(e,ne(t),r),n},ae={_zaplibReturnParams:function(e){const t=JSON.parse(e[0]);re[t](e.slice(1)),delete re[t]}},oe=e=>{for(const t of Object.keys(e))if(t in ae)throw new Error(`Error: overwriting existing function "${t}"`);Object.assign(ae,e),window.cefReadyForMessages()},ie=e=>{e.forEach((e=>{if(!(e in ae))throw new Error(`Error: unregistering non-existent function "${e}"`);delete ae[e]}))},le=e=>e.map((e=>{if("string"==typeof e)return e;{const[t,r,n]=e,s=(0,c.rx)(t,r,n);if(n===J.r.String)throw new Error("ZapParam buffer type called with string paramType");const a={[J.r.U8Buffer]:Uint8Array,[J.r.ReadOnlyU8Buffer]:Uint8Array,[J.r.F32Buffer]:Float32Array,[J.r.ReadOnlyF32Buffer]:Float32Array};return(0,c.CO)(s,new a[n](s))}})),fe=(e,t=[])=>le(window.cefCallRustInSameThreadSync(e,ne(t))),ce=()=>{throw new Error("`newWorkerPort` is currently not supported on CEF")},de=e=>{throw new Error("`serializeZapArrayForPostMessage` is currently not supported on CEF")},ue=e=>{throw new Error("`deserializeZapArrayFromPostMessage` is currently not supported on CEF")},he=e=>new Promise((t=>{(0,c.$q)(),window.fromCefSetMouseCursor=e=>{document.body&&(document.body.style.cursor=X[e]||"default")},window.fromCefCallJsFunction=(e,t)=>{ae[e](le(t))},document.addEventListener("DOMContentLoaded",(()=>{e.defaultStyles&&B();const{showTextIME:r,textareaHasFocus:n}=_((e=>{const[t]=window.cefCreateArrayBuffer(80,J.r.U8Buffer),r=new E.k({buffer:t,byteOffset:0,slots:20,growCallback:()=>{throw new Error("Growing of this buffer is not supported")}});e.type===y.KeyDown?Q.keyDown(r,e):e.type===y.KeyUp?Q.keyUp(r,e):e.type===y.TextInput?Q.textInput(r,e):e.type===y.TextCopy&&Q.textCopy(r),window.cefHandleKeyboardEvent(t)}));window.fromCefSetIMEPosition=(e,t)=>{r({x:e,y:t})},document.addEventListener("keydown",(e=>{const t=e.keyCode;(e.metaKey||e.ctrlKey)&&(n()||(67==t?window.cefTriggerCopy():88==t?window.cefTriggerCut():65==t&&window.cefTriggerSelectAll()),86==t&&window.cefTriggerPaste())})),t()}))})),pe=e=>ee(void 0,void 0,void 0,(function*(){const t=(0,d.D3)(e,!1),[r]=window.cefCreateArrayBuffer(e.length,t);return(0,d.dy)(e,r,0),le([[r,void 0,t]])[0]})),ye=e=>ee(void 0,void 0,void 0,(function*(){const t=(0,d.D3)(e,!0),[r,n]=window.cefCreateArrayBuffer(e.length,t);return(0,d.dy)(e,r,0),le([[r,n,t]])[0]}));var ge=r(379),me=r.n(ge),be=r(795),_e=r.n(be),Ee=r(569),ve=r.n(Ee),we=r(565),Ae=r.n(we),Be=r(216),Ue=r.n(Be),Re=r(589),Se=r.n(Re),We=r(605),Te={};Te.styleTagTransform=Se(),Te.setAttributes=Ae(),Te.insert=ve().bind(null,"head"),Te.domAPI=_e(),Te.insertStyleElement=Ue(),me()(We.Z,Te),We.Z&&We.Z.locals&&We.Z.locals;const{initialize:ke,newWorkerPort:Pe,registerCallJsCallbacks:ze,unregisterCallJsCallbacks:Fe,callRust:Ce,serializeZapArrayForPostMessage:xe,deserializeZapArrayFromPostMessage:Ie,callRustInSameThreadSync:Me,createMutableBuffer:De,createReadOnlyBuffer:Oe}="cef"===U.Zm?s:n},540:(e,t,r)=>{r.d(t,{k:()=>s,x:()=>a});var n=r(676);class s{constructor({buffer:e,byteOffset:t,slots:r,growCallback:n}){this._buffer=e,this._byteOffset=t,this._slots=r,this._growCallback=n,this._used=2,this._updateRefs()}_updateRefs(){this._f32=new Float32Array(this._buffer,this._byteOffset,this._slots),this._u32=new Uint32Array(this._buffer,this._byteOffset,this._slots),this._f64=new Float64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64=new BigUint64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64[0]=BigInt(this._slots)*BigInt(4)}_fit(e){if(this._used+e>this._slots){let t=Math.max(this._used+e,2*this._slots);1&t&&t++;const r=4*t,{buffer:n,byteOffset:s}=this._growCallback(this._buffer,this._byteOffset,r);this._buffer=n,this._byteOffset=s,this._slots=t,this._updateRefs()}const t=this._used;return this._used+=e,t}sendF32(e){const t=this._fit(1);this._f32[t]=e}sendU32(e){const t=this._fit(1);this._u32[t]=e}sendF64(e){if(1&this._used){const t=this._fit(3)+1;this._f64[t>>1]=e}else{const t=this._fit(2);this._f64[t>>1]=e}}sendU64(e){if(1&this._used){const t=this._fit(3)+1;this._u64[t>>1]=e}else{const t=this._fit(2);this._u64[t>>1]=e}}sendString(e){let t=this._fit(e.length+1);this._u32[t++]=e.length;for(let r=0;r<e.length;r++)this._u32[t++]=e.charCodeAt(r)}getData(){return{buffer:this._buffer,byteOffset:this._byteOffset}}}class a{constructor(e,t){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,t),this._u32=new Uint32Array(this._memory.buffer,t),this._f64=new Float64Array(this._memory.buffer,t),this._u64=new BigUint64Array(this._memory.buffer,t)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e="";const t=this.parseU32();for(let r=0;r<t;r++){const t=this.parseU32();0!=t&&(e+=String.fromCharCode(t))}return e}parseU8Slice(){const e=this.parseU32(),t=e>>2,r=new Uint8Array(e),n=3&e;for(let e=0;e<t;e++){const t=e<<2,n=this.parseU32();r[t+0]=255&n,r[t+1]=n>>8&255,r[t+2]=n>>16&255,r[t+3]=n>>24&255}const s=t<<2;if(1==n){const e=this.parseU32();r[s+0]=255&e}else if(2==n){const e=this.parseU32();r[s+0]=255&e,r[s+1]=e>>8&255}else if(3==n){const e=this.parseU32();r[s+0]=255&e,r[s+1]=e>>8&255,r[s+2]=e>>16&255}return r}parseZapParams(){const e=this.parseU32(),t=[];for(let r=0;r<e;++r){const e=this.parseU32();if(e===n.r.String)t.push(this.parseString());else if(e===n.r.ReadOnlyU8Buffer||e===n.r.ReadOnlyF32Buffer){const r=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:e,bufferPtr:r,bufferLen:n,arcPtr:s,readonly:!0})}else{if(e!==n.r.U8Buffer&&e!==n.r.F32Buffer)throw new Error(`Unknown ZapParam type: ${e}`);{const r=this.parseU32(),n=this.parseU32(),s=this.parseU32();t.push({paramType:e,bufferPtr:r,bufferLen:n,bufferCap:s,readonly:!1})}}}return t}}},477:e=>{e.exports=function(e,t,r,n){var s=self||window;try{try{var a;try{a=new s.Blob([e])}catch(t){(a=new(s.BlobBuilder||s.WebKitBlobBuilder||s.MozBlobBuilder||s.MSBlobBuilder)).append(e),a=a.getBlob()}var o=s.URL||s.webkitURL,i=o.createObjectURL(a),l=new s[t](i,r);return o.revokeObjectURL(i),l}catch(n){return new s[t]("data:application/javascript,".concat(encodeURIComponent(e)),r)}}catch(e){if(!n)throw Error("Inline worker is not supported");return new s[t](n,r)}}}},t={};function r(n){var s=t[n];if(void 0!==s)return s.exports;var a=t[n]={id:n,exports:{}};return e[n](a,a.exports,r),a.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{r.r(n);var e=r(477),t=r.n(e),s=r(90),a=r(676),o=r(760),i=r(214);const{ZapUint8Array:l,ZapUint16Array:f}=window,c={testBuffer:function(){const e=new SharedArrayBuffer(1024),t=new o.fV(e,{bufferPtr:10,bufferLen:4,bufferCap:4,paramType:a.r.U8Buffer,readonly:!1}),r=new l(t,10,4);(0,i.l_)(r.byteOffset,10),(0,i.l_)(r.length,4)},testShare:function(){const e=new SharedArrayBuffer(1024),t=new o.fV(e,{bufferPtr:0,bufferLen:1024,bufferCap:1024,paramType:a.r.U8Buffer,readonly:!1}),r=new l(t),n=new f(r.buffer);(0,i.l_)(r.buffer,t),(0,i.l_)(r.buffer,n.buffer)},testOutOfBounds:function(){const e=new SharedArrayBuffer(1024),t=new o.fV(e,{bufferPtr:1,bufferLen:16,bufferCap:16,paramType:a.r.U8Buffer,readonly:!1});(0,i.zp)((()=>{new l(t,0)}),"Byte_offset 0 is out of bounds");const r=new l(t,1);(0,i.l_)(r.length,16);const n=new l(t,2);(0,i.l_)(n.length,15),(0,i.zp)((()=>{new l(t,15,3)}),"Byte_offset 15 + length 3 is out of bounds")},testZapNameMatches:function(){for(const[e,t]of Object.entries(o.CT)){const r="Zap"+e;(0,i.l_)(r,t)}},testArrayBuffer:function(){const e=new ArrayBuffer(16),t=new o.fV(e,{bufferPtr:0,bufferLen:e.byteLength,bufferCap:e.byteLength,paramType:a.r.U8Buffer,readonly:!1}),r=new l(t);(0,i.l_)(r.byteOffset,0),(0,i.l_)(r.byteLength,16)},testSubarray:function(){const e=new SharedArrayBuffer(5),t=new Uint8Array(e);t.set(Uint8Array.from([0,1,2,3,4]));const r=new o.fV(e,{bufferPtr:0,bufferLen:5,bufferCap:5,paramType:a.r.U8Buffer,readonly:!1}),n=new l(r);(0,i.l_)(n.subarray().buffer,r),(0,i.l_)(n.subarray().toString(),t.subarray().toString()),(0,i.l_)(n.subarray(1,3).toString(),t.subarray(1,3).toString()),(0,i.l_)(n.subarray(-2,0).toString(),t.subarray(-2,0).toString()),(0,i.l_)(n.subarray(-3,-1).toString(),t.subarray(-3,-1).toString()),(0,i.l_)(n.subarray(1,-1).toString(),t.subarray(1,-1).toString())},testContainsZapBuffer:function(){const e=new SharedArrayBuffer(16),t=new o.fV(e,{bufferPtr:0,bufferLen:16,bufferCap:16,paramType:a.r.U8Buffer,readonly:!1}),r=new l(t);(0,i.l_)((0,o.Ko)(r),!0),(0,i.l_)((0,o.Ko)([r]),!0),(0,i.l_)((0,o.Ko)({key:r}),!0),(0,i.l_)((0,o.Ko)(new Set([r])),!0);const n=new Map;n.set("key",r),(0,i.l_)((0,o.Ko)(n),!0),(0,i.l_)((0,o.Ko)(r.slice()),!1),(0,i.l_)((0,o.Ko)(void 0),!1),(0,i.l_)((0,o.Ko)(null),!1)}};var d=r(167),u=r(3),h=function(e,t,r,n){return new(r||(r=Promise))((function(s,a){function o(e){try{l(n.next(e))}catch(e){a(e)}}function i(e){try{l(n.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,i)}l((n=n.apply(e,t||[])).next())}))};const p=e=>(0,i.Ed)(d.callRust,e),y=new s.Wl(new function(){return t()('(()=>{"use strict";var e;!function(e){e[e.String=0]="String",e[e.ReadOnlyU8Buffer=1]="ReadOnlyU8Buffer",e[e.U8Buffer=2]="U8Buffer",e[e.F32Buffer=3]="F32Buffer",e[e.ReadOnlyF32Buffer=4]="ReadOnlyF32Buffer"}(e||(e={})),self;const r="function"==typeof importScripts;const t=(e,r)=>{if(r!==e)throw new Error(`Failure: Got ${e}, Expected ${r}`);console.debug(`Success: Got ${e}, Expected ${r}`)},n=(e,r)=>{let n;try{e()}catch(e){n=e}t(!!n,!0),n&&r&&t(n.message,r)};class a extends SharedArrayBuffer{constructor(e,r){super(0),this.__zaplibWasmBuffer=e,this.__zaplibBufferData=r}get readonly(){return this.__zaplibBufferData.readonly}get byteLength(){return this.__zaplibWasmBuffer.byteLength}slice(...e){return this.__zaplibWasmBuffer.slice(...e)}}function s(e){return class r extends e{constructor(...r){const t=r[0];if("object"==typeof t&&t instanceof a){if(r.length<2&&(r[1]=t.__zaplibBufferData.bufferPtr),r.length<3&&(r[2]=Math.floor((t.__zaplibBufferData.bufferPtr+t.__zaplibBufferData.bufferLen-r[1])/e.BYTES_PER_ELEMENT)),r[1]<t.__zaplibBufferData.bufferPtr)throw new Error(`Byte_offset ${r[1]} is out of bounds`);if(r[1]+r[2]*e.BYTES_PER_ELEMENT>t.__zaplibBufferData.bufferPtr+t.__zaplibBufferData.bufferLen)throw new Error(`Byte_offset ${r[1]} + length ${r[2]} is out of bounds`);r[0]=t.__zaplibWasmBuffer,super(...r),this.__zaplibBuffer=t}else super(...r)}get buffer(){return this.__zaplibBuffer||super.buffer}subarray(e=0,t=this.length){return e<0&&(e=this.length+e),t<0&&(t=this.length+t),t<e&&(t=e),new r(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,t-e)}}}const o={Int8Array:"ZapInt8Array",Uint8Array:"ZapUint8Array",Uint8ClampedArray:"ZapUint8ClampedArray",Int16Array:"ZapInt16Array",Uint16Array:"ZapUint16Array",Uint16ClampedArray:"ZapUint16ClampedArray",Int32Array:"ZapInt32Array",Uint32Array:"ZapUint32Array",Float32Array:"ZapFloat32Array",Float64Array:"ZapFloat64Array",BigInt64Array:"ZapBigInt64Array",BigUint64Array:"ZapBigUint64Array",DataView:"ZapDataView"};for(const[e,r]of Object.entries(o))e in self&&(self[r]=s(self[e]));function i(e){if("object"!=typeof e||null===e)return!1;if(Object.prototype.hasOwnProperty.call(e,"__zaplibBuffer"))return!0;if(Array.isArray(e)||e instanceof Set||e instanceof Map){for(const r of e)if(i(r))return!0}else if(Object.getPrototypeOf(e)===Object.getPrototypeOf({}))for(const r of Object.entries(e))if(i(r))return!0;return!1}function f(e){const r=e.postMessage;e.postMessage=function(...e){if(i(e[0]))throw new Error("Sending ZapBuffers to/from workers is not supported - use .slice() on typed array instead to make an explicit copy");r.apply(this,e)}}const u=new WeakMap;function l(e){return"object"==typeof e&&e instanceof a}function c(r){if(!l(r.buffer))throw new Error("zapArray.buffer is not a ZapBuffer in checkValidZapArray");const t=r.buffer;if(r.byteOffset!==t.__zaplibBufferData.bufferPtr||r.byteLength!==t.__zaplibBufferData.bufferLen)throw new Error("Called Rust with a buffer that does not span the entire underlying ZapBuffer");const n=A(r,t.readonly);if(n!==t.__zaplibBufferData.paramType)throw new Error(`Cannot call Rust with a buffer which has been cast to a different type. Expected ${e[t.__zaplibBufferData.paramType]} but got ${e[n]}`)}const h={},y=new FinalizationRegistry((({arcPtr:e,destructor:r})=>{delete h[e],r&&r(e)})),d=new FinalizationRegistry((({bufferData:e,destructor:r})=>{r(e)})),p=(e,r,t,n)=>{var s;if(r.readonly){if(null===(s=h[r.arcPtr])||void 0===s?void 0:s.deref())t(r.arcPtr);else{const n=new a(e.buffer,r);y.register(n,{arcPtr:r.arcPtr,destructor:t}),h[r.arcPtr]=new WeakRef(n)}return h[r.arcPtr].deref()}{const t=new a(e.buffer,r);return d.register(t,{bufferData:r,destructor:n},t),t}},b=e=>{if(e.readonly)throw new Error("`unregisterMutableBuffer` should only be called on mutable ZapBuffers");d.unregister(e)};class _{constructor({buffer:e,byteOffset:r,slots:t,growCallback:n}){this._buffer=e,this._byteOffset=r,this._slots=t,this._growCallback=n,this._used=2,this._updateRefs()}_updateRefs(){this._f32=new Float32Array(this._buffer,this._byteOffset,this._slots),this._u32=new Uint32Array(this._buffer,this._byteOffset,this._slots),this._f64=new Float64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64=new BigUint64Array(this._buffer,this._byteOffset,this._slots>>1),this._u64[0]=BigInt(this._slots)*BigInt(4)}_fit(e){if(this._used+e>this._slots){let r=Math.max(this._used+e,2*this._slots);1&r&&r++;const t=4*r,{buffer:n,byteOffset:a}=this._growCallback(this._buffer,this._byteOffset,t);this._buffer=n,this._byteOffset=a,this._slots=r,this._updateRefs()}const r=this._used;return this._used+=e,r}sendF32(e){const r=this._fit(1);this._f32[r]=e}sendU32(e){const r=this._fit(1);this._u32[r]=e}sendF64(e){if(1&this._used){const r=this._fit(3)+1;this._f64[r>>1]=e}else{const r=this._fit(2);this._f64[r>>1]=e}}sendU64(e){if(1&this._used){const r=this._fit(3)+1;this._u64[r>>1]=e}else{const r=this._fit(2);this._u64[r>>1]=e}}sendString(e){let r=this._fit(e.length+1);this._u32[r++]=e.length;for(let t=0;t<e.length;t++)this._u32[r++]=e.charCodeAt(t)}getData(){return{buffer:this._buffer,byteOffset:this._byteOffset}}}class g{constructor(e,r){this._memory=e,this._usedSlots=2,this._f32=new Float32Array(this._memory.buffer,r),this._u32=new Uint32Array(this._memory.buffer,r),this._f64=new Float64Array(this._memory.buffer,r),this._u64=new BigUint64Array(this._memory.buffer,r)}parseU32(){return this._u32[this._usedSlots++]}parseF32(){return this._f32[this._usedSlots++]}parseF64(){1&this._usedSlots&&this._usedSlots++;const e=this._f64[this._usedSlots>>1];return this._usedSlots+=2,e}parseU64(){1&this._usedSlots&&this._usedSlots++;const e=this._u64[this._usedSlots>>1];return this._usedSlots+=2,e}parseString(){let e="";const r=this.parseU32();for(let t=0;t<r;t++){const r=this.parseU32();0!=r&&(e+=String.fromCharCode(r))}return e}parseU8Slice(){const e=this.parseU32(),r=e>>2,t=new Uint8Array(e),n=3&e;for(let e=0;e<r;e++){const r=e<<2,n=this.parseU32();t[r+0]=255&n,t[r+1]=n>>8&255,t[r+2]=n>>16&255,t[r+3]=n>>24&255}const a=r<<2;if(1==n){const e=this.parseU32();t[a+0]=255&e}else if(2==n){const e=this.parseU32();t[a+0]=255&e,t[a+1]=e>>8&255}else if(3==n){const e=this.parseU32();t[a+0]=255&e,t[a+1]=e>>8&255,t[a+2]=e>>16&255}return t}parseZapParams(){const r=this.parseU32(),t=[];for(let n=0;n<r;++n){const r=this.parseU32();if(r===e.String)t.push(this.parseString());else if(r===e.ReadOnlyU8Buffer||r===e.ReadOnlyF32Buffer){const e=this.parseU32(),n=this.parseU32(),a=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,arcPtr:a,readonly:!0})}else{if(r!==e.U8Buffer&&r!==e.F32Buffer)throw new Error(`Unknown ZapParam type: ${r}`);{const e=this.parseU32(),n=this.parseU32(),a=this.parseU32();t.push({paramType:r,bufferPtr:e,bufferLen:n,bufferCap:a,readonly:!1})}}}return t}}const w="$$RESPONSE",m="$$ERROR";class E{constructor(e){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=e=>{const{id:r,topic:t,data:n}=e.data;if(t===w)return this._pendingCallbacks[r](e.data),void delete this._pendingCallbacks[r];new Promise((e=>{const r=this._receivers.get(t);if(!r)throw new Error(`no receiver registered for ${t}`);e(r(n))})).then((e=>{if(!e)return void this.postMessage({topic:w,id:r},[]);const t=e[E.transferrables];delete e[E.transferrables];const n={topic:w,id:r,data:e};this.postMessage(n,t)})).catch((e=>{const t={topic:w,id:r,data:{[m]:!0,name:e.name,message:e.message,stack:e.stack}};this.postMessage(t,[])}))},this._channel=e,this._channel.onmessage)throw new Error("channel.onmessage is already set. Can only use one Rpc instance per channel.");this._channel.onmessage=this._onChannelMessage}send(e,r,t){const n=this._messageId++,a={topic:e,id:n,data:r},s=new Promise(((e,r)=>{this._pendingCallbacks[n]=t=>{if(t.data&&t.data[m]){const e=new Error(t.data.message);e.name=t.data.name,e.stack=t.data.stack,r(e)}else e(t.data)}}));return this.postMessage(a,t),s}receive(e,r){if(this._receivers.has(e))throw new Error(`Receiver already registered for topic: ${e}`);this._receivers.set(e,r)}postMessage(e,r){try{this._channel.postMessage(e,r)}catch(e){console.error("Rpc postMessage call itself failed: ",e)}}}E.transferrables="$$TRANSFERRABLES";const v=(e,r,t)=>{new e.constructor(r,t,e.length).set(e)},A=(r,t)=>{if(r instanceof Uint8Array)return t?e.ReadOnlyU8Buffer:e.U8Buffer;if(r instanceof Float32Array)return t?e.ReadOnlyF32Buffer:e.F32Buffer;throw new Error("Invalid array type")},B=(e,r,t)=>{const n=Number(r.allocWasmVec(BigInt(t.byteLength)));return v(t,e.buffer,n),n};class W extends Error{constructor(e){super(e),this.name="RustPanic"}}var k,S,U,R,C;!function(e){e.CallRust="WorkerEvent.CallRust",e.CreateBuffer="WorkerEvent.CreateBuffer",e.CreateReadOnlyBuffer="WorkerEvent.CreateReadOnlyBuffer",e.BindMainWorkerPort="WorkerEvent.BindMainWorkerPort",e.DecrementArc="WorkerEvent.DecrementArc",e.DeallocVec="WorkerEvent.DeallocVec",e.IncrementArc="WorkerEvent.IncrementArc",e.DragEnter="WorkerEvent.DragEnter",e.DragOver="WorkerEvent.DragOver",e.DragLeave="WorkerEvent.DragLeave",e.Drop="WorkerEvent.Drop",e.WindowMouseUp="WorkerEvent.WindowMouseUp",e.CanvasMouseDown="WorkerEvent.CanvasMouseDown",e.WindowMouseMove="WorkerEvent.WindowMouseMove",e.WindowMouseOut="WorkerEvent.WindowMouseOut",e.WindowFocus="WorkerEvent.WindowFocus",e.WindowBlur="WorkerEvent.WindowBlur",e.ScreenResize="WorkerEvent.ScreenResize",e.CanvasWheel="WorkerEvent.CanvasWheel",e.ShowIncompatibleBrowserNotification="WorkerEvent.ShowIncompatibleBrowserNotification",e.RemoveLoadingIndicators="WorkerEvent.RemoveLoadingIndicators",e.SetDocumentTitle="WorkerEvent.SetDocumentTitle",e.SetMouseCursor="WorkerEvent.SetMouseCursor",e.Fullscreen="WorkerEvent.Fullscreen",e.Normalscreen="WorkerEvent.Normalscreen",e.TextCopyResponse="WorkerEvent.TextCopyResponse",e.EnableGlobalFileDropTarget="WorkerEvent.EnableGlobalFileDropTarget",e.CallJs="WorkerEvent.CallJs",e.ShowTextIME="WorkerEvent.ShowTextIME",e.TextInput="WorkerEvent.TextInput",e.TextCopy="WorkerEvent.TextCopy",e.KeyDown="WorkerEvent.KeyDown",e.KeyUp="WorkerEvent.KeyUp",e.Init="WorkerEvent.Init",e.RunWebGL="WorkerEvent.RunWebGL",e.ThreadSpawn="WorkerEvent.ThreadSpawn",e.WindowTouchStart="WorkerEvent.WindowTouchStart",e.WindowTouchMove="WorkerEvent.WindowTouchMove",e.WindowTouchEndCancelLeave="WorkerEvent.WindowTouchEndCancelLeave",e.Panic="WorkerEvent.Panic"}(k||(k={})),function(e){e.Init="TaskWorkerEvent.Init"}(S||(S={})),function(e){e.Run="AsyncWorkerEvent.Run",e.ThreadSpawn="AsyncWorkerEvent.ThreadSpawn"}(U||(U={})),(C=R||(R={})).Init="MainWorkerChannelEvent.Init",C.BindMainWorkerPort="MainWorkerChannelEvent.BindMainWorkerPort",C.CallRust="MainWorkerChannelEvent.CallRust",C.SendEventFromAnyThread="MainWorkerChannelEvent.SendEventFromAnyThread";let T,O,F,I,M,P=!1;const{checkWasm:D,wrapWasmExports:L}=(e=>{const r=()=>{if(1!==Atomics.load(M,0))throw new Error("Zaplib WebAssembly instance crashed")};return{checkWasm:r,wrapWasmExports:e=>new Proxy(e,{get:function(e,t){return r(),e[t]}})}})(),z=e=>{if(P)throw new Error("Only call zaplib.initializeWorker once");if(P=!0,!r)throw new Error("zaplib.initializeWorker() can only be called in a WebWorker");return function(){for(const[e,r]of Object.entries(o))e in self&&(self[e]=self[r]);f(self),f(self.Worker),self.MessagePort&&f(self.MessagePort)}(),new Promise((r=>{T=new E(e),T.send(R.Init).then((({wasmModule:e,memory:t,taskWorkerSab:n,baseUri:a,appPtr:s,tlsAndStackData:o,wasmOnline:i})=>{M=i,F=t,I=s;const f=(({getExports:e,memory:r,taskWorkerSab:t,fileHandles:n,sendEventFromAnyThread:a,threadSpawn:s,baseUri:o})=>{const i=(e,t)=>{let n="";const a=new Uint32Array(r.buffer,e,t);for(let e=0;e<t;e++)n+=String.fromCharCode(a[e]);return n};return{memory:r,_consoleLog:(e,r)=>{const t=i(parseInt(e),parseInt(r));console.log(t)},_throwError:(e,r)=>{throw new W(i(parseInt(e),parseInt(r)))},readUserFileRange:(e,t,a,s)=>{const o=n[e],i=Number(s),f=i+Number(a);o.lastReadStart<=i&&i<o.lastReadEnd&&console.warn(`Read start (${i}) fell in the range of the last read (${o.lastReadStart}-${o.lastReadEnd}); this usually happens if you don\'t use BufReader or if you don\'t use BufReader.seek_relative.`),o.lastReadStart=i,o.lastReadEnd=f;const u=(new FileReaderSync).readAsArrayBuffer(o.file.slice(i,f));return v(new Uint8Array(u),r.buffer,Number(t)),BigInt(u.byteLength)},performanceNow:()=>performance.now(),threadSpawn:e=>{s(e)},_sendEventFromAnyThread:e=>{a(e)},readUrlSync:(t,n,a,s)=>{const f=i(t,n),u=new XMLHttpRequest;if(u.responseType="arraybuffer",u.open("GET",new URL(f,o).href,!1),u.send(null),200===u.status){const t=e(),n=B(r,t,new Uint8Array(u.response));return new Uint32Array(r.buffer,a,1)[0]=n,new Uint32Array(r.buffer,s,1)[0]=u.response.byteLength,1}return 0},randomU64:()=>new BigUint64Array(self.crypto.getRandomValues(new Uint32Array(2)).buffer)[0],sendTaskWorkerMessage:e=>{((e,r)=>{const t=new Int32Array(e);((e,r)=>{for(;;){if(0==Atomics.compareExchange(e,0,0,1))return;Atomics.wait(e,0,1)}})(t);const n=t[1];new Uint32Array(e)[n+2]=r,t[1]=n+1,((e,r)=>{if(1!=Atomics.compareExchange(e,0,1,0))throw new Error("Called mutex_unlock on an already unlocked mutex");Atomics.notify(e,0,1)})(t),Atomics.notify(t,1)})(t,parseInt(e))}}})({getExports:function(){return O},memory:t,taskWorkerSab:n,fileHandles:[],sendEventFromAnyThread:e=>{T.send(R.SendEventFromAnyThread,e)},threadSpawn:()=>{throw new Error("Not yet implemented")},baseUri:a});WebAssembly.instantiate(e,{env:f}).then((e=>{((e,r)=>{e.__stack_pointer.value=Number(r.ptr)+r.size-8,e.__wasm_init_tls(Number(r.ptr))})(e.exports,o),O=L(e.exports),r()}))}))}))},N=e=>{O.decrementArc(BigInt(e))},x=({bufferPtr:e,bufferLen:r,bufferCap:t})=>{O.deallocVec(BigInt(e),BigInt(r),BigInt(t))},Z=r=>function(r,t,n,a){return a.map((a=>{if("string"==typeof a)return a;{const s=p(r,a,t,n);if(a.paramType===e.String)throw new Error("ZapParam buffer type called with string paramType");const o={[e.U8Buffer]:Uint8Array,[e.ReadOnlyU8Buffer]:Uint8Array,[e.F32Buffer]:Float32Array,[e.ReadOnlyF32Buffer]:Float32Array}[a.paramType];return function(e,r){var t;return(null===(t=u.get(e))||void 0===t?void 0:t.BYTES_PER_ELEMENT)!==r.BYTES_PER_ELEMENT&&u.set(e,r),u.get(e)}(s,new o(s,a.bufferPtr,a.bufferLen/o.BYTES_PER_ELEMENT))}}))}(F,N,x,r),$=(e,r=[])=>{return t=void 0,n=void 0,s=function*(){D();const t=r.map((e=>"string"==typeof e?e:l(e.buffer)?(c(e),G(e)):(e.buffer instanceof SharedArrayBuffer||console.warn("Consider passing Uint8Arrays backed by ZapBuffer or SharedArrayBuffer into `callRust` to prevent copying data"),e)));return Z(yield T.send(R.CallRust,{name:e,params:t}))},new((a=void 0)||(a=Promise))((function(e,r){function o(e){try{f(s.next(e))}catch(e){r(e)}}function i(e){try{f(s.throw(e))}catch(e){r(e)}}function f(r){var t;r.done?e(r.value):(t=r.value,t instanceof a?t:new a((function(e){e(t)}))).then(o,i)}f((s=s.apply(t,n||[])).next())}));var t,n,a,s},J=(r,t=[])=>{D();const n=((e,r)=>{const t=Number(r.allocWasmMessage(BigInt(4096)));return new _({buffer:e.buffer,byteOffset:t,slots:1024,growCallback:(t,n,a)=>{const s=Number(r.reallocWasmMessage(BigInt(n),BigInt(a)));return{buffer:e.buffer,byteOffset:s}}})})(F,O);n.sendString(r),n.sendU32(t.length);for(const r of t)if("string"==typeof r)n.sendU32(e.String),n.sendString(r);else if(r.buffer instanceof a)if(c(r),r.buffer.__zaplibBufferData.readonly){n.sendU32(A(r,!0));const e=r.buffer.__zaplibBufferData.arcPtr;O.incrementArc(BigInt(e)),n.sendU32(e)}else b(r.buffer),n.sendU32(A(r,!1)),n.sendU32(r.buffer.__zaplibBufferData.bufferPtr),n.sendU32(r.buffer.__zaplibBufferData.bufferLen),n.sendU32(r.buffer.__zaplibBufferData.bufferCap);else{console.warn("Consider passing Uint8Arrays backed by ZapBuffer to prevent copying data");const e=r.byteLength,t=B(F,O,r);n.sendU32(A(r,!1)),n.sendU32(t),n.sendU32(e),n.sendU32(e)}const s=O.callRustInSameThreadSync(I,BigInt(n.getData().byteOffset)),o=new g(F,Number(s)).parseZapParams();return Z(o)},j=e=>{D();const r=e.byteLength,t=B(F,O,e);return Z([{paramType:A(e,!1),bufferPtr:t,bufferLen:r,bufferCap:r,readonly:!1}])[0]},V=e=>{D();const r=B(F,O,e),t=A(e,!0),n=Number(O.createArcVec(BigInt(r),BigInt(e.length),BigInt(t)));return Z([{paramType:t,bufferPtr:r,bufferLen:e.byteLength,arcPtr:n,readonly:!0}])[0]},G=e=>{if("object"!=typeof e||!l(e.buffer))throw new Error("Only pass Zap arrays to serializeZapArrayForPostMessage");const r=e.buffer;return r.__zaplibBufferData.readonly?O.incrementArc(BigInt(r.__zaplibBufferData.arcPtr)):b(r),{bufferData:r.__zaplibBufferData,byteOffset:e.byteOffset,byteLength:e.byteLength}};var Y=function(e,r,t,n){return new(t||(t=Promise))((function(a,s){function o(e){try{f(n.next(e))}catch(e){s(e)}}function i(e){try{f(n.throw(e))}catch(e){s(e)}}function f(e){var r;e.done?a(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(o,i)}f((n=n.apply(e,r||[])).next())}))};const K=new E(self),H={testCallRustFromWorker:function(){return Y(this,void 0,void 0,(function*(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const r=new Uint8Array(e,2,4),[n]=yield $("array_multiply_u8",[JSON.stringify(10),r]);t(n.length,4),t(n[0],30),t(n[1],40),t(n[2],50),t(n[3],60)}))},testCallRustNoReturnFromWorker:function(){return Y(this,void 0,void 0,(function*(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const r=new Uint8Array(e,2,4),n=yield $("call_rust_no_return",[JSON.stringify(10),r]);t(n.length,0)}))},testCallRustInSameThreadSyncWithSignal:function(){const e=J("send_signal");t(e.length,0)},testCallRustFloat32ArrayFromWorker:()=>Y(void 0,void 0,void 0,(function*(){const e=new Float32Array([.1,.9,.3]),r=(yield $("array_multiply_f32",[JSON.stringify(10),e]))[0];t(r.length,3),t(r[0],1),t(r[1],9),t(r[2],3);const n=j(new Float32Array([.1,.9,.3])),a=(yield $("array_multiply_f32",[JSON.stringify(10),n]))[0];t(a.length,3),t(a[0],1),t(a[1],9),t(a[2],3);const s=V(new Float32Array([.1,.9,.3])),o=(yield $("array_multiply_f32_readonly",[JSON.stringify(10),s]))[0];t(o.length,3),t(o[0],1),t(o[1],9),t(o[2],3)})),testCallRustInSameThreadSyncFloat32ArrayFromWorker:()=>Y(void 0,void 0,void 0,(function*(){const e=new Float32Array([.1,.9,.3]),r=J("array_multiply_f32",[JSON.stringify(10),e])[0];t(r.length,3),t(r[0],1),t(r[1],9),t(r[2],3);const n=j(new Float32Array([.1,.9,.3])),a=J("array_multiply_f32",[JSON.stringify(10),n])[0];t(a.length,3),t(a[0],1),t(a[1],9),t(a[2],3);const s=V(new Float32Array([.1,.9,.3])),o=J("array_multiply_f32_readonly",[JSON.stringify(10),s])[0];t(o.length,3),t(o[0],1),t(o[1],9),t(o[2],3)})),testInWorker:()=>{t(r,!0)},testErrorAfterPanic:()=>Y(void 0,void 0,void 0,(function*(){const e=[()=>J("call_rust_no_return"),()=>j(new Uint8Array),()=>V(new Uint8Array)];for(const r of e)n(r,"Zaplib WebAssembly instance crashed");var r,a,s,o,i,f;yield(r=()=>$("call_rust_no_return"),a="Zaplib WebAssembly instance crashed",s=void 0,o=void 0,i=void 0,f=function*(){let e;try{yield r()}catch(r){e=r}t(!!e,!0),e&&t(e.message,a)},new(i||(i=Promise))((function(e,r){function t(e){try{a(f.next(e))}catch(e){r(e)}}function n(e){try{a(f.throw(e))}catch(e){r(e)}}function a(r){var a;r.done?e(r.value):(a=r.value,a instanceof i?a:new i((function(e){e(a)}))).then(t,n)}a((f=f.apply(s,o||[])).next())})))}))};K.receive("initWasm",(e=>z(e))),K.receive("runTest",(e=>Y(void 0,void 0,void 0,(function*(){return H[e]()})))),K.receive("sendWorker",(function(e){const r=(e=>{const r=p(F,e.bufferData,N,x);return new Uint8Array(r,e.byteOffset,e.byteLength)})(e);console.log("got data",r)})),K.receive("testSendZapArrayToMainThread",(function(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const r=new Uint8Array(e,2,4),t=J("array_multiply_u8",[JSON.stringify(10),r])[0];return{array:G(t),subarray:G(t.subarray(1,3))}})),K.receive("testCallRustInSameThreadSyncWithZapbuffer",(function(){const e=j(new Uint8Array([1,2,3,4,5,6,7,8])),[r]=J("array_multiply_u8",[JSON.stringify(10),e]);if("string"==typeof r)throw new Error("didn\'t expect result2 to be a string");return G(r)}))})();\n',"Worker",void 0,void 0)}),g=e=>()=>y.send("runTest",e),m=new URL(window.document.location.toString()).searchParams.has("release")?"release":"debug";let b=!1;d.initialize({wasmModule:`target/wasm32-unknown-unknown/${m}/test_suite.wasm`,defaultStyles:!0,onRenderingPanic:()=>{b=!0}}).then((()=>h(void 0,void 0,void 0,(function*(){if("wasm"===d.jsRuntime){const e=d.newWorkerPort();yield y.send("initWasm",e,[e])}d.registerCallJsCallbacks({log(e){console.log("log fn called",e[0]);const t=document.createElement("div");t.innerText="log fn called: "+e[0],(0,s.yR)(document.getElementById("root")).append(t)},sendWorker(e){const t=e[0];console.log("sending data",t),y.send("sendWorker",d.serializeZapArrayForPostMessage(t))}});const e="wasm"===d.jsRuntime?{"Call rust from worker":g("testCallRustFromWorker"),"Call rust (no return) from worker":g("testCallRustNoReturnFromWorker"),"Call rust with Float32Array from worker":g("testCallRustFloat32ArrayFromWorker"),"Call rust in same thread sync with Float32Array from worker":g("testCallRustInSameThreadSyncFloat32ArrayFromWorker"),"Test that for a worker 'inWorker' returns true":g("testInWorker"),"Send zap array to main thread":()=>h(void 0,void 0,void 0,(function*(){const e=yield y.send("testSendZapArrayToMainThread"),t=d.deserializeZapArrayFromPostMessage(e.array),r=d.deserializeZapArrayFromPostMessage(e.subarray);(0,i.l_)(t.length,4),(0,i.l_)(t[0],30),(0,i.l_)(t[1],40),(0,i.l_)(t[2],50),(0,i.l_)(t[3],60),(0,i.l_)(r.length,2),(0,i.l_)(r[0],40),(0,i.l_)(r[1],50)})),"Call Rust in same thread with zapbuffer":()=>h(void 0,void 0,void 0,(function*(){const e=yield y.send("testCallRustInSameThreadSyncWithZapbuffer"),t=d.deserializeZapArrayFromPostMessage(e);(0,i.l_)(t.length,8),(0,i.l_)(t[0],10),(0,i.l_)(t[1],20),(0,i.l_)(t[2],30),(0,i.l_)(t[3],40),(0,i.l_)(t[4],50),(0,i.l_)(t[5],60),(0,i.l_)(t[6],70),(0,i.l_)(t[7],80)})),"Send signal from worker":g("testCallRustInSameThreadSyncWithSignal")}:{"Call Rust (in same thread)":()=>{const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const t=new Uint8Array(e,2,4),[r]=d.callRustInSameThreadSync("array_multiply_u8",[JSON.stringify(10),t]);(0,i.l_)(r.length,4),(0,i.l_)(r[0],30),(0,i.l_)(r[1],40),(0,i.l_)(r[2],50),(0,i.l_)(r[3],60)},"Call Rust with Float32Array (in same thread)":()=>h(void 0,void 0,void 0,(function*(){const e=new Float32Array([.1,.9,.3]),t=d.callRustInSameThreadSync("array_multiply_f32",[JSON.stringify(10),e])[0];(0,i.l_)(t.length,3),(0,i.l_)(t[0],1),(0,i.l_)(t[1],9),(0,i.l_)(t[2],3);const r=yield d.createMutableBuffer(new Float32Array([.1,.9,.3])),n=d.callRustInSameThreadSync("array_multiply_f32",[JSON.stringify(10),r])[0];(0,i.l_)(n.length,3),(0,i.l_)(n[0],1),(0,i.l_)(n[1],9),(0,i.l_)(n[2],3);const s=yield d.createReadOnlyBuffer(new Float32Array([.1,.9,.3])),a=d.callRustInSameThreadSync("array_multiply_f32_readonly",[JSON.stringify(10),s])[0];(0,i.l_)(a.length,3),(0,i.l_)(a[0],1),(0,i.l_)(a[1],9),(0,i.l_)(a[2],3)}))},t=Object.assign(Object.assign({"Call Rust":()=>h(void 0,void 0,void 0,(function*(){const e=new SharedArrayBuffer(8);new Uint8Array(e).set([1,2,3,4,5,6,7,8]);const t=new Uint8Array(e,2,4),[r]=yield d.callRust("array_multiply_u8",[JSON.stringify(10),t]);(0,i.l_)(r.length,4),(0,i.l_)(r[0],30),(0,i.l_)(r[1],40),(0,i.l_)(r[2],50),(0,i.l_)(r[3],60)})),"Call Rust (no return)":()=>h(void 0,void 0,void 0,(function*(){const e=yield d.callRust("call_rust_no_return");(0,i.l_)(e.length,0)})),"Call Rust (string return)":()=>h(void 0,void 0,void 0,(function*(){const e=new SharedArrayBuffer(8),t=new Uint8Array(e);t.set([1,2,3,4,5,6,7,8]);const[r]=yield d.callRust("total_sum",[t]);(0,i.l_)(r,"36")})),"Call Rust (with ZapBuffer)":()=>h(void 0,void 0,void 0,(function*(){const e=yield d.createReadOnlyBuffer(new Uint8Array([1,2,3,4,5,6,7,8])),t=(yield d.callRust("array_multiply_u8_readonly",[JSON.stringify(10),e]))[0];return(0,i.l_)(t.length,8),(0,i.l_)(t[0],10),(0,i.l_)(t[1],20),(0,i.l_)(t[2],30),(0,i.l_)(t[3],40),(0,i.l_)(t[4],50),(0,i.l_)(t[5],60),(0,i.l_)(t[6],70),(0,i.l_)(t[7],80),Promise.all([p(e),p(t)])})),"Call Rust (with Mutable ZapBuffer)":()=>h(void 0,void 0,void 0,(function*(){const e=yield d.createMutableBuffer(new Uint8Array([1,2,3,4,5,6,7,8]));(0,i.l_)(e.length,8),(0,i.l_)(e[0],1),(0,i.l_)(e[1],2),(0,i.l_)(e[2],3),(0,i.l_)(e[3],4),(0,i.l_)(e[4],5),(0,i.l_)(e[5],6),(0,i.l_)(e[6],7),(0,i.l_)(e[7],8),e[0]=0,e[1]=0,e[2]=0,e[3]=0;const t=(yield d.callRust("array_multiply_u8",[JSON.stringify(10),e]))[0];return(0,i.l_)(t.length,8),(0,i.l_)(t[0],0),(0,i.l_)(t[1],0),(0,i.l_)(t[2],0),(0,i.l_)(t[3],0),(0,i.l_)(t[4],50),(0,i.l_)(t[5],60),(0,i.l_)(t[6],70),(0,i.l_)(t[7],80),Promise.all([p(e),p(t)])})),"Call Rust with Float32Array":()=>h(void 0,void 0,void 0,(function*(){const e=new Float32Array([.1,.9,.3]),t=(yield d.callRust("array_multiply_f32",[JSON.stringify(10),e]))[0];(0,i.l_)(t.length,3),(0,i.l_)(t[0],1),(0,i.l_)(t[1],9),(0,i.l_)(t[2],3);const r=yield d.createMutableBuffer(new Float32Array([.1,.9,.3])),n=(yield d.callRust("array_multiply_f32",[JSON.stringify(10),r]))[0];(0,i.l_)(n.length,3),(0,i.l_)(n[0],1),(0,i.l_)(n[1],9),(0,i.l_)(n[2],3);const s=yield d.createReadOnlyBuffer(new Float32Array([.1,.9,.3])),a=(yield d.callRust("array_multiply_f32_readonly",[JSON.stringify(10),s]))[0];return(0,i.l_)(a.length,3),(0,i.l_)(a[0],1),(0,i.l_)(a[1],9),(0,i.l_)(a[2],3),Promise.all([p(t),p(r),p(n),p(s),p(a)])})),"Cast WrBuffers":()=>h(void 0,void 0,void 0,(function*(){const e=yield d.createMutableBuffer(new Float32Array([.1])),t=new Uint8Array(e.buffer);(0,i.l_)(t.length,4),(0,i.l_)(t[0],205),(0,i.l_)(t[1],204),(0,i.l_)(t[2],204),(0,i.l_)(t[3],61),yield(0,i.eM)((()=>d.callRust("verify_cast_array",[t])),"Cannot call Rust with a buffer which has been cast to a different type. Expected F32Buffer but got U8Buffer");const r=yield d.createReadOnlyBuffer(new Float32Array([.1])),n=new Uint8Array(r.buffer);(0,i.l_)(n.length,4),(0,i.l_)(n[0],205),(0,i.l_)(n[1],204),(0,i.l_)(n[2],204),(0,i.l_)(n[3],61),yield(0,i.eM)((()=>d.callRust("verify_cast_array",[n])),"Cannot call Rust with a buffer which has been cast to a different type. Expected ReadOnlyF32Buffer but got ReadOnlyU8Buffer")})),"On the main thread inWorker returns false":()=>{(0,i.l_)(u.iO,!1)}},e),c),r=()=>h(void 0,void 0,void 0,(function*(){const e=[()=>d.callRust("call_rust_no_return"),()=>d.createMutableBuffer(new Uint8Array),()=>d.createReadOnlyBuffer(new Uint8Array)];for(const t of e)yield(0,i.eM)(t,"Zaplib WebAssembly instance crashed");yield y.send("runTest","testErrorAfterPanic")})),n="wasm"===d.jsRuntime?{"Disable RPC after panic":()=>h(void 0,void 0,void 0,(function*(){yield(0,i.eM)((()=>h(void 0,void 0,void 0,(function*(){yield d.callRust("panic")}))),"panicked at 'I am panicking!', zaplib/web/test_suite/src/main.rs:109:17"),yield r()})),"Throw error from event handling to user provided callback":()=>h(void 0,void 0,void 0,(function*(){yield d.callRust("panic_signal"),setTimeout((()=>h(void 0,void 0,void 0,(function*(){(0,i.l_)(b,!0),yield r()}))),10)})),"Throw error from draw to user provided callback":()=>h(void 0,void 0,void 0,(function*(){yield d.callRust("panic_draw"),setTimeout((()=>h(void 0,void 0,void 0,(function*(){(0,i.l_)(b,!0),yield r()}))),10)}))}:{},a=()=>{const e=(0,s.yR)(document.getElementById("root")),r=document.createElement("button");r.innerText="Run All Tests 3x",r.onclick=()=>h(void 0,void 0,void 0,(function*(){(0,i.u6)(!0);for(let e=0;e<3;e++)for(const[e,r]of Object.entries(t))console.log(`Running test: ${e}`),yield r(),console.log(" Success");console.log(" All tests completed (3x to ensure no memory corruption!)"),(0,i.u6)(!1)}));const a=document.createElement("div");a.append(r),e.append(a);for(const[r,n]of Object.entries(t)){const t=document.createElement("button");t.innerText=r,t.onclick=()=>h(void 0,void 0,void 0,(function*(){(0,i.u6)(!0),console.log(`Running test: ${r}`),yield n(),console.log(" Success"),(0,i.u6)(!1)}));const s=document.createElement("div");s.append(t),e.append(s)}const o=(0,s.yR)(document.getElementById("other-tests"));for(const[e,t]of Object.entries(n)){const r=document.createElement("button");r.innerText=e,r.onclick=()=>h(void 0,void 0,void 0,(function*(){(0,i.u6)(!0),console.log(`Running test: ${e}`),yield t(),console.log(" Success"),(0,i.u6)(!1)}));const n=document.createElement("div");n.append(r),o.append(n)}};"loading"!==document.readyState?a():document.addEventListener("DOMContentLoaded",a)}))))})(),n})()}));
//# sourceMappingURL=test_suite.js.map